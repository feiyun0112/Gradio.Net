const __vite__fileDeps=["./Index.CPt7Lj0q.js","../assets/Index.C0TCl1hH.css","./Index.BpisMbvM.js","./BlockLabel.BTMmUS9o.js","./Empty.C5uBb2Fk.js","./Minimize.BNzzPy3I.js","./Image.CMPoCWop.js","./IconButtonWrapper.IfQYleUI.js","./file-url.Bs-FMz4v.js","../assets/Index.CH2uJXwy.css","../assets/DownloadLink.wTm37iHI.css","./StaticAudio.a9A5cXcJ.js","./ShareButton.B3gcBIAK.js","./Community.4FBzcHeP.js","./Download.BLM_J5wv.js","./Music.BKn1BNLT.js","./Trim.CQ15_So8.js","./Play.wmWinRDD.js","./Undo.BEjgqHJW.js","./hls.CFPBCiRi.js","./DownloadLink.CzZp0moC.js","../assets/StaticAudio.d1C6RIRD.css","./Example.CNa918u4.js","../assets/Example.DiaQHWGN.css","./index.ClSQ7e4F.js","./preload-helper.DpQnamwV.js","./Upload.CpXh2Xm5.js","../assets/Upload.OMSDRJHz.css","./ModifyUpload.Bygvg79x.js","./SelectSource.j1x9BYNI.js","./Upload.v2Thvwuk.js","./StreamingBar.CkIfdne5.js","./UploadText.BG6Hywul.js","../assets/index.CXcK9J7T.css","./Index.Bzw0U_-f.js","./Image.eJ_qOnkr.js","../assets/Image.CYNaBOxE.css","./index.DTU9giFV.js","./Trash.phFEWuFK.js","../assets/Index.DA_XIPh3.css","../assets/ImagePreview.CBXFidgj.css","./Example.BVeuag4v.js","./Index.DmbGX_He.js","../assets/Index.CgUesbFV.css","./Example.B3uMG8lv.js","./Index.ClbzocfK.js","../assets/Index.B4zwzOds.css","./Example.C2EXtnCA.js","../assets/Example.COmDoKuI.css","./Index.D784wQ_6.js","./Code.VKlWzMBL.js","../assets/Index.Cpc8zqPC.css","./Example.D2Mw89Ip.js","../assets/Example.UAAEakYs.css","./Index.DtBJa_nn.js","./tinycolor.IwkldZk1.js","../assets/Index.Df2gU2NX.css","./Example.LJcGc8OW.js","../assets/Example.s-gSAUme.css","./Index.BPnIplJo.js","./dsv.CKxpOsHB.js","../assets/Index.DxNL_V1M.css","./Index.BqLllX5v.js","./Example.N3QsiMhe.js","../assets/Index.B1wGGoq8.css","./Index.TmZWVF_c.js","./Example.CYe6rnxa.js","../assets/Index.BT2w1lL2.css","./Index.BvrximTe.js","../assets/Index.C9aJa-R5.css","./Example.BEWyOqJ6.js","./Index.oXi7gfSd.js","./DropdownArrow.Shy1tB9t.js","../assets/Index.Chd0wpLW.css","./Example.DBkrk8px.js","../assets/Example.CniNOwBY.css","./Index.PUtlLKbd.js","./FileUpload.CLCgRYp8.js","./File.DqOJDDoa.js","../assets/FileUpload.CX39u1_F.css","./Example.CSI_-_PL.js","../assets/Example.BT9hnQY6.css","./Index.DFEwCGv-.js","../assets/Index.5XZaptZI.css","./Gallery.BQ5aYZaP.js","./Video.ML_kOajE.js","../assets/Video.BS7gIGiU.css","../assets/Gallery.DLSkpWZj.css","./Index.DI2fRCK5.js","./Index.QezQk_XN.js","../assets/Index.CM3Al4BG.css","./Index.D4RYB8FJ.js","./color.DhNifA4j.js","../assets/Index.A2SdUVuA.css","./Index.eG7Upuns.js","../assets/Index.By21hgQW.css","./Example.CGUNrbfF.js","../assets/Example.PNpjY3LI.css","./ImagePreview.CDVGjPNr.js","./utils.avOzX0x9.js","./Example.wemIBKRq.js","../assets/Example.BI_HSbIA.css","./Index.B36kMi9W.js","./ImageUploader.D4fj6zSl.js","../assets/ImageUploader.rBPXgEQK.css","./Example.BEQwiSyv.js","../assets/Example.q-HzhiHp.css","./Index.DFmX-KUe.js","./__vite-browser-external.CURh0WXD.js","../assets/Index.Bc-d5vZp.css","./Index.Duv5AmD8.js","../assets/Index.HGSBPzJx.css","./Index.DYx0ZFdb.js","./LineChart.D-OPS8mj.js","../assets/Index.Dx3_WQ06.css","./Example.BX_ByPoX.js","./Index.ChQ9Oisy.js","../assets/Index.2gNKIPgc.css","./Example.Ydb40JSe.js","./Index.BcpLSuT7.js","../assets/Index.Bn2wKUfz.css","./Example.Bdco60LN.js","../assets/Example.6livfLEN.css","./Index.BHXJpgWg.js","./Video.CzEOFOtQ.js","../assets/Index.CXpUkSuS.css","./Index.EkjABLTR.js","../assets/Index.I_mWlOg0.css","./Example.C_6qP6MW.js","./Index.rNbQZIDY.js","../assets/Index.ChNDsf5c.css","./Example.DmMqcInw.js","./Index.B7fie9U3.js","../assets/Index.BGwBwINE.css","./Plot.BhrmBiCN.js","./Index.CPxJl5Am.js","./Example.DH7CNEn-.js","./Index.wgCBRpNo.js","../assets/Index.Cf-vq2w3.css","./Index.C4rHS1C7.js","../assets/Index.BN_qRTWi.css","./Example.CTo-xuiL.js","./Index.BYRl9nej.js","../assets/Index.aP12nkUD.css","./index.CeOWPMlw.js","./Index.BaDdcX1E.js","./Tabs.D7V6q4qh.js","../assets/Tabs.ColxKYED.css","../assets/Index.BJRWfaww.css","./Index.c4wt6laL.js","./Index.BIOoGeh4.js","./Index.PmFoRO_o.js","../assets/Index.CzHwIWu3.css","./VideoPreview.kpXYMTB0.js","../assets/VideoPreview.D43CLM8T.css","./Example.HUy-V3IF.js","../assets/Example.DhjYx34x.css","./index.BHqhB4kL.js","../assets/index.CY9spOiQ.css","./Example.Ce2XkglX.js","./Index.BSvE2fZR.js","../assets/Index.DFgZ7vPU.css"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _currentLine, _parseMarkdown, parseMarkdown_fn, _onError, onError_fn, _id, _el;
import { _ as __vitePreload } from "./preload-helper.DpQnamwV.js";
import { SvelteComponent, init as init$2, safe_not_equal, create_slot, element, space, claim_element, children, detach, claim_space, attr, toggle_class, set_style, insert_hydration, append_hydration, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, component_subscribe, text as text$3, claim_text, get_svelte_dataset, set_data, binding_callbacks, svg_element, claim_svg_element, noop, create_component, claim_component, mount_component, listen, destroy_component, createEventDispatcher, empty, group_outros, check_outros, bubble, src_url_equal, onMount, assign, set_dynamic_element_data, get_spread_update, HtmlTagHydration, claim_html_tag, afterUpdate, construct_svelte_component, onDestroy, tick, ensure_array_like, destroy_each, stop_propagation, add_render_callback, create_in_transition, create_out_transition, run_all, update_keyed_each, fix_and_outro_and_destroy_block, fix_position, create_animation, not_equal, bind, get_spread_object, add_flush_callback, compute_rest_props, exclude_internal_props, setContext, outro_and_destroy_block, head_selector, globals, beforeUpdate, set_input_value, action_destroyer, is_function } from "../../../svelte/svelte.js";
import { writable, derived, get, spring, fade, flip } from "../../../svelte/svelte-submodules.js";
import { p as page } from "./stores.DcWgXC6T.js";
const BROWSER = true;
const browser = BROWSER;
var fn = new Intl.Collator(0, { numeric: 1 }).compare;
function semiver(a, b, bool) {
  a = a.split(".");
  b = b.split(".");
  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join("."), bool = /[.-]/.test(a[2] = a.slice(2).join(".")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);
}
const HOST_URL = `host`;
const SSE_URL = `queue/data`;
const SSE_DATA_URL = `queue/join`;
const UPLOAD_URL = `upload`;
const LOGIN_URL = `login`;
const CONFIG_URL = `config`;
const API_INFO_URL = `info`;
const RUNTIME_URL = `runtime`;
const SLEEPTIME_URL = `sleeptime`;
const HEARTBEAT_URL = `heartbeat`;
const COMPONENT_SERVER_URL = `component_server`;
const RESET_URL = `reset`;
const CANCEL_URL = `cancel`;
const SPACE_FETCHER_URL = "https://gradio-space-api-fetcher-v2.hf.space/api";
const QUEUE_FULL_MSG = "This application is currently busy. Please try again. ";
const BROKEN_CONNECTION_MSG = "Connection errored out. ";
const CONFIG_ERROR_MSG = "Could not resolve app config. ";
const SPACE_STATUS_ERROR_MSG = "Could not get space status. ";
const API_INFO_ERROR_MSG = "Could not get API info. ";
const SPACE_METADATA_ERROR_MSG = "Space metadata could not be loaded. ";
const INVALID_URL_MSG = "Invalid URL. A full URL path is required.";
const UNAUTHORIZED_MSG = "Not authorized to access this space. ";
const INVALID_CREDENTIALS_MSG = "Invalid credentials. Could not login. ";
const MISSING_CREDENTIALS_MSG = "Login credentials are required to access this space.";
const NODEJS_FS_ERROR_MSG = "File system access is only available in Node.js environments";
const ROOT_URL_ERROR_MSG = "Root URL not found in client config";
const FILE_PROCESSING_ERROR_MSG = "Error uploading file";
function resolve_root(base_url, root_path, prioritize_base) {
  if (root_path.startsWith("http://") || root_path.startsWith("https://")) {
    return prioritize_base ? base_url : root_path;
  }
  return base_url + root_path;
}
async function get_jwt(space2, token, cookies) {
  try {
    const r = await fetch(`https://huggingface.co/api/spaces/${space2}/jwt`, {
      headers: {
        Authorization: `Bearer ${token}`,
        ...cookies ? { Cookie: cookies } : {}
      }
    });
    const jwt = (await r.json()).token;
    return jwt || false;
  } catch (e) {
    return false;
  }
}
function map_names_to_ids(fns) {
  let apis = {};
  fns.forEach(({ api_name, id: id2 }) => {
    if (api_name)
      apis[api_name] = id2;
  });
  return apis;
}
async function resolve_config(endpoint) {
  var _a2;
  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};
  headers["Content-Type"] = "application/json";
  if (typeof window !== "undefined" && window.gradio_config && location.origin !== "http://localhost:9876" && !window.gradio_config.dev_mode) {
    const path2 = window.gradio_config.root;
    const config = window.gradio_config;
    let config_root = resolve_root(endpoint, config.root, false);
    config.root = config_root;
    return { ...config, path: path2 };
  } else if (endpoint) {
    const config_url = join_urls(endpoint, CONFIG_URL);
    const response = await this.fetch(config_url, {
      headers,
      credentials: "include"
    });
    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {
      throw new Error(MISSING_CREDENTIALS_MSG);
    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {
      throw new Error(INVALID_CREDENTIALS_MSG);
    }
    if ((response == null ? void 0 : response.status) === 200) {
      let config = await response.json();
      config.path = config.path ?? "";
      config.root = endpoint;
      (_a2 = config.dependencies) == null ? void 0 : _a2.forEach((dep, i) => {
        if (dep.id === void 0) {
          dep.id = i;
        }
      });
      return config;
    } else if ((response == null ? void 0 : response.status) === 401) {
      throw new Error(UNAUTHORIZED_MSG);
    }
    throw new Error(CONFIG_ERROR_MSG);
  }
  throw new Error(CONFIG_ERROR_MSG);
}
async function resolve_cookies() {
  const { http_protocol, host } = await process_endpoint(
    this.app_reference,
    this.options.hf_token
  );
  try {
    if (this.options.auth) {
      const cookie_header = await get_cookie_header(
        http_protocol,
        host,
        this.options.auth,
        this.fetch,
        this.options.hf_token
      );
      if (cookie_header)
        this.set_cookies(cookie_header);
    }
  } catch (e) {
    throw Error(e.message);
  }
}
async function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {
  const formData = new FormData();
  formData.append("username", auth == null ? void 0 : auth[0]);
  formData.append("password", auth == null ? void 0 : auth[1]);
  let headers = {};
  if (hf_token) {
    headers.Authorization = `Bearer ${hf_token}`;
  }
  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {
    headers,
    method: "POST",
    body: formData,
    credentials: "include"
  });
  if (res.status === 200) {
    return res.headers.get("set-cookie");
  } else if (res.status === 401) {
    throw new Error(INVALID_CREDENTIALS_MSG);
  } else {
    throw new Error(SPACE_METADATA_ERROR_MSG);
  }
}
function determine_protocol(endpoint) {
  if (endpoint.startsWith("http")) {
    const { protocol, host, pathname } = new URL(endpoint);
    return {
      ws_protocol: protocol === "https:" ? "wss" : "ws",
      http_protocol: protocol,
      host: host + (pathname !== "/" ? pathname : "")
    };
  } else if (endpoint.startsWith("file:")) {
    return {
      ws_protocol: "ws",
      http_protocol: "http:",
      host: "lite.local"
      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.
    };
  }
  return {
    ws_protocol: "wss",
    http_protocol: "https:",
    host: new URL(endpoint).host
  };
}
const parse_and_set_cookies = (cookie_header) => {
  let cookies = [];
  const parts = cookie_header.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/);
  parts.forEach((cookie) => {
    const [cookie_name, cookie_value] = cookie.split(";")[0].split("=");
    if (cookie_name && cookie_value) {
      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);
    }
  });
  return cookies;
};
const RE_SPACE_NAME = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/;
const RE_SPACE_DOMAIN = /.*hf\.space\/{0,1}.*$/;
async function process_endpoint(app_reference, hf_token) {
  const headers = {};
  if (hf_token) {
    headers.Authorization = `Bearer ${hf_token}`;
  }
  const _app_reference = app_reference.trim().replace(/\/$/, "");
  if (RE_SPACE_NAME.test(_app_reference)) {
    try {
      const res = await fetch(
        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,
        { headers }
      );
      const _host = (await res.json()).host;
      return {
        space_id: app_reference,
        ...determine_protocol(_host)
      };
    } catch (e) {
      throw new Error(SPACE_METADATA_ERROR_MSG);
    }
  }
  if (RE_SPACE_DOMAIN.test(_app_reference)) {
    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);
    return {
      space_id: host.split("/")[0].replace(".hf.space", ""),
      ws_protocol,
      http_protocol,
      host
    };
  }
  return {
    space_id: false,
    ...determine_protocol(_app_reference)
  };
}
const join_urls = (...urls) => {
  try {
    return urls.reduce((base_url, part) => {
      base_url = base_url.replace(/\/+$/, "");
      part = part.replace(/^\/+/, "");
      return new URL(part, base_url + "/").toString();
    });
  } catch (e) {
    throw new Error(INVALID_URL_MSG);
  }
};
function transform_api_info(api_info, config, api_map) {
  const transformed_info = {
    named_endpoints: {},
    unnamed_endpoints: {}
  };
  Object.keys(api_info).forEach((category) => {
    if (category === "named_endpoints" || category === "unnamed_endpoints") {
      transformed_info[category] = {};
      Object.entries(api_info[category]).forEach(
        ([endpoint, { parameters, returns }]) => {
          var _a2, _b, _c, _d;
          const dependencyIndex = ((_a2 = config.dependencies.find(
            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace("/", "")
          )) == null ? void 0 : _a2.id) || api_map[endpoint.replace("/", "")] || -1;
          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };
          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {
            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(
              (input) => {
                var _a3;
                return (_a3 = config.components.find((c) => c.id === input)) == null ? void 0 : _a3.type;
              }
            );
            try {
              components.forEach((comp, idx) => {
                if (comp === "state") {
                  const new_param = {
                    component: "state",
                    example: null,
                    parameter_default: null,
                    parameter_has_default: true,
                    parameter_name: null,
                    hidden: true
                  };
                  parameters.splice(idx, 0, new_param);
                }
              });
            } catch (e) {
              console.error(e);
            }
          }
          const transform_type = (data, component, serializer, signature_type) => ({
            ...data,
            description: get_description(data == null ? void 0 : data.type, serializer),
            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || ""
          });
          transformed_info[category][endpoint] = {
            parameters: parameters.map(
              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, "parameter")
            ),
            returns: returns.map(
              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, "return")
            ),
            type: dependencyTypes
          };
        }
      );
    }
  });
  return transformed_info;
}
function get_type(type, component, serializer, signature_type) {
  switch (type == null ? void 0 : type.type) {
    case "string":
      return "string";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
  }
  if (serializer === "JSONSerializable" || serializer === "StringSerializable") {
    return "any";
  } else if (serializer === "ListStringSerializable") {
    return "string[]";
  } else if (component === "Image") {
    return signature_type === "parameter" ? "Blob | File | Buffer" : "string";
  } else if (serializer === "FileSerializable") {
    if ((type == null ? void 0 : type.type) === "array") {
      return signature_type === "parameter" ? "(Blob | File | Buffer)[]" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;
    }
    return signature_type === "parameter" ? "Blob | File | Buffer" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;
  } else if (serializer === "GallerySerializable") {
    return signature_type === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;
  }
}
function get_description(type, serializer) {
  if (serializer === "GallerySerializable") {
    return "array of [file, label] tuples";
  } else if (serializer === "ListStringSerializable") {
    return "array of strings";
  } else if (serializer === "FileSerializable") {
    return "array of files or single file";
  }
  return type == null ? void 0 : type.description;
}
function handle_message(data, last_status) {
  const queue2 = true;
  switch (data.msg) {
    case "send_data":
      return { type: "data" };
    case "send_hash":
      return { type: "hash" };
    case "queue_full":
      return {
        type: "update",
        status: {
          queue: queue2,
          message: QUEUE_FULL_MSG,
          stage: "error",
          code: data.code,
          success: data.success
        }
      };
    case "heartbeat":
      return {
        type: "heartbeat"
      };
    case "unexpected_error":
      return {
        type: "unexpected_error",
        status: {
          queue: queue2,
          message: data.message,
          stage: "error",
          success: false
        }
      };
    case "estimation":
      return {
        type: "update",
        status: {
          queue: queue2,
          stage: last_status || "pending",
          code: data.code,
          size: data.queue_size,
          position: data.rank,
          eta: data.rank_eta,
          success: data.success
        }
      };
    case "progress":
      return {
        type: "update",
        status: {
          queue: queue2,
          stage: "pending",
          code: data.code,
          progress_data: data.progress_data,
          success: data.success
        }
      };
    case "log":
      return { type: "log", data };
    case "process_generating":
      return {
        type: "generating",
        status: {
          queue: queue2,
          message: !data.success ? data.output.error : null,
          stage: data.success ? "generating" : "error",
          code: data.code,
          progress_data: data.progress_data,
          eta: data.average_duration,
          changed_state_ids: data.success ? data.output.changed_state_ids : void 0
        },
        data: data.success ? data.output : null
      };
    case "process_streaming":
      return {
        type: "streaming",
        status: {
          queue: queue2,
          message: data.output.error,
          stage: "streaming",
          time_limit: data.time_limit,
          code: data.code,
          progress_data: data.progress_data,
          eta: data.eta
        },
        data: data.output
      };
    case "process_completed":
      if ("error" in data.output) {
        return {
          type: "update",
          status: {
            queue: queue2,
            title: data.output.title,
            message: data.output.error,
            visible: data.output.visible,
            duration: data.output.duration,
            stage: "error",
            code: data.code,
            success: data.success
          }
        };
      }
      return {
        type: "complete",
        status: {
          queue: queue2,
          message: !data.success ? data.output.error : void 0,
          stage: data.success ? "complete" : "error",
          code: data.code,
          progress_data: data.progress_data,
          changed_state_ids: data.success ? data.output.changed_state_ids : void 0
        },
        data: data.success ? data.output : null
      };
    case "process_starts":
      return {
        type: "update",
        status: {
          queue: queue2,
          stage: "pending",
          code: data.code,
          size: data.rank,
          position: 0,
          success: data.success,
          eta: data.eta
        },
        original_msg: "process_starts"
      };
  }
  return { type: "none", status: { stage: "error", queue: queue2 } };
}
const map_data_to_params = (data = [], endpoint_info) => {
  const parameters = endpoint_info ? endpoint_info.parameters : [];
  if (Array.isArray(data)) {
    if (data.length > parameters.length) {
      console.warn("Too many arguments provided for the endpoint.");
    }
    return data;
  }
  const resolved_data = [];
  const provided_keys = Object.keys(data);
  parameters.forEach((param, index) => {
    if (data.hasOwnProperty(param.parameter_name)) {
      resolved_data[index] = data[param.parameter_name];
    } else if (param.parameter_has_default) {
      resolved_data[index] = param.parameter_default;
    } else {
      throw new Error(
        `No value provided for required parameter: ${param.parameter_name}`
      );
    }
  });
  provided_keys.forEach((key) => {
    if (!parameters.some((param) => param.parameter_name === key)) {
      throw new Error(
        `Parameter \`${key}\` is not a valid keyword argument. Please refer to the API for usage.`
      );
    }
  });
  resolved_data.forEach((value, idx) => {
    if (value === void 0 && !parameters[idx].parameter_has_default) {
      throw new Error(
        `No value provided for required parameter: ${parameters[idx].parameter_name}`
      );
    }
  });
  return resolved_data;
};
async function view_api() {
  if (this.api_info)
    return this.api_info;
  const { hf_token } = this.options;
  const { config } = this;
  const headers = { "Content-Type": "application/json" };
  if (hf_token) {
    headers.Authorization = `Bearer ${hf_token}`;
  }
  if (!config) {
    return;
  }
  try {
    let response;
    let api_info;
    if (typeof window !== "undefined" && window.gradio_api_info) {
      api_info = window.gradio_api_info;
    } else {
      if (semiver((config == null ? void 0 : config.version) || "2.0.0", "3.30") < 0) {
        response = await this.fetch(SPACE_FETCHER_URL, {
          method: "POST",
          body: JSON.stringify({
            serialize: false,
            config: JSON.stringify(config)
          }),
          headers,
          credentials: "include"
        });
      } else {
        const url = join_urls(config.root, this.api_prefix, API_INFO_URL);
        response = await this.fetch(url, {
          headers,
          credentials: "include"
        });
      }
      if (!response.ok) {
        throw new Error(BROKEN_CONNECTION_MSG);
      }
      api_info = await response.json();
    }
    if ("api" in api_info) {
      api_info = api_info.api;
    }
    if (api_info.named_endpoints["/predict"] && !api_info.unnamed_endpoints["0"]) {
      api_info.unnamed_endpoints[0] = api_info.named_endpoints["/predict"];
    }
    return transform_api_info(api_info, config, this.api_map);
  } catch (e) {
    "Could not get API info. " + e.message;
  }
}
async function upload_files(root_url, files, upload_id) {
  var _a2;
  const headers = {};
  if ((_a2 = this == null ? void 0 : this.options) == null ? void 0 : _a2.hf_token) {
    headers.Authorization = `Bearer ${this.options.hf_token}`;
  }
  const chunkSize = 1e3;
  const uploadResponses = [];
  let response;
  for (let i = 0; i < files.length; i += chunkSize) {
    const chunk = files.slice(i, i + chunkSize);
    const formData = new FormData();
    chunk.forEach((file2) => {
      formData.append("files", file2);
    });
    try {
      const upload_url = upload_id ? `${root_url}${this.api_prefix}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}${this.api_prefix}/${UPLOAD_URL}`;
      response = await this.fetch(upload_url, {
        method: "POST",
        body: formData,
        headers,
        credentials: "include"
      });
    } catch (e) {
      throw new Error(BROKEN_CONNECTION_MSG + e.message);
    }
    if (!response.ok) {
      const error_text = await response.text();
      return { error: `HTTP ${response.status}: ${error_text}` };
    }
    const output = await response.json();
    if (output) {
      uploadResponses.push(...output);
    }
  }
  return { files: uploadResponses };
}
async function upload(file_data, root_url, upload_id, max_file_size) {
  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(
    (file_data2) => file_data2.blob
  );
  const oversized_files = files.filter(
    (f) => f.size > (max_file_size ?? Infinity)
  );
  if (oversized_files.length) {
    throw new Error(
      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(", ")}`
    );
  }
  return await Promise.all(
    await this.upload_files(root_url, files, upload_id).then(
      async (response) => {
        if (response.error) {
          throw new Error(response.error);
        } else {
          if (response.files) {
            return response.files.map((f, i) => {
              const file2 = new FileData({
                ...file_data[i],
                path: f,
                url: `${root_url}${this.api_prefix}/file=${f}`
              });
              return file2;
            });
          }
          return [];
        }
      }
    )
  );
}
async function prepare_files(files, is_stream) {
  return files.map(
    (f) => new FileData({
      path: f.name,
      orig_name: f.name,
      blob: f,
      size: f.size,
      mime_type: f.type,
      is_stream
    })
  );
}
class FileData {
  constructor({
    path: path2,
    url,
    orig_name,
    size,
    blob,
    is_stream,
    mime_type,
    alt_text,
    b64
  }) {
    __publicField(this, "path");
    __publicField(this, "url");
    __publicField(this, "orig_name");
    __publicField(this, "size");
    __publicField(this, "blob");
    __publicField(this, "is_stream");
    __publicField(this, "mime_type");
    __publicField(this, "alt_text");
    __publicField(this, "b64");
    __publicField(this, "meta", { _type: "gradio.FileData" });
    this.path = path2;
    this.url = url;
    this.orig_name = orig_name;
    this.size = size;
    this.blob = url ? void 0 : blob;
    this.is_stream = is_stream;
    this.mime_type = mime_type;
    this.alt_text = alt_text;
    this.b64 = b64;
  }
}
class Command {
  constructor(command, meta) {
    __publicField(this, "type");
    __publicField(this, "command");
    __publicField(this, "meta");
    __publicField(this, "fileData");
    this.type = "command";
    this.command = command;
    this.meta = meta;
  }
}
typeof process !== "undefined" && process.versions && process.versions.node;
function update_object(object, newValue, stack) {
  while (stack.length > 1) {
    const key2 = stack.shift();
    if (typeof key2 === "string" || typeof key2 === "number") {
      object = object[key2];
    } else {
      throw new Error("Invalid key type");
    }
  }
  const key = stack.shift();
  if (typeof key === "string" || typeof key === "number") {
    object[key] = newValue;
  } else {
    throw new Error("Invalid key type");
  }
}
async function walk_and_store_blobs(data, type = void 0, path2 = [], root = false, endpoint_info = void 0) {
  if (Array.isArray(data)) {
    let blob_refs = [];
    await Promise.all(
      data.map(async (_, index) => {
        var _a2;
        let new_path = path2.slice();
        new_path.push(String(index));
        const array_refs = await walk_and_store_blobs(
          data[index],
          root ? ((_a2 = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a2.component) || void 0 : type,
          new_path,
          false,
          endpoint_info
        );
        blob_refs = blob_refs.concat(array_refs);
      })
    );
    return blob_refs;
  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {
    return [
      {
        path: path2,
        blob: new Blob([data]),
        type
      }
    ];
  } else if (typeof data === "object" && data !== null) {
    let blob_refs = [];
    for (const key of Object.keys(data)) {
      const new_path = [...path2, key];
      const value = data[key];
      blob_refs = blob_refs.concat(
        await walk_and_store_blobs(
          value,
          void 0,
          new_path,
          false,
          endpoint_info
        )
      );
    }
    return blob_refs;
  }
  return [];
}
function skip_queue(id2, config) {
  var _a2, _b;
  let fn_queue = (_b = (_a2 = config == null ? void 0 : config.dependencies) == null ? void 0 : _a2.find((dep) => dep.id == id2)) == null ? void 0 : _b.queue;
  if (fn_queue != null) {
    return !fn_queue;
  }
  return !config.enable_queue;
}
function post_message(message, origin) {
  return new Promise((res, _rej) => {
    const channel = new MessageChannel();
    channel.port1.onmessage = ({ data }) => {
      channel.port1.close();
      res(data);
    };
    window.parent.postMessage(message, origin, [channel.port2]);
  });
}
function handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {
  if (type === "input" && !with_null_state) {
    throw new Error("Invalid code path. Cannot skip state inputs for input.");
  }
  if (type === "output" && with_null_state) {
    return resolved_payload;
  }
  let updated_payload = [];
  let payload_index = 0;
  const deps = type === "input" ? dependency.inputs : dependency.outputs;
  for (let i = 0; i < deps.length; i++) {
    const input_id = deps[i];
    const component = components.find((c) => c.id === input_id);
    if ((component == null ? void 0 : component.type) === "state") {
      if (with_null_state) {
        if (resolved_payload.length === deps.length) {
          const value = resolved_payload[payload_index];
          updated_payload.push(value);
          payload_index++;
        } else {
          updated_payload.push(null);
        }
      } else {
        payload_index++;
        continue;
      }
      continue;
    } else {
      const value = resolved_payload[payload_index];
      updated_payload.push(value);
      payload_index++;
    }
  }
  return updated_payload;
}
async function handle_blob(endpoint, data, api_info) {
  const self2 = this;
  await process_local_file_commands(self2, data);
  const blobRefs = await walk_and_store_blobs(
    data,
    void 0,
    [],
    true,
    api_info
  );
  const results = await Promise.all(
    blobRefs.map(async ({ path: path2, blob, type }) => {
      if (!blob)
        return { path: path2, type };
      const response = await self2.upload_files(endpoint, [blob]);
      const file_url = response.files && response.files[0];
      return {
        path: path2,
        file_url,
        type,
        name: typeof File !== "undefined" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0
      };
    })
  );
  results.forEach(({ path: path2, file_url, type, name }) => {
    if (type === "Gallery") {
      update_object(data, file_url, path2);
    } else if (file_url) {
      const file2 = new FileData({ path: file_url, orig_name: name });
      update_object(data, file2, path2);
    }
  });
  return data;
}
async function process_local_file_commands(client, data) {
  var _a2, _b;
  const root = ((_a2 = client.config) == null ? void 0 : _a2.root) || ((_b = client.config) == null ? void 0 : _b.root_url);
  if (!root) {
    throw new Error(ROOT_URL_ERROR_MSG);
  }
  await recursively_process_commands(client, data);
}
async function recursively_process_commands(client, data, path2 = []) {
  for (const key in data) {
    if (data[key] instanceof Command) {
      await process_single_command(client, data, key);
    } else if (typeof data[key] === "object" && data[key] !== null) {
      await recursively_process_commands(client, data[key], [...path2, key]);
    }
  }
}
async function process_single_command(client, data, key) {
  var _a2, _b;
  let cmd_item = data[key];
  const root = ((_a2 = client.config) == null ? void 0 : _a2.root) || ((_b = client.config) == null ? void 0 : _b.root_url);
  if (!root) {
    throw new Error(ROOT_URL_ERROR_MSG);
  }
  try {
    let fileBuffer;
    let fullPath;
    if (typeof process !== "undefined" && process.versions && process.versions.node) {
      const fs = await __vitePreload(() => import("./__vite-browser-external.CURh0WXD.js").then((n) => n._), true ? [] : void 0, import.meta.url);
      const path2 = await __vitePreload(() => import("./__vite-browser-external.CURh0WXD.js").then((n) => n._), true ? [] : void 0, import.meta.url);
      fullPath = path2.resolve(process.cwd(), cmd_item.meta.path);
      fileBuffer = await fs.readFile(fullPath);
    } else {
      throw new Error(NODEJS_FS_ERROR_MSG);
    }
    const file2 = new Blob([fileBuffer], { type: "application/octet-stream" });
    const response = await client.upload_files(root, [file2]);
    const file_url = response.files && response.files[0];
    if (file_url) {
      const fileData = new FileData({
        path: file_url,
        orig_name: cmd_item.meta.name || ""
      });
      data[key] = fileData;
    }
  } catch (error) {
    console.error(FILE_PROCESSING_ERROR_MSG, error);
  }
}
async function post_data(url, body, additional_headers) {
  const headers = { "Content-Type": "application/json" };
  if (this.options.hf_token) {
    headers.Authorization = `Bearer ${this.options.hf_token}`;
  }
  try {
    var response = await this.fetch(url, {
      method: "POST",
      body: JSON.stringify(body),
      headers: { ...headers, ...additional_headers },
      credentials: "include"
    });
  } catch (e) {
    return [{ error: BROKEN_CONNECTION_MSG }, 500];
  }
  let output;
  let status;
  try {
    output = await response.json();
    status = response.status;
  } catch (e) {
    output = { error: `Could not parse server response: ${e}` };
    status = 500;
  }
  return [output, status];
}
async function predict(endpoint, data = {}) {
  let data_returned = false;
  let status_complete = false;
  if (!this.config) {
    throw new Error("Could not resolve app config");
  }
  if (typeof endpoint === "number") {
    this.config.dependencies.find((dep) => dep.id == endpoint);
  } else {
    const trimmed_endpoint = endpoint.replace(/^\//, "");
    this.config.dependencies.find(
      (dep) => dep.id == this.api_map[trimmed_endpoint]
    );
  }
  return new Promise(async (resolve, reject) => {
    const app = this.submit(endpoint, data, null, null, true);
    let result;
    for await (const message of app) {
      if (message.type === "data") {
        if (status_complete) {
          resolve(result);
        }
        data_returned = true;
        result = message;
      }
      if (message.type === "status") {
        if (message.stage === "error")
          reject(message);
        if (message.stage === "complete") {
          status_complete = true;
          if (data_returned) {
            resolve(result);
          }
        }
      }
    }
  });
}
async function check_space_status(id2, type, status_callback) {
  let endpoint = type === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${id2}` : `https://huggingface.co/api/spaces/${id2}`;
  let response;
  let _status;
  try {
    response = await fetch(endpoint);
    _status = response.status;
    if (_status !== 200) {
      throw new Error();
    }
    response = await response.json();
  } catch (e) {
    status_callback({
      status: "error",
      load_status: "error",
      message: SPACE_STATUS_ERROR_MSG,
      detail: "NOT_FOUND"
    });
    return;
  }
  if (!response || _status !== 200)
    return;
  const {
    runtime: { stage },
    id: space_name
  } = response;
  switch (stage) {
    case "STOPPED":
    case "SLEEPING":
      status_callback({
        status: "sleeping",
        load_status: "pending",
        message: "Space is asleep. Waking it up...",
        detail: stage
      });
      setTimeout(() => {
        check_space_status(id2, type, status_callback);
      }, 1e3);
      break;
    case "PAUSED":
      status_callback({
        status: "paused",
        load_status: "error",
        message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
        detail: stage,
        discussions_enabled: await discussions_enabled(space_name)
      });
      break;
    case "RUNNING":
    case "RUNNING_BUILDING":
      status_callback({
        status: "running",
        load_status: "complete",
        message: "Space is running.",
        detail: stage
      });
      break;
    case "BUILDING":
      status_callback({
        status: "building",
        load_status: "pending",
        message: "Space is building...",
        detail: stage
      });
      setTimeout(() => {
        check_space_status(id2, type, status_callback);
      }, 1e3);
      break;
    case "APP_STARTING":
      status_callback({
        status: "starting",
        load_status: "pending",
        message: "Space is starting...",
        detail: stage
      });
      setTimeout(() => {
        check_space_status(id2, type, status_callback);
      }, 1e3);
      break;
    default:
      status_callback({
        status: "space_error",
        load_status: "error",
        message: "This space is experiencing an issue.",
        detail: stage,
        discussions_enabled: await discussions_enabled(space_name)
      });
      break;
  }
}
const check_and_wake_space = async (space_id, status_callback) => {
  let retries = 0;
  const max_retries = 12;
  const check_interval = 5e3;
  return new Promise((resolve) => {
    check_space_status(
      space_id,
      RE_SPACE_NAME.test(space_id) ? "space_name" : "subdomain",
      (status) => {
        status_callback(status);
        if (status.status === "running") {
          resolve();
        } else if (status.status === "error" || status.status === "paused" || status.status === "space_error") {
          resolve();
        } else if (status.status === "sleeping" || status.status === "building") {
          if (retries < max_retries) {
            retries++;
            setTimeout(() => {
              check_and_wake_space(space_id, status_callback).then(resolve);
            }, check_interval);
          } else {
            resolve();
          }
        }
      }
    );
  });
};
const RE_DISABLED_DISCUSSION = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
async function discussions_enabled(space_id) {
  try {
    const r = await fetch(
      `https://huggingface.co/api/spaces/${space_id}/discussions`,
      {
        method: "HEAD"
      }
    );
    const error = r.headers.get("x-error-message");
    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))
      return false;
    return true;
  } catch (e) {
    return false;
  }
}
async function get_space_hardware(space_id, hf_token) {
  const headers = {};
  if (hf_token) {
    headers.Authorization = `Bearer ${hf_token}`;
  }
  try {
    const res = await fetch(
      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,
      { headers }
    );
    if (res.status !== 200)
      throw new Error("Space hardware could not be obtained.");
    const { hardware } = await res.json();
    return hardware.current;
  } catch (e) {
    throw new Error(e.message);
  }
}
async function set_space_timeout(space_id, timeout, hf_token) {
  const headers = {};
  if (hf_token) {
    headers.Authorization = `Bearer ${hf_token}`;
  }
  const body = {
    seconds: timeout
  };
  try {
    const res = await fetch(
      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", ...headers },
        body: JSON.stringify(body)
      }
    );
    if (res.status !== 200) {
      throw new Error(
        "Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."
      );
    }
    const response = await res.json();
    return response;
  } catch (e) {
    throw new Error(e.message);
  }
}
const hardware_types = [
  "cpu-basic",
  "cpu-upgrade",
  "cpu-xl",
  "t4-small",
  "t4-medium",
  "a10g-small",
  "a10g-large",
  "a10g-largex2",
  "a10g-largex4",
  "a100-large",
  "zero-a10g",
  "h100",
  "h100x8"
];
async function duplicate(app_reference, options2) {
  const { hf_token, private: _private, hardware, timeout, auth } = options2;
  if (hardware && !hardware_types.includes(hardware)) {
    throw new Error(
      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `"${v}"`).join(",")}.`
    );
  }
  const { http_protocol, host } = await process_endpoint(
    app_reference,
    hf_token
  );
  let cookies = null;
  if (auth) {
    const cookie_header = await get_cookie_header(
      http_protocol,
      host,
      auth,
      fetch
    );
    if (cookie_header)
      cookies = parse_and_set_cookies(cookie_header);
  }
  const headers = {
    Authorization: `Bearer ${hf_token}`,
    "Content-Type": "application/json",
    ...cookies ? { Cookie: cookies.join("; ") } : {}
  };
  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {
    headers
  })).json()).name;
  const space_name = app_reference.split("/")[1];
  const body = {
    repository: `${user}/${space_name}`
  };
  if (_private) {
    body.private = true;
  }
  let original_hardware;
  try {
    if (!hardware) {
      original_hardware = await get_space_hardware(app_reference, hf_token);
    }
  } catch (e) {
    throw Error(SPACE_METADATA_ERROR_MSG + e.message);
  }
  const requested_hardware = hardware || original_hardware || "cpu-basic";
  body.hardware = requested_hardware;
  try {
    const response = await fetch(
      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,
      {
        method: "POST",
        headers,
        body: JSON.stringify(body)
      }
    );
    if (response.status === 409) {
      try {
        const client = await Client.connect(`${user}/${space_name}`, options2);
        return client;
      } catch (error) {
        console.error("Failed to connect Client instance:", error);
        throw error;
      }
    } else if (response.status !== 200) {
      throw new Error(response.statusText);
    }
    const duplicated_space = await response.json();
    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);
    return await Client.connect(
      get_space_reference(duplicated_space.url),
      options2
    );
  } catch (e) {
    throw new Error(e);
  }
}
function get_space_reference(url) {
  const regex2 = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/;
  const match = url.match(regex2);
  if (match) {
    return match[1];
  }
}
class TextLineStream extends TransformStream {
  /** Constructs a new instance. */
  constructor(options2 = { allowCR: false }) {
    super({
      transform: (chars, controller) => {
        chars = __privateGet(this, _currentLine) + chars;
        while (true) {
          const lfIndex = chars.indexOf("\n");
          const crIndex = options2.allowCR ? chars.indexOf("\r") : -1;
          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
            controller.enqueue(chars.slice(0, crIndex));
            chars = chars.slice(crIndex + 1);
            continue;
          }
          if (lfIndex === -1)
            break;
          const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
          controller.enqueue(chars.slice(0, endIndex));
          chars = chars.slice(lfIndex + 1);
        }
        __privateSet(this, _currentLine, chars);
      },
      flush: (controller) => {
        if (__privateGet(this, _currentLine) === "")
          return;
        const currentLine = options2.allowCR && __privateGet(this, _currentLine).endsWith("\r") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);
        controller.enqueue(currentLine);
      }
    });
    __privateAdd(this, _currentLine, "");
  }
}
_currentLine = new WeakMap();
function stream$1(input) {
  let decoder = new TextDecoderStream();
  let split2 = new TextLineStream({ allowCR: true });
  return input.pipeThrough(decoder).pipeThrough(split2);
}
function split(input) {
  let rgx = /[:]\s*/;
  let match = rgx.exec(input);
  let idx = match && match.index;
  if (idx) {
    return [
      input.substring(0, idx),
      input.substring(idx + match[0].length)
    ];
  }
}
function fallback(headers, key, value) {
  let tmp = headers.get(key);
  if (!tmp)
    headers.set(key, value);
}
async function* events(res, signal) {
  if (!res.body)
    return;
  let iter = stream$1(res.body);
  let line, reader = iter.getReader();
  let event;
  for (; ; ) {
    if (signal && signal.aborted) {
      return reader.cancel();
    }
    line = await reader.read();
    if (line.done)
      return;
    if (!line.value) {
      if (event)
        yield event;
      event = void 0;
      continue;
    }
    let [field, value] = split(line.value) || [];
    if (!field)
      continue;
    if (field === "data") {
      event || (event = {});
      event[field] = event[field] ? event[field] + "\n" + value : value;
    } else if (field === "event") {
      event || (event = {});
      event[field] = value;
    } else if (field === "id") {
      event || (event = {});
      event[field] = +value || value;
    } else if (field === "retry") {
      event || (event = {});
      event[field] = +value || void 0;
    }
  }
}
async function stream(input, init2) {
  let req = new Request(input, init2);
  fallback(req.headers, "Accept", "text/event-stream");
  fallback(req.headers, "Content-Type", "application/json");
  let r = await fetch(req);
  if (!r.ok)
    throw r;
  return events(r, req.signal);
}
async function open_stream() {
  let {
    event_callbacks,
    unclosed_events,
    pending_stream_messages,
    stream_status,
    config,
    jwt
  } = this;
  const that = this;
  if (!config) {
    throw new Error("Could not resolve app config");
  }
  stream_status.open = true;
  let stream2 = null;
  let params = new URLSearchParams({
    session_hash: this.session_hash
  }).toString();
  let url = new URL(`${config.root}${this.api_prefix}/${SSE_URL}?${params}`);
  if (jwt) {
    url.searchParams.set("__sign", jwt);
  }
  stream2 = this.stream(url);
  if (!stream2) {
    console.warn("Cannot connect to SSE endpoint: " + url.toString());
    return;
  }
  stream2.onmessage = async function(event) {
    let _data = JSON.parse(event.data);
    if (_data.msg === "close_stream") {
      close_stream(stream_status, that.abort_controller);
      return;
    }
    const event_id = _data.event_id;
    if (!event_id) {
      await Promise.all(
        Object.keys(event_callbacks).map(
          (event_id2) => event_callbacks[event_id2](_data)
        )
      );
    } else if (event_callbacks[event_id] && config) {
      if (_data.msg === "process_completed" && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(
        config.protocol
      )) {
        unclosed_events.delete(event_id);
      }
      let fn2 = event_callbacks[event_id];
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        setTimeout(fn2, 0, _data);
      } else {
        fn2(_data);
      }
    } else {
      if (!pending_stream_messages[event_id]) {
        pending_stream_messages[event_id] = [];
      }
      pending_stream_messages[event_id].push(_data);
    }
  };
  stream2.onerror = async function() {
    await Promise.all(
      Object.keys(event_callbacks).map(
        (event_id) => event_callbacks[event_id]({
          msg: "unexpected_error",
          message: BROKEN_CONNECTION_MSG
        })
      )
    );
  };
}
function close_stream(stream_status, abort_controller) {
  if (stream_status) {
    stream_status.open = false;
    abort_controller == null ? void 0 : abort_controller.abort();
  }
}
function apply_diff_stream(pending_diff_streams, event_id, data) {
  let is_first_generation = !pending_diff_streams[event_id];
  if (is_first_generation) {
    pending_diff_streams[event_id] = [];
    data.data.forEach((value, i) => {
      pending_diff_streams[event_id][i] = value;
    });
  } else {
    data.data.forEach((value, i) => {
      let new_data = apply_diff(pending_diff_streams[event_id][i], value);
      pending_diff_streams[event_id][i] = new_data;
      data.data[i] = new_data;
    });
  }
}
function apply_diff(obj, diff) {
  diff.forEach(([action, path2, value]) => {
    obj = apply_edit(obj, path2, action, value);
  });
  return obj;
}
function apply_edit(target, path2, action, value) {
  if (path2.length === 0) {
    if (action === "replace") {
      return value;
    } else if (action === "append") {
      return target + value;
    }
    throw new Error(`Unsupported action: ${action}`);
  }
  let current2 = target;
  for (let i = 0; i < path2.length - 1; i++) {
    current2 = current2[path2[i]];
  }
  const last_path = path2[path2.length - 1];
  switch (action) {
    case "replace":
      current2[last_path] = value;
      break;
    case "append":
      current2[last_path] += value;
      break;
    case "add":
      if (Array.isArray(current2)) {
        current2.splice(Number(last_path), 0, value);
      } else {
        current2[last_path] = value;
      }
      break;
    case "delete":
      if (Array.isArray(current2)) {
        current2.splice(Number(last_path), 1);
      } else {
        delete current2[last_path];
      }
      break;
    default:
      throw new Error(`Unknown action: ${action}`);
  }
  return target;
}
function readable_stream(input, init2 = {}) {
  const instance2 = {
    close: () => {
      console.warn("Method not implemented.");
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    url: input.toString(),
    withCredentials: false,
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    addEventListener: () => {
      throw new Error("Method not implemented.");
    },
    dispatchEvent: () => {
      throw new Error("Method not implemented.");
    },
    removeEventListener: () => {
      throw new Error("Method not implemented.");
    }
  };
  stream(input, init2).then(async (res) => {
    instance2.readyState = instance2.OPEN;
    try {
      for await (const chunk of res) {
        instance2.onmessage && instance2.onmessage(chunk);
      }
      instance2.readyState = instance2.CLOSED;
    } catch (e) {
      instance2.onerror && instance2.onerror(e);
      instance2.readyState = instance2.CLOSED;
    }
  }).catch((e) => {
    console.error(e);
    instance2.onerror && instance2.onerror(e);
    instance2.readyState = instance2.CLOSED;
  });
  return instance2;
}
function submit(endpoint, data = {}, event_data, trigger_id, all_events) {
  var _a2;
  try {
    let fire_event = function(event) {
      if (all_events || events_to_publish[event.type]) {
        push_event(event);
      }
    }, close2 = function() {
      done = true;
      while (resolvers.length > 0)
        resolvers.shift()({
          value: void 0,
          done: true
        });
    }, push = function(data2) {
      if (done)
        return;
      if (resolvers.length > 0) {
        resolvers.shift()(data2);
      } else {
        values.push(data2);
      }
    }, push_error = function(error) {
      push(thenable_reject(error));
      close2();
    }, push_event = function(event) {
      push({ value: event, done: false });
    }, next = function() {
      if (values.length > 0)
        return Promise.resolve(values.shift());
      if (done)
        return Promise.resolve({ value: void 0, done: true });
      return new Promise((resolve) => resolvers.push(resolve));
    };
    const { hf_token } = this.options;
    const {
      fetch: fetch2,
      app_reference,
      config,
      session_hash,
      api_info,
      api_map,
      stream_status,
      pending_stream_messages,
      pending_diff_streams,
      event_callbacks,
      unclosed_events,
      post_data: post_data2,
      options: options2,
      api_prefix
    } = this;
    const that = this;
    if (!api_info)
      throw new Error("No API found");
    if (!config)
      throw new Error("Could not resolve app config");
    let { fn_index, endpoint_info, dependency } = get_endpoint_info(
      api_info,
      endpoint,
      api_map,
      config
    );
    let resolved_data = map_data_to_params(data, endpoint_info);
    let websocket;
    let stream2;
    let protocol = config.protocol ?? "ws";
    let event_id_final = "";
    let event_id_cb = () => event_id_final;
    const _endpoint = typeof endpoint === "number" ? "/predict" : endpoint;
    let payload;
    let event_id = null;
    let complete = false;
    let last_status = {};
    let url_params = typeof window !== "undefined" && typeof document !== "undefined" ? new URLSearchParams(window.location.search).toString() : "";
    const events_to_publish = ((_a2 = options2 == null ? void 0 : options2.events) == null ? void 0 : _a2.reduce(
      (acc, event) => {
        acc[event] = true;
        return acc;
      },
      {}
    )) || {};
    async function cancel() {
      const _status = {
        stage: "complete",
        queue: false,
        time: /* @__PURE__ */ new Date()
      };
      complete = _status;
      fire_event({
        ..._status,
        type: "status",
        endpoint: _endpoint,
        fn_index
      });
      let reset_request = {};
      let cancel_request = {};
      if (protocol === "ws") {
        if (websocket && websocket.readyState === 0) {
          websocket.addEventListener("open", () => {
            websocket.close();
          });
        } else {
          websocket.close();
        }
        reset_request = { fn_index, session_hash };
      } else {
        close_stream(stream_status, that.abort_controller);
        close2();
        reset_request = { event_id };
        cancel_request = { event_id, session_hash, fn_index };
      }
      try {
        if (!config) {
          throw new Error("Could not resolve app config");
        }
        if ("event_id" in cancel_request) {
          await fetch2(`${config.root}${api_prefix}/${CANCEL_URL}`, {
            headers: { "Content-Type": "application/json" },
            method: "POST",
            body: JSON.stringify(cancel_request)
          });
        }
        await fetch2(`${config.root}${api_prefix}/${RESET_URL}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(reset_request)
        });
      } catch (e) {
        console.warn(
          "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
        );
      }
    }
    const resolve_heartbeat = async (config2) => {
      await this._resolve_hearbeat(config2);
    };
    async function handle_render_config(render_config) {
      if (!config)
        return;
      let render_id = render_config.render_id;
      config.components = [
        ...config.components.filter((c) => c.props.rendered_in !== render_id),
        ...render_config.components
      ];
      config.dependencies = [
        ...config.dependencies.filter((d) => d.rendered_in !== render_id),
        ...render_config.dependencies
      ];
      const any_state = config.components.some((c) => c.type === "state");
      const any_unload = config.dependencies.some(
        (d) => d.targets.some((t) => t[1] === "unload")
      );
      config.connect_heartbeat = any_state || any_unload;
      await resolve_heartbeat(config);
      fire_event({
        type: "render",
        data: render_config,
        endpoint: _endpoint,
        fn_index
      });
    }
    this.handle_blob(config.root, resolved_data, endpoint_info).then(
      async (_payload) => {
        var _a3;
        let input_data = handle_payload(
          _payload,
          dependency,
          config.components,
          "input",
          true
        );
        payload = {
          data: input_data || [],
          event_data,
          fn_index,
          trigger_id
        };
        if (skip_queue(fn_index, config)) {
          fire_event({
            type: "status",
            endpoint: _endpoint,
            stage: "pending",
            queue: false,
            fn_index,
            time: /* @__PURE__ */ new Date()
          });
          post_data2(
            `${config.root}${api_prefix}/run${_endpoint.startsWith("/") ? _endpoint : `/${_endpoint}`}${url_params ? "?" + url_params : ""}`,
            {
              ...payload,
              session_hash
            }
          ).then(([output, status_code]) => {
            const data2 = output.data;
            if (status_code == 200) {
              fire_event({
                type: "data",
                endpoint: _endpoint,
                fn_index,
                data: handle_payload(
                  data2,
                  dependency,
                  config.components,
                  "output",
                  options2.with_null_state
                ),
                time: /* @__PURE__ */ new Date(),
                event_data,
                trigger_id
              });
              if (output.render_config) {
                handle_render_config(output.render_config);
              }
              fire_event({
                type: "status",
                endpoint: _endpoint,
                fn_index,
                stage: "complete",
                eta: output.average_duration,
                queue: false,
                time: /* @__PURE__ */ new Date()
              });
            } else {
              fire_event({
                type: "status",
                stage: "error",
                endpoint: _endpoint,
                fn_index,
                message: output.error,
                queue: false,
                time: /* @__PURE__ */ new Date()
              });
            }
          }).catch((e) => {
            fire_event({
              type: "status",
              stage: "error",
              message: e.message,
              endpoint: _endpoint,
              fn_index,
              queue: false,
              time: /* @__PURE__ */ new Date()
            });
          });
        } else if (protocol == "ws") {
          const { ws_protocol, host } = await process_endpoint(
            app_reference,
            hf_token
          );
          fire_event({
            type: "status",
            stage: "pending",
            queue: true,
            endpoint: _endpoint,
            fn_index,
            time: /* @__PURE__ */ new Date()
          });
          let url = new URL(
            `${ws_protocol}://${resolve_root(
              host,
              config.path,
              true
            )}/queue/join${url_params ? "?" + url_params : ""}`
          );
          if (this.jwt) {
            url.searchParams.set("__sign", this.jwt);
          }
          websocket = new WebSocket(url);
          websocket.onclose = (evt) => {
            if (!evt.wasClean) {
              fire_event({
                type: "status",
                stage: "error",
                broken: true,
                message: BROKEN_CONNECTION_MSG,
                queue: true,
                endpoint: _endpoint,
                fn_index,
                time: /* @__PURE__ */ new Date()
              });
            }
          };
          websocket.onmessage = function(event) {
            const _data = JSON.parse(event.data);
            const { type, status, data: data2 } = handle_message(
              _data,
              last_status[fn_index]
            );
            if (type === "update" && status && !complete) {
              fire_event({
                type: "status",
                endpoint: _endpoint,
                fn_index,
                time: /* @__PURE__ */ new Date(),
                ...status
              });
              if (status.stage === "error") {
                websocket.close();
              }
            } else if (type === "hash") {
              websocket.send(JSON.stringify({ fn_index, session_hash }));
              return;
            } else if (type === "data") {
              websocket.send(JSON.stringify({ ...payload, session_hash }));
            } else if (type === "complete") {
              complete = status;
            } else if (type === "log") {
              fire_event({
                type: "log",
                title: data2.title,
                log: data2.log,
                level: data2.level,
                endpoint: _endpoint,
                duration: data2.duration,
                visible: data2.visible,
                fn_index
              });
            } else if (type === "generating") {
              fire_event({
                type: "status",
                time: /* @__PURE__ */ new Date(),
                ...status,
                stage: status == null ? void 0 : status.stage,
                queue: true,
                endpoint: _endpoint,
                fn_index
              });
            }
            if (data2) {
              fire_event({
                type: "data",
                time: /* @__PURE__ */ new Date(),
                data: handle_payload(
                  data2.data,
                  dependency,
                  config.components,
                  "output",
                  options2.with_null_state
                ),
                endpoint: _endpoint,
                fn_index,
                event_data,
                trigger_id
              });
              if (complete) {
                fire_event({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...complete,
                  stage: status == null ? void 0 : status.stage,
                  queue: true,
                  endpoint: _endpoint,
                  fn_index
                });
                websocket.close();
              }
            }
          };
          if (semiver(config.version || "2.0.0", "3.6") < 0) {
            addEventListener(
              "open",
              () => websocket.send(JSON.stringify({ hash: session_hash }))
            );
          }
        } else if (protocol == "sse") {
          fire_event({
            type: "status",
            stage: "pending",
            queue: true,
            endpoint: _endpoint,
            fn_index,
            time: /* @__PURE__ */ new Date()
          });
          var params = new URLSearchParams({
            fn_index: fn_index.toString(),
            session_hash
          }).toString();
          let url = new URL(
            `${config.root}${api_prefix}/${SSE_URL}?${url_params ? url_params + "&" : ""}${params}`
          );
          if (this.jwt) {
            url.searchParams.set("__sign", this.jwt);
          }
          stream2 = this.stream(url);
          if (!stream2) {
            return Promise.reject(
              new Error("Cannot connect to SSE endpoint: " + url.toString())
            );
          }
          stream2.onmessage = async function(event) {
            const _data = JSON.parse(event.data);
            const { type, status, data: data2 } = handle_message(
              _data,
              last_status[fn_index]
            );
            if (type === "update" && status && !complete) {
              fire_event({
                type: "status",
                endpoint: _endpoint,
                fn_index,
                time: /* @__PURE__ */ new Date(),
                ...status
              });
              if (status.stage === "error") {
                stream2 == null ? void 0 : stream2.close();
                close2();
              }
            } else if (type === "data") {
              let [_, status2] = await post_data2(
                `${config.root}${api_prefix}/queue/data`,
                {
                  ...payload,
                  session_hash,
                  event_id
                }
              );
              if (status2 !== 200) {
                fire_event({
                  type: "status",
                  stage: "error",
                  message: BROKEN_CONNECTION_MSG,
                  queue: true,
                  endpoint: _endpoint,
                  fn_index,
                  time: /* @__PURE__ */ new Date()
                });
                stream2 == null ? void 0 : stream2.close();
                close2();
              }
            } else if (type === "complete") {
              complete = status;
            } else if (type === "log") {
              fire_event({
                type: "log",
                title: data2.title,
                log: data2.log,
                level: data2.level,
                endpoint: _endpoint,
                duration: data2.duration,
                visible: data2.visible,
                fn_index
              });
            } else if (type === "generating" || type === "streaming") {
              fire_event({
                type: "status",
                time: /* @__PURE__ */ new Date(),
                ...status,
                stage: status == null ? void 0 : status.stage,
                queue: true,
                endpoint: _endpoint,
                fn_index
              });
            }
            if (data2) {
              fire_event({
                type: "data",
                time: /* @__PURE__ */ new Date(),
                data: handle_payload(
                  data2.data,
                  dependency,
                  config.components,
                  "output",
                  options2.with_null_state
                ),
                endpoint: _endpoint,
                fn_index,
                event_data,
                trigger_id
              });
              if (complete) {
                fire_event({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...complete,
                  stage: status == null ? void 0 : status.stage,
                  queue: true,
                  endpoint: _endpoint,
                  fn_index
                });
                stream2 == null ? void 0 : stream2.close();
                close2();
              }
            }
          };
        } else if (protocol == "sse_v1" || protocol == "sse_v2" || protocol == "sse_v2.1" || protocol == "sse_v3") {
          fire_event({
            type: "status",
            stage: "pending",
            queue: true,
            endpoint: _endpoint,
            fn_index,
            time: /* @__PURE__ */ new Date()
          });
          let hostname = "";
          if (typeof window !== "undefined" && typeof document !== "undefined") {
            hostname = (_a3 = window == null ? void 0 : window.location) == null ? void 0 : _a3.hostname;
          }
          let hfhubdev = "dev.spaces.huggingface.tech";
          const origin = hostname.includes(".dev.") ? `https://moon-${hostname.split(".")[1]}.${hfhubdev}` : `https://huggingface.co`;
          const is_iframe = typeof window !== "undefined" && typeof document !== "undefined" && window.parent != window;
          const is_zerogpu_space = dependency.zerogpu && config.space_id;
          const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message("zerogpu-headers", origin) : Promise.resolve(null);
          const post_data_promise = zerogpu_auth_promise.then((headers) => {
            return post_data2(
              `${config.root}${api_prefix}/${SSE_DATA_URL}?${url_params}`,
              {
                ...payload,
                session_hash
              },
              headers
            );
          });
          post_data_promise.then(async ([response, status]) => {
            if (status === 503) {
              fire_event({
                type: "status",
                stage: "error",
                message: QUEUE_FULL_MSG,
                queue: true,
                endpoint: _endpoint,
                fn_index,
                time: /* @__PURE__ */ new Date()
              });
            } else if (status !== 200) {
              fire_event({
                type: "status",
                stage: "error",
                message: BROKEN_CONNECTION_MSG,
                queue: true,
                endpoint: _endpoint,
                fn_index,
                time: /* @__PURE__ */ new Date()
              });
            } else {
              event_id = response.event_id;
              event_id_final = event_id;
              let callback = async function(_data) {
                try {
                  const { type, status: status2, data: data2, original_msg } = handle_message(
                    _data,
                    last_status[fn_index]
                  );
                  if (type == "heartbeat") {
                    return;
                  }
                  if (type === "update" && status2 && !complete) {
                    fire_event({
                      type: "status",
                      endpoint: _endpoint,
                      fn_index,
                      time: /* @__PURE__ */ new Date(),
                      original_msg,
                      ...status2
                    });
                  } else if (type === "complete") {
                    complete = status2;
                  } else if (type == "unexpected_error") {
                    console.error("Unexpected error", status2 == null ? void 0 : status2.message);
                    fire_event({
                      type: "status",
                      stage: "error",
                      message: (status2 == null ? void 0 : status2.message) || "An Unexpected Error Occurred!",
                      queue: true,
                      endpoint: _endpoint,
                      fn_index,
                      time: /* @__PURE__ */ new Date()
                    });
                  } else if (type === "log") {
                    fire_event({
                      type: "log",
                      title: data2.title,
                      log: data2.log,
                      level: data2.level,
                      endpoint: _endpoint,
                      duration: data2.duration,
                      visible: data2.visible,
                      fn_index
                    });
                    return;
                  } else if (type === "generating" || type === "streaming") {
                    fire_event({
                      type: "status",
                      time: /* @__PURE__ */ new Date(),
                      ...status2,
                      stage: status2 == null ? void 0 : status2.stage,
                      queue: true,
                      endpoint: _endpoint,
                      fn_index
                    });
                    if (data2 && dependency.connection !== "stream" && ["sse_v2", "sse_v2.1", "sse_v3"].includes(protocol)) {
                      apply_diff_stream(pending_diff_streams, event_id, data2);
                    }
                  }
                  if (data2) {
                    fire_event({
                      type: "data",
                      time: /* @__PURE__ */ new Date(),
                      data: handle_payload(
                        data2.data,
                        dependency,
                        config.components,
                        "output",
                        options2.with_null_state
                      ),
                      endpoint: _endpoint,
                      fn_index
                    });
                    if (data2.render_config) {
                      await handle_render_config(data2.render_config);
                    }
                    if (complete) {
                      fire_event({
                        type: "status",
                        time: /* @__PURE__ */ new Date(),
                        ...complete,
                        stage: status2 == null ? void 0 : status2.stage,
                        queue: true,
                        endpoint: _endpoint,
                        fn_index
                      });
                      close2();
                    }
                  }
                  if ((status2 == null ? void 0 : status2.stage) === "complete" || (status2 == null ? void 0 : status2.stage) === "error") {
                    if (event_callbacks[event_id]) {
                      delete event_callbacks[event_id];
                    }
                    if (event_id in pending_diff_streams) {
                      delete pending_diff_streams[event_id];
                    }
                  }
                } catch (e) {
                  console.error("Unexpected client exception", e);
                  fire_event({
                    type: "status",
                    stage: "error",
                    message: "An Unexpected Error Occurred!",
                    queue: true,
                    endpoint: _endpoint,
                    fn_index,
                    time: /* @__PURE__ */ new Date()
                  });
                  if (["sse_v2", "sse_v2.1", "sse_v3"].includes(protocol)) {
                    close_stream(stream_status, that.abort_controller);
                    stream_status.open = false;
                    close2();
                  }
                }
              };
              if (event_id in pending_stream_messages) {
                pending_stream_messages[event_id].forEach(
                  (msg) => callback(msg)
                );
                delete pending_stream_messages[event_id];
              }
              event_callbacks[event_id] = callback;
              unclosed_events.add(event_id);
              if (!stream_status.open) {
                await this.open_stream();
              }
            }
          });
        }
      }
    );
    let done = false;
    const values = [];
    const resolvers = [];
    const iterator = {
      [Symbol.asyncIterator]: () => iterator,
      next,
      throw: async (value) => {
        push_error(value);
        return next();
      },
      return: async () => {
        close2();
        return next();
      },
      cancel,
      event_id: event_id_cb
    };
    return iterator;
  } catch (error) {
    console.error("Submit function encountered an error:", error);
    throw error;
  }
}
function thenable_reject(error) {
  return {
    then: (resolve, reject) => reject(error)
  };
}
function get_endpoint_info(api_info, endpoint, api_map, config) {
  let fn_index;
  let endpoint_info;
  let dependency;
  if (typeof endpoint === "number") {
    fn_index = endpoint;
    endpoint_info = api_info.unnamed_endpoints[fn_index];
    dependency = config.dependencies.find((dep) => dep.id == endpoint);
  } else {
    const trimmed_endpoint = endpoint.replace(/^\//, "");
    fn_index = api_map[trimmed_endpoint];
    endpoint_info = api_info.named_endpoints[endpoint.trim()];
    dependency = config.dependencies.find(
      (dep) => dep.id == api_map[trimmed_endpoint]
    );
  }
  if (typeof fn_index !== "number") {
    throw new Error(
      "There is no endpoint matching that name of fn_index matching that number."
    );
  }
  return { fn_index, endpoint_info, dependency };
}
class Client {
  constructor(app_reference, options2 = { events: ["data"] }) {
    __publicField(this, "app_reference");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "api_prefix", "");
    __publicField(this, "api_info");
    __publicField(this, "api_map", {});
    __publicField(this, "session_hash", Math.random().toString(36).substring(2));
    __publicField(this, "jwt", false);
    __publicField(this, "last_status", {});
    __publicField(this, "cookies", null);
    // streaming
    __publicField(this, "stream_status", { open: false });
    __publicField(this, "pending_stream_messages", {});
    __publicField(this, "pending_diff_streams", {});
    __publicField(this, "event_callbacks", {});
    __publicField(this, "unclosed_events", /* @__PURE__ */ new Set());
    __publicField(this, "heartbeat_event", null);
    __publicField(this, "abort_controller", null);
    __publicField(this, "stream_instance", null);
    __publicField(this, "current_payload");
    __publicField(this, "ws_map", {});
    __publicField(this, "view_api");
    __publicField(this, "upload_files");
    __publicField(this, "upload");
    __publicField(this, "handle_blob");
    __publicField(this, "post_data");
    __publicField(this, "submit");
    __publicField(this, "predict");
    __publicField(this, "open_stream");
    __publicField(this, "resolve_config");
    __publicField(this, "resolve_cookies");
    this.app_reference = app_reference;
    if (!options2.events) {
      options2.events = ["data"];
    }
    this.options = options2;
    this.current_payload = {};
    this.view_api = view_api.bind(this);
    this.upload_files = upload_files.bind(this);
    this.handle_blob = handle_blob.bind(this);
    this.post_data = post_data.bind(this);
    this.submit = submit.bind(this);
    this.predict = predict.bind(this);
    this.open_stream = open_stream.bind(this);
    this.resolve_config = resolve_config.bind(this);
    this.resolve_cookies = resolve_cookies.bind(this);
    this.upload = upload.bind(this);
    this.fetch = this.fetch.bind(this);
    this.handle_space_success = this.handle_space_success.bind(this);
    this.stream = this.stream.bind(this);
  }
  fetch(input, init2) {
    const headers = new Headers((init2 == null ? void 0 : init2.headers) || {});
    if (this && this.cookies) {
      headers.append("Cookie", this.cookies);
    }
    return fetch(input, { ...init2, headers });
  }
  stream(url) {
    const headers = new Headers();
    if (this && this.cookies) {
      headers.append("Cookie", this.cookies);
    }
    this.abort_controller = new AbortController();
    this.stream_instance = readable_stream(url.toString(), {
      credentials: "include",
      headers,
      signal: this.abort_controller.signal
    });
    return this.stream_instance;
  }
  async init() {
    var _a2;
    if ((typeof window === "undefined" || !("WebSocket" in window)) && !global.WebSocket) {
      const ws = await __vitePreload(() => import("./browser.C60xexX8.js").then((n) => n.b), true ? [] : void 0, import.meta.url);
      global.WebSocket = ws.WebSocket;
    }
    if (this.options.auth) {
      await this.resolve_cookies();
    }
    await this._resolve_config().then(
      ({ config }) => this._resolve_hearbeat(config)
    );
    this.api_info = await this.view_api();
    this.api_map = map_names_to_ids(((_a2 = this.config) == null ? void 0 : _a2.dependencies) || []);
  }
  async _resolve_hearbeat(_config) {
    if (_config) {
      this.config = _config;
      this.api_prefix = _config.api_prefix || "";
      if (this.config && this.config.connect_heartbeat) {
        if (this.config.space_id && this.options.hf_token) {
          this.jwt = await get_jwt(
            this.config.space_id,
            this.options.hf_token,
            this.cookies
          );
        }
      }
    }
    if (_config.space_id && this.options.hf_token) {
      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);
    }
    if (this.config && this.config.connect_heartbeat) {
      const heartbeat_url = new URL(
        `${this.config.root}${this.api_prefix}/${HEARTBEAT_URL}/${this.session_hash}`
      );
      if (this.jwt) {
        heartbeat_url.searchParams.set("__sign", this.jwt);
      }
      if (!this.heartbeat_event) {
        this.heartbeat_event = this.stream(heartbeat_url);
      }
    }
  }
  static async connect(app_reference, options2 = {
    events: ["data"]
  }) {
    const client2 = new this(app_reference, options2);
    await client2.init();
    return client2;
  }
  close() {
    close_stream(this.stream_status, this.abort_controller);
  }
  set_current_payload(payload) {
    this.current_payload = payload;
  }
  static async duplicate(app_reference, options2 = {
    events: ["data"]
  }) {
    return duplicate(app_reference, options2);
  }
  async _resolve_config() {
    const { http_protocol, host, space_id } = await process_endpoint(
      this.app_reference,
      this.options.hf_token
    );
    const { status_callback } = this.options;
    if (space_id && status_callback) {
      await check_and_wake_space(space_id, status_callback);
    }
    let config;
    try {
      config = await this.resolve_config(`${http_protocol}//${host}`);
      if (!config) {
        throw new Error(CONFIG_ERROR_MSG);
      }
      return this.config_success(config);
    } catch (e) {
      if (space_id && status_callback) {
        check_space_status(
          space_id,
          RE_SPACE_NAME.test(space_id) ? "space_name" : "subdomain",
          this.handle_space_success
        );
      } else {
        if (status_callback)
          status_callback({
            status: "error",
            message: "Could not load this space.",
            load_status: "error",
            detail: "NOT_FOUND"
          });
        throw Error(e);
      }
    }
  }
  async config_success(_config) {
    this.config = _config;
    this.api_prefix = _config.api_prefix || "";
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      if (window.location.protocol === "https:") {
        this.config.root = this.config.root.replace("http://", "https://");
      }
    }
    if (this.config.auth_required) {
      return this.prepare_return_obj();
    }
    try {
      this.api_info = await this.view_api();
    } catch (e) {
      console.error(API_INFO_ERROR_MSG + e.message);
    }
    return this.prepare_return_obj();
  }
  async handle_space_success(status) {
    var _a2;
    if (!this) {
      throw new Error(CONFIG_ERROR_MSG);
    }
    const { status_callback } = this.options;
    if (status_callback)
      status_callback(status);
    if (status.status === "running") {
      try {
        this.config = await this._resolve_config();
        this.api_prefix = ((_a2 = this == null ? void 0 : this.config) == null ? void 0 : _a2.api_prefix) || "";
        if (!this.config) {
          throw new Error(CONFIG_ERROR_MSG);
        }
        const _config = await this.config_success(this.config);
        return _config;
      } catch (e) {
        if (status_callback) {
          status_callback({
            status: "error",
            message: "Could not load this space.",
            load_status: "error",
            detail: "NOT_FOUND"
          });
        }
        throw e;
      }
    }
  }
  async component_server(component_id, fn_name, data) {
    var _a2;
    if (!this.config) {
      throw new Error(CONFIG_ERROR_MSG);
    }
    const headers = {};
    const { hf_token } = this.options;
    const { session_hash } = this;
    if (hf_token) {
      headers.Authorization = `Bearer ${this.options.hf_token}`;
    }
    let root_url;
    let component = this.config.components.find(
      (comp) => comp.id === component_id
    );
    if ((_a2 = component == null ? void 0 : component.props) == null ? void 0 : _a2.root_url) {
      root_url = component.props.root_url;
    } else {
      root_url = this.config.root;
    }
    let body;
    if ("binary" in data) {
      body = new FormData();
      for (const key in data.data) {
        if (key === "binary")
          continue;
        body.append(key, data.data[key]);
      }
      body.set("component_id", component_id.toString());
      body.set("fn_name", fn_name);
      body.set("session_hash", session_hash);
    } else {
      body = JSON.stringify({
        data,
        component_id,
        fn_name,
        session_hash
      });
      headers["Content-Type"] = "application/json";
    }
    if (hf_token) {
      headers.Authorization = `Bearer ${hf_token}`;
    }
    try {
      const response = await this.fetch(
        `${root_url}${this.api_prefix}/${COMPONENT_SERVER_URL}/`,
        {
          method: "POST",
          body,
          headers,
          credentials: "include"
        }
      );
      if (!response.ok) {
        throw new Error(
          "Could not connect to component server: " + response.statusText
        );
      }
      const output = await response.json();
      return output;
    } catch (e) {
      console.warn(e);
    }
  }
  set_cookies(raw_cookies) {
    this.cookies = parse_and_set_cookies(raw_cookies).join("; ");
  }
  prepare_return_obj() {
    return {
      config: this.config,
      predict: this.predict,
      submit: this.submit,
      view_api: this.view_api,
      component_server: this.component_server
    };
  }
  async connect_ws(url) {
    return new Promise((resolve, reject) => {
      let ws;
      try {
        ws = new WebSocket(url);
      } catch (e) {
        this.ws_map[url] = "failed";
        return;
      }
      ws.onopen = () => {
        resolve();
      };
      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        this.close_ws(url);
        this.ws_map[url] = "failed";
        resolve();
      };
      ws.onclose = () => {
        delete this.ws_map[url];
        this.ws_map[url] = "failed";
      };
      ws.onmessage = (event) => {
      };
      this.ws_map[url] = ws;
    });
  }
  async send_ws_message(url, data) {
    if (!(url in this.ws_map)) {
      await this.connect_ws(url);
    }
    const ws = this.ws_map[url];
    if (ws instanceof WebSocket) {
      ws.send(JSON.stringify(data));
    } else {
      this.post_data(url, data);
    }
  }
  async close_ws(url) {
    if (url in this.ws_map) {
      const ws = this.ws_map[url];
      if (ws instanceof WebSocket) {
        ws.close();
        delete this.ws_map[url];
      }
    }
  }
}
const space_logo = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='10'%20height='10'%20fill='none'%3e%3cpath%20fill='%23FF3270'%20d='M1.93%206.03v2.04h2.04V6.03H1.93Z'/%3e%3cpath%20fill='%23861FFF'%20d='M6.03%206.03v2.04h2.04V6.03H6.03Z'/%3e%3cpath%20fill='%23097EFF'%20d='M1.93%201.93v2.04h2.04V1.93H1.93Z'/%3e%3cpath%20fill='%23000'%20fill-rule='evenodd'%20d='M.5%201.4c0-.5.4-.9.9-.9h3.1a.9.9%200%200%201%20.87.67A2.44%202.44%200%200%201%209.5%202.95c0%20.65-.25%201.24-.67%201.68.39.1.67.46.67.88v3.08c0%20.5-.4.91-.9.91H1.4a.9.9%200%200%201-.9-.9V1.4Zm1.43.53v2.04h2.04V1.93H1.93Zm0%206.14V6.03h2.04v2.04H1.93Zm4.1%200V6.03h2.04v2.04H6.03Zm0-5.12a1.02%201.02%200%201%201%202.04%200%201.02%201.02%200%200%201-2.04%200Z'%20clip-rule='evenodd'/%3e%3cpath%20fill='%23FFD702'%20d='M7.05%201.93a1.02%201.02%200%201%200%200%202.04%201.02%201.02%200%200%200%200-2.04Z'/%3e%3c/svg%3e";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options2) {
  return options2.clone !== false && options2.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options2) : value;
}
function defaultArrayMerge(target, source, options2) {
  return target.concat(source).map(function(element2) {
    return cloneUnlessOtherwiseSpecified(element2, options2);
  });
}
function getMergeFunction(key, options2) {
  if (!options2.customMerge) {
    return deepmerge;
  }
  var customMerge = options2.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target, symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options2) {
  var destination = {};
  if (options2.isMergeableObject(target)) {
    getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options2);
    });
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options2.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options2)(target[key], source[key], options2);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options2);
    }
  });
  return destination;
}
function deepmerge(target, source, options2) {
  options2 = options2 || {};
  options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
  options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
  options2.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options2);
  } else if (sourceIsArray) {
    return options2.arrayMerge(target, source, options2);
  } else {
    return mergeObject(target, source, options2);
  }
}
deepmerge.all = function deepmergeAll(array, options2) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options2);
  }, {});
};
var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;
const deepmerge$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar2; i < l; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x) {
    return x.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options2 = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options2; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options: options2 });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "rounding-mode-floor":
        result.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        result.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        result.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        result.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        result.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        result.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        result.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CU": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BO": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-EC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-PE": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n) {
  return typeof n === "number" && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  var re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s, search, position) {
    return s.startsWith(search, position);
  }
) : (
  // For IE11
  function startsWith3(s, search, position) {
    return s.slice(position, position + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length = codePoints.length;
    var i = 0;
    var code2;
    while (length > i) {
      code2 = codePoints[i++];
      if (code2 > 1114111)
        throw RangeError(code2 + " is not a valid code point");
      elements += code2 < 65536 ? String.fromCharCode(code2) : String.fromCharCode(((code2 -= 65536) >> 10) + 55296, code2 % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries2) {
      var obj = {};
      for (var _i = 0, entries_1 = entries2; _i < entries_1.length; _i++) {
        var _a2 = entries_1[_i], k = _a2[0], v = _a2[1];
        obj[k] = v;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s, index) {
    return s.codePointAt(index);
  }
) : (
  // IE 11
  function codePointAt3(s, index) {
    var size = s.length;
    if (index < 0 || index >= size) {
      return void 0;
    }
    var first = s.charCodeAt(index);
    var second;
    return first < 55296 || first > 56319 || index + 1 === size || (second = s.charCodeAt(index + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s) {
    return s.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s) {
    return s.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s) {
    return s.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s) {
    return s.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s, flag) {
  return new RegExp(s, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index;
    var match = IDENTIFIER_PREFIX_RE_1.exec(s);
    return (_a2 = match[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s, index) {
    var match = [];
    while (true) {
      var c = codePointAt(s, index);
      if (c === void 0 || _isWhiteSpace(c) || _isPatternSyntax(c)) {
        break;
      }
      match.push(c);
      index += c >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match);
  };
}
var Parser$1 = (
  /** @class */
  function() {
    function Parser2(message, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options2.ignoreTag;
      this.locale = options2.locale;
      this.requiresOtherClause = !!options2.requiresOtherClause;
      this.shouldParseSkeletons = !!options2.shouldParseSkeletons;
    }
    Parser2.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser2.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char = this.char();
        if (char === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char === 125 && nestingLevel > 0) {
          break;
        } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position, this.clonePosition())
          });
        } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser2.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children2 = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children: children2,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser2.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start = this.clonePosition();
      var value = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start, this.clonePosition());
      return {
        val: { type: TYPE.literal, value, location: location2 },
        err: null
      };
    };
    Parser2.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser2.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser2.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser2.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value, location: location2 };
    };
    Parser2.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a2;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type, value, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location: location_1,
              style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser2.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser2.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser2.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser2.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a2;
      var hasOtherClause = false;
      var options2 = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options2.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
      }
      if (options2.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options2, err: null };
    };
    Parser2.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+"))
        ;
      else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser2.prototype.offset = function() {
      return this.position.offset;
    };
    Parser2.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser2.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser2.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code2 = codePointAt(this.message, offset);
      if (code2 === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code2;
    };
    Parser2.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser2.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code2 = this.char();
      if (code2 === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code2 < 65536 ? 1 : 2;
      }
    };
    Parser2.prototype.bumpIf = function(prefix) {
      if (startsWith(this.message, prefix, this.offset())) {
        for (var i = 0; i < prefix.length; i++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser2.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index = this.message.indexOf(pattern, currentOffset);
      if (index >= 0) {
        this.bumpTo(index);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser2.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser2.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser2.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code2 = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code2 >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser2;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c) {
  return c === 45 || c === 46 || c >= 48 && c <= 57 || c === 95 || c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
}
function _isWhiteSpace(c) {
  return c >= 9 && c <= 13 || c === 32 || c === 133 || c >= 8206 && c <= 8207 || c === 8232 || c === 8233;
}
function _isPatternSyntax(c) {
  return c >= 33 && c <= 35 || c === 36 || c >= 37 && c <= 39 || c === 40 || c === 41 || c === 42 || c === 43 || c === 44 || c === 45 || c >= 46 && c <= 47 || c >= 58 && c <= 59 || c >= 60 && c <= 62 || c >= 63 && c <= 64 || c === 91 || c === 92 || c === 93 || c === 94 || c === 96 || c === 123 || c === 124 || c === 125 || c === 126 || c === 161 || c >= 162 && c <= 165 || c === 166 || c === 167 || c === 169 || c === 171 || c === 172 || c === 174 || c === 176 || c === 177 || c === 182 || c === 187 || c === 191 || c === 215 || c === 247 || c >= 8208 && c <= 8213 || c >= 8214 && c <= 8215 || c === 8216 || c === 8217 || c === 8218 || c >= 8219 && c <= 8220 || c === 8221 || c === 8222 || c === 8223 || c >= 8224 && c <= 8231 || c >= 8240 && c <= 8248 || c === 8249 || c === 8250 || c >= 8251 && c <= 8254 || c >= 8257 && c <= 8259 || c === 8260 || c === 8261 || c === 8262 || c >= 8263 && c <= 8273 || c === 8274 || c === 8275 || c >= 8277 && c <= 8286 || c >= 8592 && c <= 8596 || c >= 8597 && c <= 8601 || c >= 8602 && c <= 8603 || c >= 8604 && c <= 8607 || c === 8608 || c >= 8609 && c <= 8610 || c === 8611 || c >= 8612 && c <= 8613 || c === 8614 || c >= 8615 && c <= 8621 || c === 8622 || c >= 8623 && c <= 8653 || c >= 8654 && c <= 8655 || c >= 8656 && c <= 8657 || c === 8658 || c === 8659 || c === 8660 || c >= 8661 && c <= 8691 || c >= 8692 && c <= 8959 || c >= 8960 && c <= 8967 || c === 8968 || c === 8969 || c === 8970 || c === 8971 || c >= 8972 && c <= 8991 || c >= 8992 && c <= 8993 || c >= 8994 && c <= 9e3 || c === 9001 || c === 9002 || c >= 9003 && c <= 9083 || c === 9084 || c >= 9085 && c <= 9114 || c >= 9115 && c <= 9139 || c >= 9140 && c <= 9179 || c >= 9180 && c <= 9185 || c >= 9186 && c <= 9254 || c >= 9255 && c <= 9279 || c >= 9280 && c <= 9290 || c >= 9291 && c <= 9311 || c >= 9472 && c <= 9654 || c === 9655 || c >= 9656 && c <= 9664 || c === 9665 || c >= 9666 && c <= 9719 || c >= 9720 && c <= 9727 || c >= 9728 && c <= 9838 || c === 9839 || c >= 9840 && c <= 10087 || c === 10088 || c === 10089 || c === 10090 || c === 10091 || c === 10092 || c === 10093 || c === 10094 || c === 10095 || c === 10096 || c === 10097 || c === 10098 || c === 10099 || c === 10100 || c === 10101 || c >= 10132 && c <= 10175 || c >= 10176 && c <= 10180 || c === 10181 || c === 10182 || c >= 10183 && c <= 10213 || c === 10214 || c === 10215 || c === 10216 || c === 10217 || c === 10218 || c === 10219 || c === 10220 || c === 10221 || c === 10222 || c === 10223 || c >= 10224 && c <= 10239 || c >= 10240 && c <= 10495 || c >= 10496 && c <= 10626 || c === 10627 || c === 10628 || c === 10629 || c === 10630 || c === 10631 || c === 10632 || c === 10633 || c === 10634 || c === 10635 || c === 10636 || c === 10637 || c === 10638 || c === 10639 || c === 10640 || c === 10641 || c === 10642 || c === 10643 || c === 10644 || c === 10645 || c === 10646 || c === 10647 || c === 10648 || c >= 10649 && c <= 10711 || c === 10712 || c === 10713 || c === 10714 || c === 10715 || c >= 10716 && c <= 10747 || c === 10748 || c === 10749 || c >= 10750 && c <= 11007 || c >= 11008 && c <= 11055 || c >= 11056 && c <= 11076 || c >= 11077 && c <= 11078 || c >= 11079 && c <= 11084 || c >= 11085 && c <= 11123 || c >= 11124 && c <= 11125 || c >= 11126 && c <= 11157 || c === 11158 || c >= 11159 && c <= 11263 || c >= 11776 && c <= 11777 || c === 11778 || c === 11779 || c === 11780 || c === 11781 || c >= 11782 && c <= 11784 || c === 11785 || c === 11786 || c === 11787 || c === 11788 || c === 11789 || c >= 11790 && c <= 11798 || c === 11799 || c >= 11800 && c <= 11801 || c === 11802 || c === 11803 || c === 11804 || c === 11805 || c >= 11806 && c <= 11807 || c === 11808 || c === 11809 || c === 11810 || c === 11811 || c === 11812 || c === 11813 || c === 11814 || c === 11815 || c === 11816 || c === 11817 || c >= 11818 && c <= 11822 || c === 11823 || c >= 11824 && c <= 11833 || c >= 11834 && c <= 11835 || c >= 11836 && c <= 11839 || c === 11840 || c === 11841 || c === 11842 || c >= 11843 && c <= 11855 || c >= 11856 && c <= 11857 || c === 11858 || c >= 11859 && c <= 11903 || c >= 12289 && c <= 12291 || c === 12296 || c === 12297 || c === 12298 || c === 12299 || c === 12300 || c === 12301 || c === 12302 || c === 12303 || c === 12304 || c === 12305 || c >= 12306 && c <= 12307 || c === 12308 || c === 12309 || c === 12310 || c === 12311 || c === 12312 || c === 12313 || c === 12314 || c === 12315 || c === 12316 || c === 12317 || c >= 12318 && c <= 12319 || c === 12320 || c === 12336 || c === 64830 || c === 64831 || c >= 65093 && c <= 65094;
}
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k in el.options) {
        delete el.options[k].location;
        pruneLocation(el.options[k].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser$1(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}
function memoize(fn2, options2) {
  var cache = options2 && options2.cache ? options2.cache : cacheDefault;
  var serializer = options2 && options2.serializer ? options2.serializer : serializerDefault;
  var strategy = options2 && options2.strategy ? options2.strategy : strategyDefault;
  return strategy(fn2, {
    cache,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn2, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache, serialize) {
  return strategy.bind(context, fn2, cache, serialize);
}
function strategyDefault(fn2, options2) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options2.cache.create(), options2.serializer);
}
function strategyVariadic(fn2, options2) {
  return assemble(fn2, this, variadic, options2.cache.create(), options2.serializer);
}
function strategyMonadic(fn2, options2) {
  return assemble(fn2, this, monadic, options2.cache.create(), options2.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg, code2, originalMessage) {
      var _this = _super.call(this, msg) || this;
      _this.code = code2;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value, options2, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options2).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value, type, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children2 = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children2, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p) {
        return p.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c) {
        return {
          type: typeof c === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k) {
    all[k] = __assign(__assign({}, c1[k]), c2[k] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k) {
    all[k] = mergeConfig(defaultConfig[k], configs[k]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      var _this = this;
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all, part) {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a3;
        return {
          locale: ((_a3 = _this.resolvedLocale) === null || _a3 === void 0 ? void 0 : _a3.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a2 = opts || {};
        _a2.formatters;
        var parseOpts = __rest(_a2, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);
function delve(obj, fullKey) {
  if (fullKey == null)
    return void 0;
  if (fullKey in obj) {
    return obj[fullKey];
  }
  const keys = fullKey.split(".");
  let result = obj;
  for (let p = 0; p < keys.length; p++) {
    if (typeof result === "object") {
      if (p > 0) {
        const partialKey = keys.slice(p, keys.length).join(".");
        if (partialKey in result) {
          result = result[partialKey];
          break;
        }
      }
      result = result[keys[p]];
    } else {
      result = void 0;
    }
  }
  return result;
}
const lookupCache = {};
const addToCache = (path2, locale, message) => {
  if (!message)
    return message;
  if (!(locale in lookupCache))
    lookupCache[locale] = {};
  if (!(path2 in lookupCache[locale]))
    lookupCache[locale][path2] = message;
  return message;
};
const lookup = (path2, refLocale) => {
  if (refLocale == null)
    return void 0;
  if (refLocale in lookupCache && path2 in lookupCache[refLocale]) {
    return lookupCache[refLocale][path2];
  }
  const locales = getPossibleLocales(refLocale);
  for (let i = 0; i < locales.length; i++) {
    const locale = locales[i];
    const message = getMessageFromDictionary(locale, path2);
    if (message) {
      return addToCache(path2, refLocale, message);
    }
  }
  return void 0;
};
let dictionary;
const $dictionary = writable({});
function getLocaleDictionary(locale) {
  return dictionary[locale] || null;
}
function hasLocaleDictionary(locale) {
  return locale in dictionary;
}
function getMessageFromDictionary(locale, id2) {
  if (!hasLocaleDictionary(locale)) {
    return null;
  }
  const localeDictionary = getLocaleDictionary(locale);
  const match = delve(localeDictionary, id2);
  return match;
}
function getClosestAvailableLocale(refLocale) {
  if (refLocale == null)
    return void 0;
  const relatedLocales = getPossibleLocales(refLocale);
  for (let i = 0; i < relatedLocales.length; i++) {
    const locale = relatedLocales[i];
    if (hasLocaleDictionary(locale)) {
      return locale;
    }
  }
  return void 0;
}
function addMessages(locale, ...partials) {
  delete lookupCache[locale];
  $dictionary.update((d) => {
    d[locale] = deepmerge$1.all([d[locale] || {}, ...partials]);
    return d;
  });
}
derived(
  [$dictionary],
  ([dictionary2]) => Object.keys(dictionary2)
);
$dictionary.subscribe((newDictionary) => dictionary = newDictionary);
const queue = {};
function removeLoaderFromQueue(locale, loader) {
  queue[locale].delete(loader);
  if (queue[locale].size === 0) {
    delete queue[locale];
  }
}
function getLocaleQueue(locale) {
  return queue[locale];
}
function getLocalesQueues(locale) {
  return getPossibleLocales(locale).map((localeItem) => {
    const localeQueue = getLocaleQueue(localeItem);
    return [localeItem, localeQueue ? [...localeQueue] : []];
  }).filter(([, localeQueue]) => localeQueue.length > 0);
}
function hasLocaleQueue(locale) {
  if (locale == null)
    return false;
  return getPossibleLocales(locale).some(
    (localeQueue) => {
      var _a2;
      return (_a2 = getLocaleQueue(localeQueue)) == null ? void 0 : _a2.size;
    }
  );
}
function loadLocaleQueue(locale, localeQueue) {
  const allLoadersPromise = Promise.all(
    localeQueue.map((loader) => {
      removeLoaderFromQueue(locale, loader);
      return loader().then((partial) => partial.default || partial);
    })
  );
  return allLoadersPromise.then((partials) => addMessages(locale, ...partials));
}
const activeFlushes = {};
function flush(locale) {
  if (!hasLocaleQueue(locale)) {
    if (locale in activeFlushes) {
      return activeFlushes[locale];
    }
    return Promise.resolve();
  }
  const queues = getLocalesQueues(locale);
  activeFlushes[locale] = Promise.all(
    queues.map(
      ([localeName, localeQueue]) => loadLocaleQueue(localeName, localeQueue)
    )
  ).then(() => {
    if (hasLocaleQueue(locale)) {
      return flush(locale);
    }
    delete activeFlushes[locale];
  });
  return activeFlushes[locale];
}
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const defaultFormats = {
  number: {
    scientific: { notation: "scientific" },
    engineering: { notation: "engineering" },
    compactLong: { notation: "compact", compactDisplay: "long" },
    compactShort: { notation: "compact", compactDisplay: "short" }
  },
  date: {
    short: { month: "numeric", day: "numeric", year: "2-digit" },
    medium: { month: "short", day: "numeric", year: "numeric" },
    long: { month: "long", day: "numeric", year: "numeric" },
    full: { weekday: "long", month: "long", day: "numeric", year: "numeric" }
  },
  time: {
    short: { hour: "numeric", minute: "numeric" },
    medium: { hour: "numeric", minute: "numeric", second: "numeric" },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    }
  }
};
function defaultMissingKeyHandler({ locale, id: id2 }) {
  console.warn(
    `[svelte-i18n] The message "${id2}" was not found in "${getPossibleLocales(
      locale
    ).join('", "')}".${hasLocaleQueue(getCurrentLocale()) ? `

Note: there are at least one loader still registered to this locale that wasn't executed.` : ""}`
  );
}
const defaultOptions = {
  fallbackLocale: null,
  loadingDelay: 200,
  formats: defaultFormats,
  warnOnMissingMessages: true,
  handleMissingMessage: void 0,
  ignoreTag: true
};
const options = defaultOptions;
function getOptions() {
  return options;
}
function init$1(opts) {
  const _a2 = opts, { formats } = _a2, rest = __objRest$1(_a2, ["formats"]);
  let initialLocale = opts.fallbackLocale;
  if (opts.initialLocale) {
    try {
      if (IntlMessageFormat.resolveLocale(opts.initialLocale)) {
        initialLocale = opts.initialLocale;
      }
    } catch (e) {
      console.warn(
        `[svelte-i18n] The initial locale "${opts.initialLocale}" is not a valid locale.`
      );
    }
  }
  if (rest.warnOnMissingMessages) {
    delete rest.warnOnMissingMessages;
    if (rest.handleMissingMessage == null) {
      rest.handleMissingMessage = defaultMissingKeyHandler;
    } else {
      console.warn(
        '[svelte-i18n] The "warnOnMissingMessages" option is deprecated. Please use the "handleMissingMessage" option instead.'
      );
    }
  }
  Object.assign(options, rest, { initialLocale });
  if (formats) {
    if ("number" in formats) {
      Object.assign(options.formats.number, formats.number);
    }
    if ("date" in formats) {
      Object.assign(options.formats.date, formats.date);
    }
    if ("time" in formats) {
      Object.assign(options.formats.time, formats.time);
    }
  }
  return $locale.set(initialLocale);
}
const $isLoading = writable(false);
var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
let current;
const internalLocale = writable(null);
function getSubLocales(refLocale) {
  return refLocale.split("-").map((_, i, arr) => arr.slice(0, i + 1).join("-")).reverse();
}
function getPossibleLocales(refLocale, fallbackLocale = getOptions().fallbackLocale) {
  const locales = getSubLocales(refLocale);
  if (fallbackLocale) {
    return [.../* @__PURE__ */ new Set([...locales, ...getSubLocales(fallbackLocale)])];
  }
  return locales;
}
function getCurrentLocale() {
  return current != null ? current : void 0;
}
internalLocale.subscribe((newLocale) => {
  current = newLocale != null ? newLocale : void 0;
  if (typeof window !== "undefined" && newLocale != null) {
    document.documentElement.setAttribute("lang", newLocale);
  }
});
const set = (newLocale) => {
  if (newLocale && getClosestAvailableLocale(newLocale) && hasLocaleQueue(newLocale)) {
    const { loadingDelay } = getOptions();
    let loadingTimer;
    if (typeof window !== "undefined" && getCurrentLocale() != null && loadingDelay) {
      loadingTimer = window.setTimeout(
        () => $isLoading.set(true),
        loadingDelay
      );
    } else {
      $isLoading.set(true);
    }
    return flush(newLocale).then(() => {
      internalLocale.set(newLocale);
    }).finally(() => {
      clearTimeout(loadingTimer);
      $isLoading.set(false);
    });
  }
  return internalLocale.set(newLocale);
};
const $locale = __spreadProps(__spreadValues$1({}, internalLocale), {
  set
});
const getLocaleFromNavigator = () => {
  if (typeof window === "undefined")
    return null;
  return window.navigator.language || window.navigator.languages[0];
};
const monadicMemoize = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  const memoizedFn = (arg) => {
    const cacheKey = JSON.stringify(arg);
    if (cacheKey in cache) {
      return cache[cacheKey];
    }
    return cache[cacheKey] = fn2(arg);
  };
  return memoizedFn;
};
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const getIntlFormatterOptions = (type, name) => {
  const { formats } = getOptions();
  if (type in formats && name in formats[type]) {
    return formats[type][name];
  }
  throw new Error(`[svelte-i18n] Unknown "${name}" ${type} format.`);
};
const createNumberFormatter = monadicMemoize(
  (_a2) => {
    var _b = _a2, { locale, format } = _b, options2 = __objRest(_b, ["locale", "format"]);
    if (locale == null) {
      throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
    }
    if (format) {
      options2 = getIntlFormatterOptions("number", format);
    }
    return new Intl.NumberFormat(locale, options2);
  }
);
const createDateFormatter = monadicMemoize(
  (_c) => {
    var _d = _c, { locale, format } = _d, options2 = __objRest(_d, ["locale", "format"]);
    if (locale == null) {
      throw new Error('[svelte-i18n] A "locale" must be set to format dates');
    }
    if (format) {
      options2 = getIntlFormatterOptions("date", format);
    } else if (Object.keys(options2).length === 0) {
      options2 = getIntlFormatterOptions("date", "short");
    }
    return new Intl.DateTimeFormat(locale, options2);
  }
);
const createTimeFormatter = monadicMemoize(
  (_e) => {
    var _f = _e, { locale, format } = _f, options2 = __objRest(_f, ["locale", "format"]);
    if (locale == null) {
      throw new Error(
        '[svelte-i18n] A "locale" must be set to format time values'
      );
    }
    if (format) {
      options2 = getIntlFormatterOptions("time", format);
    } else if (Object.keys(options2).length === 0) {
      options2 = getIntlFormatterOptions("time", "short");
    }
    return new Intl.DateTimeFormat(locale, options2);
  }
);
const getNumberFormatter = (_g = {}) => {
  var _h = _g, {
    locale = getCurrentLocale()
  } = _h, args = __objRest(_h, [
    "locale"
  ]);
  return createNumberFormatter(__spreadValues({ locale }, args));
};
const getDateFormatter = (_i = {}) => {
  var _j = _i, {
    locale = getCurrentLocale()
  } = _j, args = __objRest(_j, [
    "locale"
  ]);
  return createDateFormatter(__spreadValues({ locale }, args));
};
const getTimeFormatter = (_k = {}) => {
  var _l = _k, {
    locale = getCurrentLocale()
  } = _l, args = __objRest(_l, [
    "locale"
  ]);
  return createTimeFormatter(__spreadValues({ locale }, args));
};
const getMessageFormatter = monadicMemoize(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (message, locale = getCurrentLocale()) => new IntlMessageFormat(message, locale, getOptions().formats, {
    ignoreTag: getOptions().ignoreTag
  })
);
const formatMessage = (id2, options2 = {}) => {
  var _a2, _b, _c, _d;
  let messageObj = options2;
  if (typeof id2 === "object") {
    messageObj = id2;
    id2 = messageObj.id;
  }
  const {
    values,
    locale = getCurrentLocale(),
    default: defaultValue
  } = messageObj;
  if (locale == null) {
    throw new Error(
      "[svelte-i18n] Cannot format a message without first setting the initial locale."
    );
  }
  let message = lookup(id2, locale);
  if (!message) {
    message = (_d = (_c = (_b = (_a2 = getOptions()).handleMissingMessage) == null ? void 0 : _b.call(_a2, { locale, id: id2, defaultValue })) != null ? _c : defaultValue) != null ? _d : id2;
  } else if (typeof message !== "string") {
    console.warn(
      `[svelte-i18n] Message with id "${id2}" must be of type "string", found: "${typeof message}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`
    );
    return message;
  }
  if (!values) {
    return message;
  }
  let result = message;
  try {
    result = getMessageFormatter(message, locale).format(values);
  } catch (e) {
    if (e instanceof Error) {
      console.warn(
        `[svelte-i18n] Message "${id2}" has syntax error:`,
        e.message
      );
    }
  }
  return result;
};
const formatTime = (t, options2) => {
  return getTimeFormatter(options2).format(t);
};
const formatDate = (d, options2) => {
  return getDateFormatter(options2).format(d);
};
const formatNumber = (n, options2) => {
  return getNumberFormatter(options2).format(n);
};
const getJSON = (id2, locale = getCurrentLocale()) => {
  return lookup(id2, locale);
};
const $format = derived([$locale, $dictionary], () => formatMessage);
derived([$locale], () => formatTime);
derived([$locale], () => formatDate);
derived([$locale], () => formatNumber);
derived([$locale, $dictionary], () => getJSON);
function create_if_block$l(ctx) {
  let div;
  let span0;
  let a0;
  let t0;
  let a0_href_value;
  let t1;
  let span1;
  let t2_value = (
    /*$_*/
    ctx[9]("common.built_with") + ""
  );
  let t2;
  let t3;
  let a1;
  let textContent = "Gradio";
  let t5;
  let t6;
  let span3;
  let t7_value = (
    /*$_*/
    ctx[9]("common.hosted_on") + ""
  );
  let t7;
  let t8;
  let a2;
  let textContent_1 = `<span class="space-logo svelte-vcv2kd"><img src="${space_logo}" alt="Hugging Face Space" class="svelte-vcv2kd"/></span> Spaces`;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      a0 = element("a");
      t0 = text$3(
        /*space*/
        ctx[5]
      );
      t1 = space();
      span1 = element("span");
      t2 = text$3(t2_value);
      t3 = space();
      a1 = element("a");
      a1.textContent = textContent;
      t5 = text$3(".");
      t6 = space();
      span3 = element("span");
      t7 = text$3(t7_value);
      t8 = space();
      a2 = element("a");
      a2.innerHTML = textContent_1;
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      a0 = claim_element(span0_nodes, "A", { href: true, class: true });
      var a0_nodes = children(a0);
      t0 = claim_text(
        a0_nodes,
        /*space*/
        ctx[5]
      );
      a0_nodes.forEach(detach);
      span0_nodes.forEach(detach);
      t1 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, t2_value);
      t3 = claim_space(span1_nodes);
      a1 = claim_element(span1_nodes, "A", {
        class: true,
        href: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(a1) !== "svelte-jht9bl")
        a1.textContent = textContent;
      t5 = claim_text(span1_nodes, ".");
      span1_nodes.forEach(detach);
      t6 = claim_space(div_nodes);
      span3 = claim_element(div_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      t7 = claim_text(span3_nodes, t7_value);
      t8 = claim_space(span3_nodes);
      a2 = claim_element(span3_nodes, "A", {
        class: true,
        href: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(a2) !== "svelte-1nwwv82")
        a2.innerHTML = textContent_1;
      span3_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(a0, "href", a0_href_value = "https://huggingface.co/spaces/" + /*space*/
      ctx[5]);
      attr(a0, "class", "title svelte-vcv2kd");
      attr(span0, "class", "svelte-vcv2kd");
      attr(a1, "class", "gradio svelte-vcv2kd");
      attr(a1, "href", "https://gradio.app");
      attr(span1, "class", "svelte-vcv2kd");
      attr(a2, "class", "hf svelte-vcv2kd");
      attr(a2, "href", "https://huggingface.co/spaces");
      attr(span3, "class", "svelte-vcv2kd");
      attr(div, "class", "info svelte-vcv2kd");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, span0);
      append_hydration(span0, a0);
      append_hydration(a0, t0);
      append_hydration(div, t1);
      append_hydration(div, span1);
      append_hydration(span1, t2);
      append_hydration(span1, t3);
      append_hydration(span1, a1);
      append_hydration(span1, t5);
      append_hydration(div, t6);
      append_hydration(div, span3);
      append_hydration(span3, t7);
      append_hydration(span3, t8);
      append_hydration(span3, a2);
    },
    p(ctx2, dirty) {
      if (dirty & /*space*/
      32)
        set_data(
          t0,
          /*space*/
          ctx2[5]
        );
      if (dirty & /*space*/
      32 && a0_href_value !== (a0_href_value = "https://huggingface.co/spaces/" + /*space*/
      ctx2[5])) {
        attr(a0, "href", a0_href_value);
      }
      if (dirty & /*$_*/
      512 && t2_value !== (t2_value = /*$_*/
      ctx2[9]("common.built_with") + ""))
        set_data(t2, t2_value);
      if (dirty & /*$_*/
      512 && t7_value !== (t7_value = /*$_*/
      ctx2[9]("common.hosted_on") + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$D(ctx) {
  let div1;
  let div0;
  let t;
  let div1_class_value;
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let if_block = (
    /*display*/
    ctx[6] && /*space*/
    ctx[5] && /*info*/
    ctx[7] && create_if_block$l(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-iframe-height": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      t = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "main svelte-vcv2kd");
      attr(div1, "class", div1_class_value = "gradio-container gradio-container-" + /*version*/
      ctx[1] + " svelte-vcv2kd");
      attr(div1, "data-iframe-height", "");
      toggle_class(div1, "app", !/*display*/
      ctx[6] && !/*is_embed*/
      ctx[4]);
      toggle_class(
        div1,
        "fill_width",
        /*fill_width*/
        ctx[3]
      );
      toggle_class(
        div1,
        "embed-container",
        /*display*/
        ctx[6]
      );
      toggle_class(
        div1,
        "with-info",
        /*info*/
        ctx[7]
      );
      set_style(
        div1,
        "min-height",
        /*loaded*/
        ctx[8] ? "initial" : (
          /*initial_height*/
          ctx[2]
        )
      );
      set_style(div1, "flex-grow", !/*display*/
      ctx[6] ? "1" : "auto");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration(div1, t);
      if (if_block)
        if_block.m(div1, null);
      ctx[12](div1);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*display*/
        ctx2[6] && /*space*/
        ctx2[5] && /*info*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current2 || dirty & /*version*/
      2 && div1_class_value !== (div1_class_value = "gradio-container gradio-container-" + /*version*/
      ctx2[1] + " svelte-vcv2kd")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current2 || dirty & /*version, display, is_embed*/
      82) {
        toggle_class(div1, "app", !/*display*/
        ctx2[6] && !/*is_embed*/
        ctx2[4]);
      }
      if (!current2 || dirty & /*version, fill_width*/
      10) {
        toggle_class(
          div1,
          "fill_width",
          /*fill_width*/
          ctx2[3]
        );
      }
      if (!current2 || dirty & /*version, display*/
      66) {
        toggle_class(
          div1,
          "embed-container",
          /*display*/
          ctx2[6]
        );
      }
      if (!current2 || dirty & /*version, info*/
      130) {
        toggle_class(
          div1,
          "with-info",
          /*info*/
          ctx2[7]
        );
      }
      if (dirty & /*loaded, initial_height*/
      260) {
        set_style(
          div1,
          "min-height",
          /*loaded*/
          ctx2[8] ? "initial" : (
            /*initial_height*/
            ctx2[2]
          )
        );
      }
      if (dirty & /*display*/
      64) {
        set_style(div1, "flex-grow", !/*display*/
        ctx2[6] ? "1" : "auto");
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[12](null);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, $format, ($$value) => $$invalidate(9, $_ = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { wrapper } = $$props;
  let { version } = $$props;
  let { initial_height } = $$props;
  let { fill_width } = $$props;
  let { is_embed } = $$props;
  let { space: space2 } = $$props;
  let { display } = $$props;
  let { info } = $$props;
  let { loaded } = $$props;
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(0, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("wrapper" in $$props2)
      $$invalidate(0, wrapper = $$props2.wrapper);
    if ("version" in $$props2)
      $$invalidate(1, version = $$props2.version);
    if ("initial_height" in $$props2)
      $$invalidate(2, initial_height = $$props2.initial_height);
    if ("fill_width" in $$props2)
      $$invalidate(3, fill_width = $$props2.fill_width);
    if ("is_embed" in $$props2)
      $$invalidate(4, is_embed = $$props2.is_embed);
    if ("space" in $$props2)
      $$invalidate(5, space2 = $$props2.space);
    if ("display" in $$props2)
      $$invalidate(6, display = $$props2.display);
    if ("info" in $$props2)
      $$invalidate(7, info = $$props2.info);
    if ("loaded" in $$props2)
      $$invalidate(8, loaded = $$props2.loaded);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    wrapper,
    version,
    initial_height,
    fill_width,
    is_embed,
    space2,
    display,
    info,
    loaded,
    $_,
    $$scope,
    slots,
    div1_binding
  ];
}
class Embed extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$u, create_fragment$D, safe_not_equal, {
      wrapper: 0,
      version: 1,
      initial_height: 2,
      fill_width: 3,
      is_embed: 4,
      space: 5,
      display: 6,
      info: 7,
      loaded: 8
    });
  }
}
let supports_adopted_stylesheets = false;
if (typeof window !== "undefined" && "attachShadow" in Element.prototype && "adoptedStyleSheets" in Document.prototype) {
  const shadow_root_test = document.createElement("div").attachShadow({ mode: "open" });
  supports_adopted_stylesheets = "adoptedStyleSheets" in shadow_root_test;
}
function mount_css(url, target) {
  const base = new URL(import.meta.url).origin;
  const _url = new URL(url, base).href;
  const existing_link = document.querySelector(`link[href='${_url}']`);
  if (existing_link)
    return Promise.resolve();
  const link2 = document.createElement("link");
  link2.rel = "stylesheet";
  link2.href = _url;
  return new Promise((res, rej) => {
    link2.addEventListener("load", () => res());
    link2.addEventListener("error", () => {
      console.error(`Unable to preload CSS for ${_url}`);
      res();
    });
    target.appendChild(link2);
  });
}
function prefix_css(string, version, style_element) {
  if (!supports_adopted_stylesheets)
    return string;
  if (!style_element) {
    style_element = document.createElement("style");
  }
  style_element.remove();
  const stylesheet = new CSSStyleSheet();
  stylesheet.replaceSync(string);
  let importString = "";
  string = string.replace(/@import\s+url\((.*?)\);\s*/g, (match, url) => {
    importString += `@import url(${url});
`;
    return "";
  });
  const rules = stylesheet.cssRules;
  let css_string = "";
  let gradio_css_infix = `.gradio-container.gradio-container-${version} .contain `;
  for (let i = 0; i < rules.length; i++) {
    const rule = rules[i];
    let is_dark_rule = rule.cssText.includes(".dark");
    if (rule instanceof CSSStyleRule) {
      const selector = rule.selectorText;
      if (selector) {
        const new_selector = selector.replace(".dark", "").split(",").map(
          (s) => `${is_dark_rule ? ".dark" : ""} ${gradio_css_infix} ${s.trim()} `
        ).join(",");
        css_string += rule.cssText;
        css_string += rule.cssText.replace(selector, new_selector);
      }
    } else if (rule instanceof CSSMediaRule) {
      let mediaCssString = `@media ${rule.media.mediaText} {`;
      for (let j = 0; j < rule.cssRules.length; j++) {
        const innerRule = rule.cssRules[j];
        if (innerRule instanceof CSSStyleRule) {
          let is_dark_rule2 = innerRule.cssText.includes(".dark ");
          const selector = innerRule.selectorText;
          const new_selector = selector.replace(".dark", "").split(",").map(
            (s) => `${is_dark_rule2 ? ".dark" : ""} ${gradio_css_infix} ${s.trim()} `
          ).join(",");
          mediaCssString += innerRule.cssText.replace(selector, new_selector);
        }
      }
      mediaCssString += "}";
      css_string += mediaCssString;
    } else if (rule instanceof CSSKeyframesRule) {
      css_string += `@keyframes ${rule.name} {`;
      for (let j = 0; j < rule.cssRules.length; j++) {
        const innerRule = rule.cssRules[j];
        if (innerRule instanceof CSSKeyframeRule) {
          css_string += `${innerRule.keyText} { ${innerRule.style.cssText} }`;
        }
      }
      css_string += "}";
    } else if (rule instanceof CSSFontFaceRule) {
      css_string += `@font-face { ${rule.style.cssText} }`;
    }
  }
  return importString + css_string;
}
const component_map = {
  "accordion": {
    component: () => __vitePreload(() => import("./Index.CPt7Lj0q.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url)
  },
  "annotatedimage": {
    component: () => __vitePreload(() => import("./Index.BpisMbvM.js"), true ? __vite__mapDeps([2,3,4,5,6,7,8,9,10]) : void 0, import.meta.url)
  },
  "audio": {
    base: () => __vitePreload(() => import("./StaticAudio.a9A5cXcJ.js").then((n) => n.b), true ? __vite__mapDeps([11,3,4,12,13,14,15,7,16,17,18,8,19,20,10,21]) : void 0, import.meta.url),
    example: () => __vitePreload(() => import("./Example.CNa918u4.js"), true ? __vite__mapDeps([22,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./index.ClSQ7e4F.js"), true ? __vite__mapDeps([24,11,3,4,12,13,14,15,7,16,17,18,8,19,20,10,21,25,26,27,28,29,30,31,32,22,23,33]) : void 0, import.meta.url)
  },
  "box": {
    component: () => __vitePreload(() => import("./Index.BV9j3wzy.js"), true ? [] : void 0, import.meta.url)
  },
  "button": {
    component: () => __vitePreload(() => import("./Index.BNHQ_Lis.js"), true ? [] : void 0, import.meta.url)
  },
  "chatbot": {
    component: () => __vitePreload(() => import("./Index.Bzw0U_-f.js"), true ? __vite__mapDeps([34,35,8,36,10,20,18,7,37,13,38,3,39,40]) : void 0, import.meta.url)
  },
  "checkbox": {
    example: () => __vitePreload(() => import("./Example.BVeuag4v.js"), true ? __vite__mapDeps([41,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.DmbGX_He.js"), true ? __vite__mapDeps([42,43]) : void 0, import.meta.url)
  },
  "checkboxgroup": {
    example: () => __vitePreload(() => import("./Example.B3uMG8lv.js"), true ? __vite__mapDeps([44,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.ClbzocfK.js"), true ? __vite__mapDeps([45,46]) : void 0, import.meta.url)
  },
  "code": {
    example: () => __vitePreload(() => import("./Example.C2EXtnCA.js"), true ? __vite__mapDeps([47,48]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.D784wQ_6.js").then((n) => n.F), true ? __vite__mapDeps([49,25,14,20,8,10,7,50,3,4,47,48,51]) : void 0, import.meta.url)
  },
  "colorpicker": {
    example: () => __vitePreload(() => import("./Example.D2Mw89Ip.js"), true ? __vite__mapDeps([52,53]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.DtBJa_nn.js"), true ? __vite__mapDeps([54,55,52,53,56]) : void 0, import.meta.url)
  },
  "column": {
    component: () => __vitePreload(() => Promise.resolve().then(() => Index$1), true ? void 0 : void 0, import.meta.url)
  },
  "core": {
    component: () => __vitePreload(() => import("./index.BsP2WSSC.js"), true ? [] : void 0, import.meta.url)
  },
  "dataframe": {
    example: () => __vitePreload(() => import("./Example.LJcGc8OW.js"), true ? __vite__mapDeps([57,58]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.BPnIplJo.js"), true ? __vite__mapDeps([59,37,26,27,60,57,58,61,10]) : void 0, import.meta.url)
  },
  "dataset": {
    component: () => __vitePreload(() => import("./Index.BqLllX5v.js"), true ? __vite__mapDeps([62,63,64]) : void 0, import.meta.url)
  },
  "datetime": {
    example: () => __vitePreload(() => import("./Example.CYe6rnxa.js"), true ? [] : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.TmZWVF_c.js"), true ? __vite__mapDeps([65,66,67]) : void 0, import.meta.url)
  },
  "downloadbutton": {
    component: () => __vitePreload(() => import("./Index.BvrximTe.js"), true ? __vite__mapDeps([68,69]) : void 0, import.meta.url)
  },
  "dropdown": {
    example: () => __vitePreload(() => import("./Example.BEWyOqJ6.js"), true ? __vite__mapDeps([70,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.oXi7gfSd.js"), true ? __vite__mapDeps([71,72,70,23,73]) : void 0, import.meta.url)
  },
  "file": {
    example: () => __vitePreload(() => import("./Example.DBkrk8px.js"), true ? __vite__mapDeps([74,75]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.PUtlLKbd.js"), true ? __vite__mapDeps([76,77,3,4,78,26,27,30,7,20,8,10,79,32,74,75]) : void 0, import.meta.url)
  },
  "fileexplorer": {
    example: () => __vitePreload(() => import("./Example.CSI_-_PL.js"), true ? __vite__mapDeps([80,81]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.DFEwCGv-.js"), true ? __vite__mapDeps([82,78,3,83]) : void 0, import.meta.url)
  },
  "form": {
    component: () => __vitePreload(() => Promise.resolve().then(() => Index$3), true ? void 0 : void 0, import.meta.url)
  },
  "gallery": {
    base: () => __vitePreload(() => import("./Gallery.BQ5aYZaP.js"), true ? __vite__mapDeps([84,3,4,12,13,14,5,6,17,7,28,18,20,8,10,35,36,85,19,86,87,27,40]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.DI2fRCK5.js"), true ? __vite__mapDeps([88,32,30,84,3,4,12,13,14,5,6,17,7,28,18,20,8,10,35,36,85,19,86,87,27,40,77,78,26,79,75]) : void 0, import.meta.url)
  },
  "group": {
    component: () => __vitePreload(() => import("./Index.QezQk_XN.js"), true ? __vite__mapDeps([89,90]) : void 0, import.meta.url)
  },
  "highlightedtext": {
    component: () => __vitePreload(() => import("./Index.D4RYB8FJ.js"), true ? __vite__mapDeps([91,92,3,4,93]) : void 0, import.meta.url)
  },
  "html": {
    base: () => __vitePreload(() => import("./Index.eG7Upuns.js"), true ? __vite__mapDeps([94,50,3,95]) : void 0, import.meta.url),
    example: () => __vitePreload(() => import("./Example.CGUNrbfF.js"), true ? __vite__mapDeps([96,97]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.eG7Upuns.js"), true ? __vite__mapDeps([94,50,3,95]) : void 0, import.meta.url)
  },
  "image": {
    base: () => __vitePreload(() => import("./ImagePreview.CDVGjPNr.js"), true ? __vite__mapDeps([98,3,4,12,13,14,5,6,7,99,35,8,36,10,20,40]) : void 0, import.meta.url),
    example: () => __vitePreload(() => import("./Example.wemIBKRq.js"), true ? __vite__mapDeps([100,35,8,36,10,101]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.B36kMi9W.js"), true ? __vite__mapDeps([102,98,3,4,12,13,14,5,6,7,99,35,8,36,10,20,40,103,29,30,72,31,26,27,104,32,100,101]) : void 0, import.meta.url)
  },
  "imageeditor": {
    example: () => __vitePreload(() => import("./Example.BEQwiSyv.js"), true ? __vite__mapDeps([105,35,8,36,10,103,3,6,29,30,99,72,31,26,27,7,104,106,40,101]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.DFmX-KUe.js"), true ? __vite__mapDeps([107,98,3,4,12,13,14,5,6,7,99,35,8,36,10,20,40,103,29,30,72,31,26,27,104,108,38,18,55,109,101]) : void 0, import.meta.url)
  },
  "json": {
    component: () => __vitePreload(() => import("./Index.Duv5AmD8.js"), true ? __vite__mapDeps([110,4,7,3,111]) : void 0, import.meta.url)
  },
  "label": {
    component: () => __vitePreload(() => import("./Index.DYx0ZFdb.js"), true ? __vite__mapDeps([112,113,3,4,114]) : void 0, import.meta.url)
  },
  "markdown": {
    example: () => __vitePreload(() => import("./Example.BX_ByPoX.js"), true ? __vite__mapDeps([115,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.ChQ9Oisy.js"), true ? __vite__mapDeps([116,7,115,23,117]) : void 0, import.meta.url)
  },
  "model3d": {
    example: () => __vitePreload(() => import("./Example.Ydb40JSe.js"), true ? __vite__mapDeps([118,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.BcpLSuT7.js"), true ? __vite__mapDeps([119,25,3,14,78,18,7,26,27,28,20,8,10,4,32,30,118,23,120]) : void 0, import.meta.url)
  },
  "multimodaltextbox": {
    example: () => __vitePreload(() => import("./Example.Bdco60LN.js"), true ? __vite__mapDeps([121,35,8,36,10,85,19,86,122,40]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.BHXJpgWg.js"), true ? __vite__mapDeps([123,78,15,124,26,27,35,8,36,10,121,85,19,86,122,40,125]) : void 0, import.meta.url)
  },
  "nativeplot": {
    example: () => __vitePreload(() => import("./Example.BuFZhJ-J.js"), true ? [] : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.EkjABLTR.js"), true ? __vite__mapDeps([126,25,4,113,127]) : void 0, import.meta.url)
  },
  "number": {
    example: () => __vitePreload(() => import("./Example.C_6qP6MW.js"), true ? __vite__mapDeps([128,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.rNbQZIDY.js"), true ? __vite__mapDeps([129,130]) : void 0, import.meta.url)
  },
  "paramviewer": {
    example: () => __vitePreload(() => import("./Example.DmMqcInw.js"), true ? __vite__mapDeps([131,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.B7fie9U3.js"), true ? __vite__mapDeps([132,133]) : void 0, import.meta.url)
  },
  "plot": {
    base: () => __vitePreload(() => import("./Plot.BhrmBiCN.js").then((n) => n.b), true ? __vite__mapDeps([134,25,4]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.CPxJl5Am.js"), true ? __vite__mapDeps([135,134,25,4,3]) : void 0, import.meta.url)
  },
  "radio": {
    example: () => __vitePreload(() => import("./Example.DH7CNEn-.js"), true ? __vite__mapDeps([136,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.wgCBRpNo.js"), true ? __vite__mapDeps([137,136,23,138]) : void 0, import.meta.url)
  },
  "row": {
    component: () => __vitePreload(() => import("./Index.C4rHS1C7.js"), true ? __vite__mapDeps([139,140]) : void 0, import.meta.url)
  },
  "slider": {
    example: () => __vitePreload(() => import("./Example.CTo-xuiL.js"), true ? __vite__mapDeps([141,23]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.BYRl9nej.js"), true ? __vite__mapDeps([142,143]) : void 0, import.meta.url)
  },
  "state": {
    component: () => __vitePreload(() => import("./Index.DwWOSwcb.js"), true ? [] : void 0, import.meta.url)
  },
  "statustracker": {
    component: () => __vitePreload(() => import("./index.CeOWPMlw.js"), true ? __vite__mapDeps([144,31]) : void 0, import.meta.url)
  },
  "tabitem": {
    component: () => __vitePreload(() => import("./Index.BaDdcX1E.js"), true ? __vite__mapDeps([145,146,147,148]) : void 0, import.meta.url)
  },
  "tabs": {
    component: () => __vitePreload(() => import("./Index.c4wt6laL.js"), true ? __vite__mapDeps([149,146,147]) : void 0, import.meta.url)
  },
  "textbox": {
    example: () => __vitePreload(() => import("./Example.N3QsiMhe.js"), true ? [] : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./Index.BIOoGeh4.js"), true ? __vite__mapDeps([150,63]) : void 0, import.meta.url)
  },
  "timer": {
    component: () => __vitePreload(() => import("./Index.DuqzlIfu.js"), true ? [] : void 0, import.meta.url)
  },
  "uploadbutton": {
    component: () => __vitePreload(() => import("./Index.PmFoRO_o.js"), true ? __vite__mapDeps([151,152]) : void 0, import.meta.url)
  },
  "video": {
    base: () => __vitePreload(() => import("./VideoPreview.kpXYMTB0.js").then((n) => n.a), true ? __vite__mapDeps([153,3,4,12,13,14,124,7,20,8,10,16,17,18,85,19,86,28,154,27]) : void 0, import.meta.url),
    example: () => __vitePreload(() => import("./Example.HUy-V3IF.js"), true ? __vite__mapDeps([155,85,8,19,86,10,156]) : void 0, import.meta.url),
    component: () => __vitePreload(() => import("./index.BHqhB4kL.js"), true ? __vite__mapDeps([157,26,27,3,124,29,30,35,8,36,10,103,6,99,72,31,7,104,85,19,86,153,4,12,13,14,20,16,17,18,28,154,155,156,32,158,40,101]) : void 0, import.meta.url)
  }
};
const request_map = {};
const is_browser$3 = typeof window !== "undefined";
function load_component({ api_url, name, id: id2, variant }) {
  var _a2, _b, _c, _d;
  const comps = is_browser$3 && window.__GRADIO__CC__;
  const _component_map = {
    // eslint-disable-next-line no-undef
    ...component_map,
    ...!comps ? {} : comps
  };
  let _id2 = id2 || name;
  if (request_map[`${_id2}-${variant}`]) {
    return { component: request_map[`${_id2}-${variant}`], name };
  }
  try {
    if (!((_a2 = _component_map == null ? void 0 : _component_map[_id2]) == null ? void 0 : _a2[variant]) && !((_b = _component_map == null ? void 0 : _component_map[name]) == null ? void 0 : _b[variant]))
      throw new Error();
    request_map[`${_id2}-${variant}`] = (((_c = _component_map == null ? void 0 : _component_map[_id2]) == null ? void 0 : _c[variant]) || // for dev mode custom components
    ((_d = _component_map == null ? void 0 : _component_map[name]) == null ? void 0 : _d[variant]))();
    return {
      name,
      component: request_map[`${_id2}-${variant}`]
    };
  } catch (e) {
    if (!_id2)
      throw new Error(`Component not found: ${name}`);
    try {
      request_map[`${_id2}-${variant}`] = get_component_with_css(
        api_url,
        _id2,
        variant
      );
      return {
        name,
        component: request_map[`${_id2}-${variant}`]
      };
    } catch (e2) {
      if (variant === "example") {
        request_map[`${_id2}-${variant}`] = __vitePreload(() => import("./Example.Ce2XkglX.js"), true ? __vite__mapDeps([159,23]) : void 0, import.meta.url);
        return {
          name,
          component: request_map[`${_id2}-${variant}`]
        };
      }
      console.error(`failed to load: ${name}`);
      console.error(e2);
      throw e2;
    }
  }
}
function load_css(url) {
  if (!is_browser$3) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const link2 = document.createElement("link");
    link2.rel = "stylesheet";
    link2.href = url;
    document.head.appendChild(link2);
    link2.onload = () => resolve();
    link2.onerror = () => reject();
  });
}
function get_component_with_css(api_url, id2, variant) {
  const environment = is_browser$3 ? "client" : "server";
  let path2;
  if (environment === "server") {
    return Promise.all([
      load_css(`${api_url}/custom_component/${id2}/${variant}/style.css`),
      __vitePreload(() => import(
        /* @vite-ignore */
        "./Index.BSvE2fZR.js"
      ), true ? __vite__mapDeps([160,161]) : void 0, import.meta.url)
    ]).then(([_, module]) => {
      return module;
    });
  }
  path2 = `${api_url}/custom_component/${id2}/${environment}/${variant}/index.js`;
  return Promise.all([
    load_css(`${api_url}/custom_component/${id2}/${environment}/${variant}/style.css`),
    import(
      /* @vite-ignore */
      path2
    )
  ]).then(([_, module]) => {
    return module;
  });
}
function create_loading_status_store() {
  const store = writable({});
  const fn_inputs = {};
  const fn_outputs = {};
  const pending_outputs = /* @__PURE__ */ new Map();
  const pending_inputs = /* @__PURE__ */ new Map();
  const inputs_to_update = /* @__PURE__ */ new Map();
  const fn_status = {};
  function update({
    fn_index,
    status,
    queue: queue2 = true,
    size,
    position = null,
    eta = null,
    message = null,
    progress,
    time_limit = null
  }) {
    const outputs = fn_outputs[fn_index];
    const inputs = fn_inputs[fn_index];
    const last_status = fn_status[fn_index];
    const outputs_to_update = outputs.map((id2) => {
      let new_status;
      const pending_count = pending_outputs.get(id2) || 0;
      if (last_status === "pending" && status !== "pending") {
        let new_count = pending_count - 1;
        pending_outputs.set(id2, new_count < 0 ? 0 : new_count);
        new_status = new_count > 0 ? "pending" : status;
      } else if (last_status === "pending" && status === "pending") {
        new_status = "pending";
      } else if (last_status !== "pending" && status === "pending") {
        new_status = "pending";
        pending_outputs.set(id2, pending_count + 1);
      } else {
        new_status = status;
      }
      return {
        id: id2,
        queue_position: position,
        queue_size: size,
        eta,
        status: new_status,
        message,
        progress
      };
    });
    inputs.forEach((id2) => {
      const pending_count = pending_inputs.get(id2) || 0;
      if (last_status === "pending" && status !== "pending") {
        let new_count = pending_count - 1;
        pending_inputs.set(id2, new_count < 0 ? 0 : new_count);
        inputs_to_update.set(id2, status);
      } else if (last_status !== "pending" && status === "pending") {
        pending_inputs.set(id2, pending_count + 1);
        inputs_to_update.set(id2, status);
      } else {
        inputs_to_update.delete(id2);
      }
    });
    store.update((outputs2) => {
      outputs_to_update.forEach(
        ({
          id: id2,
          queue_position,
          queue_size,
          eta: eta2,
          status: status2,
          message: message2,
          progress: progress2
        }) => {
          outputs2[id2] = {
            queue: queue2,
            queue_size,
            queue_position,
            eta: eta2,
            message: message2,
            progress: progress2,
            status: status2,
            fn_index
          };
        }
      );
      return outputs2;
    });
    fn_status[fn_index] = status;
  }
  function register(index, inputs, outputs) {
    fn_inputs[index] = inputs;
    fn_outputs[index] = outputs;
  }
  return {
    update,
    register,
    subscribe: store.subscribe,
    get_status_for_fn(i) {
      return fn_status[i];
    },
    get_inputs_to_update() {
      return inputs_to_update;
    }
  };
}
let pending_updates = [];
const is_browser$2 = typeof window !== "undefined";
const raf$1 = is_browser$2 ? requestAnimationFrame : async (fn2) => await fn2();
function create_components(initial_layout) {
  let _component_map;
  let target_map = writable({});
  let _target_map = {};
  let inputs;
  let outputs;
  let constructor_map;
  let instance_map;
  let loading_status = create_loading_status_store();
  const layout_store = writable(initial_layout);
  let _components = [];
  let app;
  let keyed_component_values = {};
  let _rootNode;
  function set_event_specific_args(dependencies) {
    dependencies.forEach((dep) => {
      dep.targets.forEach((target) => {
        var _a2, _b;
        const instance2 = instance_map[target[0]];
        if (instance2 && ((_a2 = dep.event_specific_args) == null ? void 0 : _a2.length) > 0) {
          (_b = dep.event_specific_args) == null ? void 0 : _b.forEach((arg) => {
            instance2.props[arg] = dep[arg];
          });
        }
      });
    });
  }
  async function create_layout({
    app: _app,
    components,
    layout,
    dependencies,
    root,
    options: options2
  }) {
    flush2();
    app = _app;
    store_keyed_values(_components);
    _components = components;
    inputs = /* @__PURE__ */ new Set();
    outputs = /* @__PURE__ */ new Set();
    pending_updates = [];
    constructor_map = /* @__PURE__ */ new Map();
    _component_map = /* @__PURE__ */ new Map();
    instance_map = {};
    _rootNode = {
      id: layout.id,
      type: "column",
      props: { interactive: false, scale: options2.fill_height ? 1 : null },
      has_modes: false,
      instance: null,
      component: null,
      component_class_id: "",
      key: null
    };
    components.push(_rootNode);
    dependencies.forEach((dep) => {
      loading_status.register(dep.id, dep.inputs, dep.outputs);
      dep.frontend_fn = process_frontend_fn(
        dep.js,
        !!dep.backend_fn,
        dep.inputs.length,
        dep.outputs.length
      );
      create_target_meta(dep.targets, dep.id, _target_map);
      get_inputs_outputs(dep, inputs, outputs);
    });
    target_map.set(_target_map);
    constructor_map = preload_all_components(components, root);
    instance_map = components.reduce(
      (acc, c) => {
        acc[c.id] = c;
        return acc;
      },
      {}
    );
    await walk_layout(layout, root);
    layout_store.set(_rootNode);
    set_event_specific_args(dependencies);
  }
  function rerender_layout({
    render_id,
    components,
    layout,
    root,
    dependencies
  }) {
    let _constructor_map = preload_all_components(components, root);
    _constructor_map.forEach((v, k) => {
      constructor_map.set(k, v);
    });
    _target_map = {};
    dependencies.forEach((dep) => {
      loading_status.register(dep.id, dep.inputs, dep.outputs);
      dep.frontend_fn = process_frontend_fn(
        dep.js,
        !!dep.backend_fn,
        dep.inputs.length,
        dep.outputs.length
      );
      create_target_meta(dep.targets, dep.id, _target_map);
      get_inputs_outputs(dep, inputs, outputs);
    });
    target_map.set(_target_map);
    let current_element = instance_map[layout.id];
    let all_current_children = [];
    const add_to_current_children = (component) => {
      all_current_children.push(component);
      if (component.children) {
        component.children.forEach((child) => {
          add_to_current_children(child);
        });
      }
    };
    add_to_current_children(current_element);
    store_keyed_values(all_current_children);
    Object.entries(instance_map).forEach(([id2, component]) => {
      let _id2 = Number(id2);
      if (component.rendered_in === render_id) {
        delete instance_map[_id2];
        if (_component_map.has(_id2)) {
          _component_map.delete(_id2);
        }
      }
    });
    components.forEach((c) => {
      instance_map[c.id] = c;
      _component_map.set(c.id, c);
    });
    if (current_element.parent) {
      current_element.parent.children[current_element.parent.children.indexOf(current_element)] = instance_map[layout.id];
    }
    walk_layout(layout, root, current_element.parent).then(() => {
      layout_store.set(_rootNode);
    });
    set_event_specific_args(dependencies);
  }
  async function walk_layout(node, root, parent) {
    var _a2, _b;
    const instance2 = instance_map[node.id];
    instance2.component = (_a2 = await constructor_map.get(
      instance2.component_class_id || instance2.type
    )) == null ? void 0 : _a2.default;
    instance2.parent = parent;
    if (instance2.type === "dataset") {
      instance2.props.component_map = get_component(
        instance2.type,
        instance2.component_class_id,
        root,
        _components,
        instance2.props.components
      ).example_components;
    }
    if (_target_map[instance2.id]) {
      instance2.props.attached_events = Object.keys(_target_map[instance2.id]);
    }
    instance2.props.interactive = determine_interactivity(
      instance2.id,
      instance2.props.interactive,
      instance2.props.value,
      inputs,
      outputs
    );
    instance2.props.server = process_server_fn(
      instance2.id,
      instance2.props.server_fns,
      app
    );
    if (instance2.key != null && keyed_component_values[instance2.key] !== void 0) {
      instance2.props.value = keyed_component_values[instance2.key];
    }
    _component_map.set(instance2.id, instance2);
    if (node.children) {
      instance2.children = await Promise.all(
        node.children.map((v) => walk_layout(v, root, instance2))
      );
    }
    if (instance2.type === "tabs" && !instance2.props.initial_tabs) {
      const tab_items_props = ((_b = node.children) == null ? void 0 : _b.map((c) => {
        var _a3;
        const instance22 = instance_map[c.id];
        (_a3 = instance22.props).id ?? (_a3.id = c.id);
        return {
          type: instance22.type,
          props: {
            ...instance22.props,
            id: instance22.props.id
          }
        };
      })) || [];
      const child_tab_items = tab_items_props.filter(
        (child) => child.type === "tabitem"
      );
      instance2.props.initial_tabs = child_tab_items == null ? void 0 : child_tab_items.map((child) => ({
        label: child.props.label,
        id: child.props.id,
        visible: child.props.visible,
        interactive: child.props.interactive
      }));
    }
    return instance2;
  }
  let update_scheduled = false;
  let update_scheduled_store = writable(false);
  function store_keyed_values(components) {
    components.forEach((c) => {
      if (c.key != null) {
        keyed_component_values[c.key] = c.props.value;
      }
    });
  }
  function flush2() {
    layout_store.update((layout) => {
      for (let i = 0; i < pending_updates.length; i++) {
        for (let j = 0; j < pending_updates[i].length; j++) {
          const update = pending_updates[i][j];
          if (!update)
            continue;
          const instance2 = instance_map[update.id];
          if (!instance2)
            continue;
          let new_value;
          if (update.value instanceof Map)
            new_value = new Map(update.value);
          else if (update.value instanceof Set)
            new_value = new Set(update.value);
          else if (Array.isArray(update.value))
            new_value = [...update.value];
          else if (update.value == null)
            new_value = null;
          else if (typeof update.value === "object")
            new_value = { ...update.value };
          else
            new_value = update.value;
          instance2.props[update.prop] = new_value;
        }
      }
      return layout;
    });
    pending_updates = [];
    update_scheduled = false;
    update_scheduled_store.set(false);
  }
  function update_value(updates) {
    if (!updates)
      return;
    pending_updates.push(updates);
    if (!update_scheduled) {
      update_scheduled = true;
      update_scheduled_store.set(true);
      raf$1(flush2);
    }
  }
  function get_data(id2) {
    let comp = _component_map.get(id2);
    if (!comp) {
      const layout = get(layout_store);
      comp = findComponentById(layout, id2);
    }
    if (!comp) {
      return null;
    }
    if (comp.instance.get_value) {
      return comp.instance.get_value();
    }
    return comp.props.value;
  }
  function findComponentById(node, id2) {
    if (node.id === id2) {
      return node;
    }
    if (node.children) {
      for (const child of node.children) {
        const result = findComponentById(child, id2);
        if (result) {
          return result;
        }
      }
    }
    return void 0;
  }
  function modify_stream(id2, state) {
    const comp = _component_map.get(id2);
    if (comp && comp.instance.modify_stream_state) {
      comp.instance.modify_stream_state(state);
    }
  }
  function get_stream_state(id2) {
    const comp = _component_map.get(id2);
    if (comp && comp.instance.get_stream_state)
      return comp.instance.get_stream_state();
    return "not_set";
  }
  function set_time_limit(id2, time_limit) {
    const comp = _component_map.get(id2);
    if (comp && comp.instance.set_time_limit) {
      comp.instance.set_time_limit(time_limit);
    }
  }
  return {
    layout: layout_store,
    targets: target_map,
    update_value,
    get_data,
    modify_stream,
    get_stream_state,
    set_time_limit,
    loading_status,
    scheduled_updates: update_scheduled_store,
    create_layout,
    rerender_layout
  };
}
const AsyncFunction = Object.getPrototypeOf(
  async function() {
  }
).constructor;
function process_frontend_fn(source, backend_fn, input_length, output_length) {
  if (!source)
    return null;
  const wrap = backend_fn ? input_length === 1 : output_length === 1;
  try {
    return new AsyncFunction(
      "__fn_args",
      `  let result = await (${source})(...__fn_args);
  if (typeof result === "undefined") return [];
  return (${wrap} && !Array.isArray(result)) ? [result] : result;`
    );
  } catch (e) {
    console.error("Could not parse custom js method.");
    console.error(e);
    return null;
  }
}
function create_target_meta(targets, fn_id, target_map) {
  targets.forEach(([id2, trigger]) => {
    var _a2, _b;
    if (!target_map[id2]) {
      target_map[id2] = {};
    }
    if (((_a2 = target_map[id2]) == null ? void 0 : _a2[trigger]) && !((_b = target_map[id2]) == null ? void 0 : _b[trigger].includes(fn_id))) {
      target_map[id2][trigger].push(fn_id);
    } else {
      target_map[id2][trigger] = [fn_id];
    }
  });
  return target_map;
}
function get_inputs_outputs(dep, inputs, outputs) {
  dep.inputs.forEach((input) => inputs.add(input));
  dep.outputs.forEach((output) => outputs.add(output));
  return [inputs, outputs];
}
function has_no_default_value(value) {
  return Array.isArray(value) && value.length === 0 || value === "" || value === 0 || !value;
}
function determine_interactivity(id2, interactive_prop, value, inputs, outputs) {
  if (interactive_prop === false) {
    return false;
  } else if (interactive_prop === true) {
    return true;
  } else if (inputs.has(id2) || !outputs.has(id2) && has_no_default_value(value)) {
    return true;
  }
  return false;
}
function process_server_fn(id2, server_fns, app) {
  if (!server_fns) {
    return {};
  }
  return server_fns.reduce((acc, fn2) => {
    acc[fn2] = async (...args) => {
      if (args.length === 1) {
        args = args[0];
      }
      const result = await app.component_server(id2, fn2, args);
      return result;
    };
    return acc;
  }, {});
}
function get_component(type, class_id, root, components, example_components) {
  let example_component_map = /* @__PURE__ */ new Map();
  if (type === "dataset" && example_components) {
    example_components.forEach((name) => {
      if (example_component_map.has(name)) {
        return;
      }
      let _c2;
      const matching_component = components.find((c) => c.type === name);
      if (matching_component) {
        _c2 = load_component({
          api_url: root,
          name,
          id: matching_component.component_class_id,
          variant: "example"
        });
        example_component_map.set(name, _c2.component);
      }
    });
  }
  const _c = load_component({
    api_url: root,
    name: type,
    id: class_id,
    variant: "component"
  });
  return {
    component: _c.component,
    name: _c.name,
    example_components: example_component_map.size > 0 ? example_component_map : void 0
  };
}
function preload_all_components(components, root) {
  let constructor_map = /* @__PURE__ */ new Map();
  components.forEach((c) => {
    const { component, example_components } = get_component(
      c.type,
      c.component_class_id,
      root,
      components
    );
    constructor_map.set(c.component_class_id || c.type, component);
    if (example_components) {
      for (const [name, example_component] of example_components) {
        constructor_map.set(name, example_component);
      }
    }
  });
  return constructor_map;
}
const common$p = {
  built_with_gradio: "   Gradio",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$p = {
  click_to_upload: " ",
  drop_audio: "   ",
  drop_csv: "   ",
  drop_file: "  ",
  drop_image: "  ",
  drop_video: "  "
};
const ar = {
  common: common$p,
  upload_text: upload_text$p
};
const __vite_glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$p,
  default: ar,
  upload_text: upload_text$p
}, Symbol.toStringTag, { value: "Module" }));
const common$o = {
  built_with_gradio: "Construt amb gradio",
  clear: "Neteja",
  empty: "Buit",
  error: "Error",
  loading: "S'est carregant",
  or: "o",
  submit: "Envia"
};
const upload_text$o = {
  click_to_upload: "Feu clic per pujar",
  drop_audio: "Deixeu anar l'udio aqu",
  drop_csv: "Deixeu anar el CSV aqu",
  drop_file: "Deixeu anar el fitxer aqu",
  drop_image: "Deixeu anar la imatge aqu",
  drop_video: "Deixeu anar el vdeo aqu"
};
const ca = {
  common: common$o,
  upload_text: upload_text$o
};
const __vite_glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$o,
  default: ca,
  upload_text: upload_text$o
}, Symbol.toStringTag, { value: "Module" }));
const annotated_image$4 = {
  annotated_image: "  "
};
const audio$5 = {
  allow_recording_access: "       .",
  audio: "",
  record_from_microphone: "  ",
  stop_recording: " "
};
const blocks$4 = {
  connection_can_break: "                     .",
  long_requests_queue: "   .       .",
  lost_connection: "    . "
};
const checkbox$4 = {
  checkbox: " ",
  checkbox_group: "  "
};
const code$4 = {
  code: ""
};
const color_picker$4 = {
  color_picker: " "
};
const common$n = {
  built_with: " ...",
  built_with_gradio: "Gradio  ",
  clear: "",
  download: "",
  edit: "",
  empty: "",
  error: "",
  hosted_on: "  ",
  loading: "",
  logo: "",
  or: "",
  remove: "",
  share: "",
  submit: "",
  undo: ""
};
const dataframe$4 = {
  incorrect_format: "    CSV  TSV  ",
  new_column: " ",
  new_row: " "
};
const dropdown$4 = {
  dropdown: " "
};
const errors$4 = {
  build_error: "  ",
  config_error: "  ",
  contact_page_author: "         .",
  no_app_file: "   ",
  runtime_error: " runtime ",
  space_not_working: '"  " {0}',
  space_paused: " ",
  use_via_api: "  API  "
};
const file$4 = {
  uploading: "..."
};
const highlighted_text$4 = {
  highlighted_text: "  "
};
const image$4 = {
  allow_webcam_access: "       .",
  brush_color: " ",
  brush_radius: " ",
  image: "",
  remove_image: " ",
  select_brush_color: "  ",
  start_drawing: "   ",
  use_brush: " "
};
const label$4 = {
  label: ""
};
const login$4 = {
  enable_cookies: "   HuggingFace Space          .",
  incorrect_credentials: " ",
  login: " "
};
const number$4 = {
  number: ""
};
const plot$4 = {
  plot: ""
};
const radio$4 = {
  radio: ""
};
const slider$4 = {
  slider: ""
};
const upload_text$n = {
  click_to_upload: "   ",
  drop_audio: "  ",
  drop_csv: " CSV ",
  drop_file: "  ",
  drop_image: "  ",
  drop_video: "  "
};
const ckb = {
  "3D_model": {
    "3d_model": "  "
  },
  annotated_image: annotated_image$4,
  audio: audio$5,
  blocks: blocks$4,
  checkbox: checkbox$4,
  code: code$4,
  color_picker: color_picker$4,
  common: common$n,
  dataframe: dataframe$4,
  dropdown: dropdown$4,
  errors: errors$4,
  file: file$4,
  highlighted_text: highlighted_text$4,
  image: image$4,
  label: label$4,
  login: login$4,
  number: number$4,
  plot: plot$4,
  radio: radio$4,
  slider: slider$4,
  upload_text: upload_text$n
};
const __vite_glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotated_image: annotated_image$4,
  audio: audio$5,
  blocks: blocks$4,
  checkbox: checkbox$4,
  code: code$4,
  color_picker: color_picker$4,
  common: common$n,
  dataframe: dataframe$4,
  default: ckb,
  dropdown: dropdown$4,
  errors: errors$4,
  file: file$4,
  highlighted_text: highlighted_text$4,
  image: image$4,
  label: label$4,
  login: login$4,
  number: number$4,
  plot: plot$4,
  radio: radio$4,
  slider: slider$4,
  upload_text: upload_text$n
}, Symbol.toStringTag, { value: "Module" }));
const common$m = {
  built_with_gradio: "Mit Gradio erstellt",
  clear: "Lschen",
  or: "oder",
  submit: "Absenden"
};
const upload_text$m = {
  click_to_upload: "Hochladen",
  drop_audio: "Audio hier ablegen",
  drop_csv: "CSV Datei hier ablegen",
  drop_file: "Datei hier ablegen",
  drop_image: "Bild hier ablegen",
  drop_video: "Video hier ablegen"
};
const de = {
  common: common$m,
  upload_text: upload_text$m
};
const __vite_glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$m,
  default: de,
  upload_text: upload_text$m
}, Symbol.toStringTag, { value: "Module" }));
const annotated_image$3 = {
  annotated_image: "Annotated Image"
};
const audio$4 = {
  allow_recording_access: "Please allow access to the microphone for recording.",
  audio: "Audio",
  record_from_microphone: "Record from microphone",
  stop_recording: "Stop recording",
  no_device_support: "Media devices could not be accessed. Check that you are running on a secure origin (https) or localhost (or you have passed a valid SSL certificate to ssl_verify), and you have allowed browser access to your device.",
  stop: "Stop",
  resume: "Resume",
  record: "Record",
  no_microphone: "No microphone found",
  pause: "Pause",
  play: "Play",
  waiting: "Waiting"
};
const blocks$3 = {
  connection_can_break: "On mobile, the connection can break if this tab is unfocused or the device sleeps, losing your position in queue.",
  long_requests_queue: "There is a long queue of requests pending. Duplicate this Space to skip.",
  lost_connection: "Lost connection due to leaving page. Rejoining queue...",
  waiting_for_inputs: "Waiting for file(s) to finish uploading, please retry."
};
const checkbox$3 = {
  checkbox: "Checkbox",
  checkbox_group: "Checkbox Group"
};
const code$3 = {
  code: "Code"
};
const color_picker$3 = {
  color_picker: "Color Picker"
};
const common$l = {
  built_with: "built with",
  built_with_gradio: "Built with Gradio",
  clear: "Clear",
  download: "Download",
  edit: "Edit",
  empty: "Empty",
  error: "Error",
  hosted_on: "Hosted on",
  loading: "Loading",
  logo: "logo",
  or: "or",
  remove: "Remove",
  share: "Share",
  submit: "Submit",
  undo: "Undo",
  no_devices: "No devices found"
};
const dataframe$3 = {
  incorrect_format: "Incorrect format, only CSV and TSV files are supported",
  new_column: "Add column",
  new_row: "New row",
  add_row_above: "Add row above",
  add_row_below: "Add row below",
  add_column_left: "Add column to the left",
  add_column_right: "Add column to the right"
};
const dropdown$3 = {
  dropdown: "Dropdown"
};
const errors$3 = {
  build_error: "there is a build error",
  config_error: "there is a config error",
  contact_page_author: "Please contact the author of the page to let them know.",
  no_app_file: "there is no app file",
  runtime_error: "there is a runtime error",
  space_not_working: `"Space isn't working because" {0}`,
  space_paused: "the space is paused",
  use_via_api: "Use via API"
};
const file$3 = {
  uploading: "Uploading..."
};
const highlighted_text$3 = {
  highlighted_text: "Highlighted Text"
};
const image$3 = {
  allow_webcam_access: "Please allow access to the webcam for recording.",
  brush_color: "Brush color",
  brush_radius: "Brush radius",
  image: "Image",
  remove_image: "Remove Image",
  select_brush_color: "Select brush color",
  start_drawing: "Start drawing",
  use_brush: "Use brush"
};
const label$3 = {
  label: "Label"
};
const login$3 = {
  enable_cookies: "If you are visiting a HuggingFace Space in Incognito mode, you must enable third party cookies.",
  incorrect_credentials: "Incorrect Credentials",
  login: "Login"
};
const number$3 = {
  number: "Number"
};
const plot$3 = {
  plot: "Plot"
};
const radio$3 = {
  radio: "Radio"
};
const slider$3 = {
  slider: "Slider"
};
const upload_text$l = {
  click_to_upload: "Click to Upload",
  drop_audio: "Drop Audio Here",
  drop_csv: "Drop CSV Here",
  drop_file: "Drop File Here",
  drop_image: "Drop Image Here",
  drop_video: "Drop Video Here",
  drop_gallery: "Drop Media Here",
  paste_clipboard: "Paste from Clipboard"
};
const en = {
  "3D_model": {
    "3d_model": "3D Model"
  },
  annotated_image: annotated_image$3,
  audio: audio$4,
  blocks: blocks$3,
  checkbox: checkbox$3,
  code: code$3,
  color_picker: color_picker$3,
  common: common$l,
  dataframe: dataframe$3,
  dropdown: dropdown$3,
  errors: errors$3,
  file: file$3,
  highlighted_text: highlighted_text$3,
  image: image$3,
  label: label$3,
  login: login$3,
  number: number$3,
  plot: plot$3,
  radio: radio$3,
  slider: slider$3,
  upload_text: upload_text$l
};
const __vite_glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotated_image: annotated_image$3,
  audio: audio$4,
  blocks: blocks$3,
  checkbox: checkbox$3,
  code: code$3,
  color_picker: color_picker$3,
  common: common$l,
  dataframe: dataframe$3,
  default: en,
  dropdown: dropdown$3,
  errors: errors$3,
  file: file$3,
  highlighted_text: highlighted_text$3,
  image: image$3,
  label: label$3,
  login: login$3,
  number: number$3,
  plot: plot$3,
  radio: radio$3,
  slider: slider$3,
  upload_text: upload_text$l
}, Symbol.toStringTag, { value: "Module" }));
const common$k = {
  built_with_gradio: "Construido con Gradio",
  clear: "Limpiar",
  or: "o",
  submit: "Enviar"
};
const upload_text$k = {
  click_to_upload: "Haga click para cargar",
  drop_audio: "Coloque el audio aqu",
  drop_csv: "Coloque el CSV aqu",
  drop_file: "Coloque el archivo aqu",
  drop_image: "Coloque la imagen aqu",
  drop_video: "Coloque el video aqu",
  drop_gallery: "Coloque las imagenes aqu"
};
const es = {
  common: common$k,
  upload_text: upload_text$k
};
const __vite_glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$k,
  default: es,
  upload_text: upload_text$k
}, Symbol.toStringTag, { value: "Module" }));
const common$j = {
  built_with_gradio: "Gradiorekin eraikia",
  clear: "Garbitu",
  or: "edo",
  submit: "Bidali"
};
const upload_text$j = {
  click_to_upload: "Klik egin kargatzeko",
  drop_audio: "Jarri hemen audioa",
  drop_csv: "Jarri hemen CSVa",
  drop_file: "Jarri hemen fitxategia",
  drop_image: "Jarri hemen irudia",
  drop_video: "Jarri hemen bideoa"
};
const eu = {
  common: common$j,
  upload_text: upload_text$j
};
const __vite_glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$j,
  default: eu,
  upload_text: upload_text$j
}, Symbol.toStringTag, { value: "Module" }));
const common$i = {
  built_with_gradio: "   gradio",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$i = {
  click_to_upload: "   ",
  drop_audio: "    ",
  drop_csv: " csv     ",
  drop_file: "    ",
  drop_image: "    ",
  drop_video: "    "
};
const fa = {
  common: common$i,
  upload_text: upload_text$i
};
const __vite_glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$i,
  default: fa,
  upload_text: upload_text$i
}, Symbol.toStringTag, { value: "Module" }));
const annotated_image$2 = {
  annotated_image: "Annotoitu kuva"
};
const audio$3 = {
  allow_recording_access: "Ole hyv ja anna selaimelle ja sivustolle psy mikrofoniin.",
  audio: "Audio",
  record_from_microphone: "nit mikrofonia",
  stop_recording: "Lopeta nitys",
  no_device_support: "Medialaitteita ei voitu kytt. Tarkista, ett yhteys on salattu (https), paikallinen (localhost), tai ssl_verify on saanut voimassa olevan SSL-sertifikaatin. Tarkista, ett olet antanut selaimelle psyn medialaitteeseen.",
  stop: "Stop",
  resume: "Jatka",
  record: "nit",
  no_microphone: "Ei mikrofonia kytss",
  pause: "Pause",
  play: "Play",
  waiting: "Odotetaan"
};
const blocks$2 = {
  connection_can_break: "Mobiililaitteella yhteys voi katketa, jos vaihdat vlilehte tai laite menee lepotilaa. Tllin menett paikkasi jonossa.",
  long_requests_queue: "Spacessa on ruuhkaa ja jono on pitk. Kopioi tm Space hyptksesi jonon ohi.",
  lost_connection: "Yhteys katkesi sivulta poistumisen seurauksena. Liitytn takaisin jonoon...",
  waiting_for_inputs: "Odotetaan latauksen valmistumista, ole hyv ja yrit uudelleen."
};
const checkbox$2 = {
  checkbox: "Valintaruutu",
  checkbox_group: "Valintaruuturyhm"
};
const code$2 = {
  code: "Koodi"
};
const color_picker$2 = {
  color_picker: "Vrivalitsin"
};
const common$h = {
  built_with: "tehty",
  built_with_gradio: "tehty Gradiolla",
  clear: "Poista",
  download: "Lataa",
  edit: "Muokkaa",
  empty: "Tyhjenn",
  error: "Virhe",
  hosted_on: "Hostattu",
  loading: "Ladataan",
  logo: "logo",
  or: "tai",
  remove: "Poista",
  share: "Jaa",
  submit: "Suorita",
  undo: "Kumoa",
  no_devices: "Laitetta ei lytynyt"
};
const dataframe$2 = {
  incorrect_format: "Yhteensopimaton tiedostomuoto, vain CSV- ja TSV-tiedostoja tuetaan.",
  new_column: "Lis sarake",
  new_row: "Lis rivi",
  add_row_above: "Lis rivi ylpuolelle",
  add_row_below: "Lis rivi alle",
  add_column_left: "Lis sarake vasemmalle",
  add_column_right: "Lis sarake oikealle"
};
const dropdown$2 = {
  dropdown: "Pudotusvalikko"
};
const errors$2 = {
  build_error: "tapahtui virhe",
  config_error: "virhe asetuksissa",
  contact_page_author: "Kerro yllpitjlle virheest.",
  no_app_file: "sovellustiedosto puuttuu",
  runtime_error: "ohjelman suorituksen aikana tapahtui virhe",
  space_not_working: '"Space ei toimi, koska" {0}',
  space_paused: "tila on tauolla",
  use_via_api: "Kyt rajapinnan kautta"
};
const file$2 = {
  uploading: "Ladataan..."
};
const highlighted_text$2 = {
  highlighted_text: "Korostettu teksti"
};
const image$2 = {
  allow_webcam_access: "Ole hyv ja anna lupa web-kameran kyttn.",
  brush_color: "Siveltimen vri",
  brush_radius: "Siveltimen koko",
  image: "Kuva",
  remove_image: "Poista kuva",
  select_brush_color: "Valitse siveltimen vri",
  start_drawing: "Aloita piirtminen",
  use_brush: "Kyt sivellint"
};
const label$2 = {
  label: "Tunniste"
};
const login$2 = {
  enable_cookies: "Jos kytt Hugging Face Spacea Incognito-tilassa, sinun on otettava kyttn kolmansien osapuolten evsteet..",
  incorrect_credentials: "Kyttjtietoja ei lytynyt",
  login: "Kirjaudu sisn"
};
const number$2 = {
  number: "Numero"
};
const plot$2 = {
  plot: "Kuvaaja"
};
const radio$2 = {
  radio: "Radio"
};
const slider$2 = {
  slider: "Sdin"
};
const upload_text$h = {
  click_to_upload: "Lataa palvelimelle",
  drop_audio: "Ved audiotiedosto thn",
  drop_csv: "Ved CSV thn",
  drop_file: "Ved tiedosto thn",
  drop_image: "Ved kuva thn",
  drop_video: "Ved video thn",
  drop_gallery: "Ved media thn",
  paste_clipboard: "Liit leikepydlt"
};
const fi = {
  "3D_model": {
    "3d_model": "3D-malli"
  },
  annotated_image: annotated_image$2,
  audio: audio$3,
  blocks: blocks$2,
  checkbox: checkbox$2,
  code: code$2,
  color_picker: color_picker$2,
  common: common$h,
  dataframe: dataframe$2,
  dropdown: dropdown$2,
  errors: errors$2,
  file: file$2,
  highlighted_text: highlighted_text$2,
  image: image$2,
  label: label$2,
  login: login$2,
  number: number$2,
  plot: plot$2,
  radio: radio$2,
  slider: slider$2,
  upload_text: upload_text$h
};
const __vite_glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotated_image: annotated_image$2,
  audio: audio$3,
  blocks: blocks$2,
  checkbox: checkbox$2,
  code: code$2,
  color_picker: color_picker$2,
  common: common$h,
  dataframe: dataframe$2,
  default: fi,
  dropdown: dropdown$2,
  errors: errors$2,
  file: file$2,
  highlighted_text: highlighted_text$2,
  image: image$2,
  label: label$2,
  login: login$2,
  number: number$2,
  plot: plot$2,
  radio: radio$2,
  slider: slider$2,
  upload_text: upload_text$h
}, Symbol.toStringTag, { value: "Module" }));
const audio$2 = {
  allow_recording_access: "Veuillez autoriser l'accs  l'enregistrement",
  audio: "Audio",
  record_from_microphone: "Enregistrer avec le microphone",
  stop_recording: "Arrter l'enregistrement"
};
const common$g = {
  built_with: "Construit avec",
  built_with_gradio: "Construit avec Gradio",
  clear: "Effacer",
  download: "Tlcharger",
  edit: "diter",
  error: "Erreur",
  loading: "Chargement",
  logo: "logo",
  or: "ou",
  remove: "Supprimer",
  share: "Partager",
  submit: "Soumettre"
};
const upload_text$g = {
  click_to_upload: "Cliquer pour Tlcharger",
  drop_audio: "Dposer l'Audio Ici",
  drop_csv: "Dposer le CSV Ici",
  drop_file: "Dposer le Fichier Ici",
  drop_image: "Dposer l'Image Ici",
  drop_video: "Dposer la Vido Ici"
};
const fr = {
  audio: audio$2,
  common: common$g,
  upload_text: upload_text$g
};
const __vite_glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audio: audio$2,
  common: common$g,
  default: fr,
  upload_text: upload_text$g
}, Symbol.toStringTag, { value: "Module" }));
const common$f = {
  built_with_gradio: "  ",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$f = {
  click_to_upload: "  ",
  drop_audio: "   ",
  drop_csv: " csv  ",
  drop_file: "  ",
  drop_image: "   ",
  drop_video: "   "
};
const he = {
  common: common$f,
  upload_text: upload_text$f
};
const __vite_glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$f,
  default: he,
  upload_text: upload_text$f
}, Symbol.toStringTag, { value: "Module" }));
const common$e = {
  built_with_gradio: "Gradio  ",
  clear: "",
  or: "",
  submit: " "
};
const upload_text$e = {
  click_to_upload: "    ",
  drop_audio: "   ",
  drop_csv: " CSV  ",
  drop_file: " File  ",
  drop_image: "   ",
  drop_video: "   "
};
const hi = {
  common: common$e,
  upload_text: upload_text$e
};
const __vite_glob_0_11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$e,
  default: hi,
  upload_text: upload_text$e
}, Symbol.toStringTag, { value: "Module" }));
const common$d = {
  built_with_gradio: "gradio",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$d = {
  click_to_upload: "",
  drop_audio: "",
  drop_csv: "CSV",
  drop_file: "",
  drop_image: "",
  drop_video: ""
};
const ja = {
  common: common$d,
  upload_text: upload_text$d
};
const __vite_glob_0_12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$d,
  default: ja,
  upload_text: upload_text$d
}, Symbol.toStringTag, { value: "Module" }));
const common$c = {
  built_with_gradio: "gradio ",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$c = {
  click_to_upload: " ",
  drop_audio: "  ",
  drop_csv: "CSV  ",
  drop_file: "  ",
  drop_image: "  ",
  drop_video: "  "
};
const ko = {
  common: common$c,
  upload_text: upload_text$c
};
const __vite_glob_0_13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$c,
  default: ko,
  upload_text: upload_text$c
}, Symbol.toStringTag, { value: "Module" }));
const common$b = {
  built_with_gradio: "sukurta su gradio",
  clear: "Trinti",
  or: "arba",
  submit: "Pateikti"
};
const upload_text$b = {
  click_to_upload: "Spustelkite nordami kelti",
  drop_audio: "kelkite garso ra ia",
  drop_csv: "kelkite CSV ia",
  drop_file: "kelkite byl ia",
  drop_image: "kelkite paveiksll ia",
  drop_video: "kelkite vaizdo ra ia"
};
const lt = {
  common: common$b,
  upload_text: upload_text$b
};
const __vite_glob_0_14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$b,
  default: lt,
  upload_text: upload_text$b
}, Symbol.toStringTag, { value: "Module" }));
const common$a = {
  built_with_gradio: "gemaakt met gradio",
  clear: "Wis",
  or: "of",
  submit: "Zend in"
};
const upload_text$a = {
  click_to_upload: "Klik om the Uploaden",
  drop_audio: "Sleep een Geluidsbestand hier",
  drop_csv: "Sleep een CSV hier",
  drop_file: "Sleep een Document hier",
  drop_image: "Sleep een Afbeelding hier",
  drop_video: "Sleep een Video hier"
};
const nl = {
  common: common$a,
  upload_text: upload_text$a
};
const __vite_glob_0_15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$a,
  default: nl,
  upload_text: upload_text$a
}, Symbol.toStringTag, { value: "Module" }));
const common$9 = {
  built_with_gradio: "utworzone z gradio",
  clear: "Wyczy",
  or: "lub",
  submit: "Zatwierd"
};
const upload_text$9 = {
  click_to_upload: "Kliknij, aby przesa",
  drop_audio: "Przecignij tutaj audio",
  drop_csv: "Przecignij tutaj CSV",
  drop_file: "Przecignij tutaj plik",
  drop_image: "Przecignij tutaj zdjcie",
  drop_video: "Przecignij tutaj video"
};
const pl = {
  common: common$9,
  upload_text: upload_text$9
};
const __vite_glob_0_16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$9,
  default: pl,
  upload_text: upload_text$9
}, Symbol.toStringTag, { value: "Module" }));
const common$8 = {
  built_with_gradio: "Construdo com gradio",
  clear: "Limpar",
  error: "Erro",
  flag: "Marcar",
  loading: "Carregando",
  or: "ou",
  submit: "Enviar"
};
const upload_text$8 = {
  click_to_upload: "Clique para o Upload",
  drop_audio: "Solte o udio Aqui",
  drop_csv: "Solte o CSV Aqui",
  drop_file: "Solte o Arquivo Aqui",
  drop_image: "Solte a Imagem Aqui",
  drop_video: "Solte o Vdeo Aqui"
};
const ptBR = {
  common: common$8,
  upload_text: upload_text$8
};
const __vite_glob_0_17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$8,
  default: ptBR,
  upload_text: upload_text$8
}, Symbol.toStringTag, { value: "Module" }));
const annotated_image$1 = {
  annotated_image: " "
};
const audio$1 = {
  allow_recording_access: ",      .",
  audio: "",
  record_from_microphone: "  ",
  stop_recording: " ",
  no_device_support: "     . ,       (https)  localhost (   SSL-  ssl_verify),      .",
  stop: "",
  resume: "",
  record: "",
  no_microphone: "  ",
  pause: "",
  play: ""
};
const blocks$1 = {
  connection_can_break: "     ,       ,        .",
  long_requests_queue: "  .   ,  .",
  lost_connection: "  -   .  ..."
};
const checkbox$1 = {
  checkbox: "",
  checkbox_group: " "
};
const code$1 = {
  code: ""
};
const color_picker$1 = {
  color_picker: " "
};
const common$7 = {
  built_with: " ",
  built_with_gradio: "   Gradio",
  clear: "",
  download: "",
  edit: "",
  empty: "",
  error: "",
  hosted_on: " ",
  loading: "",
  logo: "",
  or: "",
  remove: "",
  share: "",
  submit: "",
  undo: "",
  no_devices: "    "
};
const dataframe$1 = {
  incorrect_format: " ,    CSV  TSV",
  new_column: " ",
  new_row: " "
};
const dropdown$1 = {
  dropdown: "Dropdown"
};
const errors$1 = {
  build_error: "  ",
  config_error: "  ",
  contact_page_author: ",    ,     .",
  no_app_file: "  ",
  runtime_error: "   ",
  space_not_working: '"  ,  " {0}',
  space_paused: " ",
  use_via_api: "  API"
};
const file$1 = {
  uploading: "..."
};
const highlighted_text$1 = {
  highlighted_text: " "
};
const image$1 = {
  allow_webcam_access: ",    -  .",
  brush_color: " ",
  brush_radius: " ",
  image: "",
  remove_image: " ",
  select_brush_color: "  ",
  start_drawing: " ",
  use_brush: " "
};
const label$1 = {
  label: ""
};
const login$1 = {
  enable_cookies: "    HuggingFace   ,      cookie.",
  incorrect_credentials: "  ",
  login: "  "
};
const number$1 = {
  number: ""
};
const plot$1 = {
  plot: ""
};
const radio$1 = {
  radio: ""
};
const slider$1 = {
  slider: ""
};
const upload_text$7 = {
  click_to_upload: ",  ",
  drop_audio: "  ",
  drop_csv: "  CSV ",
  drop_file: "  ",
  drop_image: "  ",
  drop_video: "  ",
  drop_gallery: " (-) ",
  paste_clipboard: "   "
};
const ru = {
  "3D_model": {
    "3d_model": "3D-"
  },
  annotated_image: annotated_image$1,
  audio: audio$1,
  blocks: blocks$1,
  checkbox: checkbox$1,
  code: code$1,
  color_picker: color_picker$1,
  common: common$7,
  dataframe: dataframe$1,
  dropdown: dropdown$1,
  errors: errors$1,
  file: file$1,
  highlighted_text: highlighted_text$1,
  image: image$1,
  label: label$1,
  login: login$1,
  number: number$1,
  plot: plot$1,
  radio: radio$1,
  slider: slider$1,
  upload_text: upload_text$7
};
const __vite_glob_0_18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotated_image: annotated_image$1,
  audio: audio$1,
  blocks: blocks$1,
  checkbox: checkbox$1,
  code: code$1,
  color_picker: color_picker$1,
  common: common$7,
  dataframe: dataframe$1,
  default: ru,
  dropdown: dropdown$1,
  errors: errors$1,
  file: file$1,
  highlighted_text: highlighted_text$1,
  image: image$1,
  label: label$1,
  login: login$1,
  number: number$1,
  plot: plot$1,
  radio: radio$1,
  slider: slider$1,
  upload_text: upload_text$7
}, Symbol.toStringTag, { value: "Module" }));
const common$6 = {
  built_with_gradio: "  ",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$6 = {
  click_to_upload: " ",
  drop_audio: " ",
  drop_csv: "csv  ",
  drop_file: " ",
  drop_image: " ",
  drop_video: " "
};
const ta = {
  common: common$6,
  upload_text: upload_text$6
};
const __vite_glob_0_19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$6,
  default: ta,
  upload_text: upload_text$6
}, Symbol.toStringTag, { value: "Module" }));
const common$5 = {
  built_with_gradio: "Gradio ile oluturulmutur",
  clear: "Temizle",
  or: "veya",
  submit: "Ykle"
};
const upload_text$5 = {
  click_to_upload: "Yklemek iin Tkla",
  drop_audio: "Kayd Buraya Srkle",
  drop_csv: "CSV'yi Buraya Srkle",
  drop_file: "Dosyay Buraya Srkle",
  drop_image: "Resmi Buraya Srkle",
  drop_video: "Videoyu Buraya Srkle"
};
const tr = {
  common: common$5,
  upload_text: upload_text$5
};
const __vite_glob_0_20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$5,
  default: tr,
  upload_text: upload_text$5
}, Symbol.toStringTag, { value: "Module" }));
const common$4 = {
  built_with_gradio: "   gradio",
  clear: "",
  or: "",
  submit: ""
};
const upload_text$4 = {
  click_to_upload: "  ",
  drop_audio: "  ",
  drop_csv: " CSV- ",
  drop_file: "  ",
  drop_image: "  ",
  drop_video: "  "
};
const uk = {
  common: common$4,
  upload_text: upload_text$4
};
const __vite_glob_0_21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$4,
  default: uk,
  upload_text: upload_text$4
}, Symbol.toStringTag, { value: "Module" }));
const common$3 = {
  built_with_gradio: "    Gradio",
  clear: " ",
  or: "",
  submit: " "
};
const upload_text$3 = {
  click_to_upload: "     ",
  drop_audio: "   ",
  drop_csv: "   ",
  drop_file: "   ",
  drop_image: "   ",
  drop_video: "   "
};
const ur = {
  common: common$3,
  upload_text: upload_text$3
};
const __vite_glob_0_22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$3,
  default: ur,
  upload_text: upload_text$3
}, Symbol.toStringTag, { value: "Module" }));
const common$2 = {
  built_with_gradio: "gradio bilan qilingan",
  clear: "Tozalash",
  submit: "Yubor"
};
const upload_text$2 = {
  click_to_upload: "Yuklash uchun Bosing",
  drop_audio: "Audioni Shu Yerga Tashlang",
  drop_csv: "CSVni Shu Yerga Tashlang",
  drop_file: "Faylni Shu Yerga Tashlang",
  drop_image: "Rasmni Shu Yerga Tashlang",
  drop_video: "Videoni Shu Yerga Tashlang"
};
const uz = {
  common: common$2,
  upload_text: upload_text$2
};
const __vite_glob_0_23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common: common$2,
  default: uz,
  upload_text: upload_text$2
}, Symbol.toStringTag, { value: "Module" }));
const annotated_image = {
  annotated_image: ""
};
const audio = {
  allow_recording_access: "",
  audio: "",
  record_from_microphone: "",
  stop_recording: "",
  no_device_support: "https ssl_verify  SSL ",
  stop: "",
  resume: "",
  record: "",
  no_microphone: "",
  pause: "",
  play: "",
  waiting: ""
};
const blocks = {
  connection_can_break: "",
  long_requests_queue: "",
  lost_connection: "..."
};
const checkbox = {
  checkbox: "",
  checkbox_group: ""
};
const code = {
  code: ""
};
const color_picker = {
  color_picker: ""
};
const common$1 = {
  built_with: "",
  built_with_gradio: " Gradio ",
  clear: "",
  download: "",
  edit: "",
  empty: "",
  error: "",
  hosted_on: "",
  loading: "",
  logo: "",
  or: "",
  remove: "",
  share: "",
  submit: "",
  undo: ""
};
const dataframe = {
  incorrect_format: " CSV  TSV ",
  new_column: "",
  new_row: ""
};
const dropdown = {
  dropdown: ""
};
const errors = {
  build_error: "",
  config_error: "",
  contact_page_author: "",
  no_app_file: "",
  runtime_error: "",
  space_not_working: '"" {0}',
  space_paused: "",
  use_via_api: " API "
};
const file = {
  uploading: "..."
};
const highlighted_text = {
  highlighted_text: ""
};
const image = {
  allow_webcam_access: "",
  brush_color: "",
  brush_radius: "",
  image: "",
  remove_image: "",
  select_brush_color: "",
  start_drawing: "",
  use_brush: ""
};
const label = {
  label: ""
};
const login = {
  enable_cookies: " HuggingFace  cookie",
  incorrect_credentials: "",
  login: ""
};
const number = {
  number: ""
};
const plot = {
  plot: ""
};
const radio = {
  radio: ""
};
const slider = {
  slider: ""
};
const upload_text$1 = {
  click_to_upload: "",
  drop_audio: "",
  drop_csv: " CSV ",
  drop_file: "",
  drop_image: "",
  drop_video: ""
};
const zhCN = {
  "3D_model": {
    "3d_model": "3D"
  },
  annotated_image,
  audio,
  blocks,
  checkbox,
  code,
  color_picker,
  common: common$1,
  dataframe,
  dropdown,
  errors,
  file,
  highlighted_text,
  image,
  label,
  login,
  number,
  plot,
  radio,
  slider,
  upload_text: upload_text$1
};
const __vite_glob_0_24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotated_image,
  audio,
  blocks,
  checkbox,
  code,
  color_picker,
  common: common$1,
  dataframe,
  default: zhCN,
  dropdown,
  errors,
  file,
  highlighted_text,
  image,
  label,
  login,
  number,
  plot,
  radio,
  slider,
  upload_text: upload_text$1
}, Symbol.toStringTag, { value: "Module" }));
const common = {
  built_with_gradio: "Gradio",
  clear: "",
  or: "",
  submit: ""
};
const upload_text = {
  click_to_upload: "",
  drop_audio: "",
  drop_csv: "CSV",
  drop_file: "",
  drop_image: "",
  drop_video: ""
};
const zhTW = {
  common,
  upload_text
};
const __vite_glob_0_25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  common,
  default: zhTW,
  upload_text
}, Symbol.toStringTag, { value: "Module" }));
const langs = /* @__PURE__ */ Object.assign({
  "./lang/ar.json": __vite_glob_0_0,
  "./lang/ca.json": __vite_glob_0_1,
  "./lang/ckb.json": __vite_glob_0_2,
  "./lang/de.json": __vite_glob_0_3,
  "./lang/en.json": __vite_glob_0_4,
  "./lang/es.json": __vite_glob_0_5,
  "./lang/eu.json": __vite_glob_0_6,
  "./lang/fa.json": __vite_glob_0_7,
  "./lang/fi.json": __vite_glob_0_8,
  "./lang/fr.json": __vite_glob_0_9,
  "./lang/he.json": __vite_glob_0_10,
  "./lang/hi.json": __vite_glob_0_11,
  "./lang/ja.json": __vite_glob_0_12,
  "./lang/ko.json": __vite_glob_0_13,
  "./lang/lt.json": __vite_glob_0_14,
  "./lang/nl.json": __vite_glob_0_15,
  "./lang/pl.json": __vite_glob_0_16,
  "./lang/pt-BR.json": __vite_glob_0_17,
  "./lang/ru.json": __vite_glob_0_18,
  "./lang/ta.json": __vite_glob_0_19,
  "./lang/tr.json": __vite_glob_0_20,
  "./lang/uk.json": __vite_glob_0_21,
  "./lang/ur.json": __vite_glob_0_22,
  "./lang/uz.json": __vite_glob_0_23,
  "./lang/zh-CN.json": __vite_glob_0_24,
  "./lang/zh-TW.json": __vite_glob_0_25
});
function process_langs() {
  let _langs = {};
  for (const lang in langs) {
    const code2 = lang.split("/").pop().split(".").shift();
    _langs[code2] = langs[lang].default;
  }
  return _langs;
}
const processed_langs = process_langs();
for (const lang in processed_langs) {
  addMessages(lang, processed_langs[lang]);
}
async function setupi18n() {
  await init$1({
    fallbackLocale: "en",
    initialLocale: getLocaleFromNavigator()
  });
}
function create_fragment$C(ctx) {
  let svg2;
  let g;
  let path0;
  let path1;
  return {
    c() {
      svg2 = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        version: true,
        xmlns: true,
        "xmlns:xlink": true,
        "xml:space": true,
        style: true
      });
      var svg_nodes = children(svg2);
      g = claim_svg_element(svg_nodes, "g", {});
      var g_nodes = children(g);
      path0 = claim_svg_element(g_nodes, "path", { d: true });
      children(path0).forEach(detach);
      path1 = claim_svg_element(g_nodes, "path", { d: true });
      children(path1).forEach(detach);
      g_nodes.forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M3.789,0.09C3.903,-0.024 4.088,-0.024 4.202,0.09L4.817,0.705C4.931,0.819 4.931,1.004 4.817,1.118L1.118,4.817C1.004,4.931 0.819,4.931 0.705,4.817L0.09,4.202C-0.024,4.088 -0.024,3.903 0.09,3.789L3.789,0.09Z");
      attr(path1, "d", "M4.825,3.797C4.934,3.907 4.934,4.084 4.825,4.193L4.193,4.825C4.084,4.934 3.907,4.934 3.797,4.825L0.082,1.11C-0.027,1.001 -0.027,0.823 0.082,0.714L0.714,0.082C0.823,-0.027 1.001,-0.027 1.11,0.082L4.825,3.797Z");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "viewBox", "0 0 5 5");
      attr(svg2, "version", "1.1");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg2, "xml:space", "preserve");
      set_style(svg2, "fill", "currentColor");
      set_style(svg2, "fill-rule", "evenodd");
      set_style(svg2, "clip-rule", "evenodd");
      set_style(svg2, "stroke-linejoin", "round");
      set_style(svg2, "stroke-miterlimit", "2");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, g);
      append_hydration(g, path0);
      append_hydration(g, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
let Clear$1 = class Clear extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$C, safe_not_equal, {});
  }
};
function create_fragment$B(ctx) {
  let div;
  let h1;
  let textContent = "API Docs";
  let t1;
  let p0;
  let t2;
  let code0;
  let t3;
  let t4;
  let p1;
  let textContent_1 = `To expose an API endpoint of your app in this page, set the <code>api_name</code>
		parameter of the event listener.
		<br/>
		For more information, visit the
		<a href="https://gradio.app/sharing_your_app/#api-page" target="_blank">API Page guide</a>
		. To hide the API documentation button and this page, set
		<code>show_api=False</code>
		in the
		<code>Blocks.launch()</code>
		method.`;
  let t15;
  let button;
  let clear;
  let current2;
  let mounted;
  let dispose;
  clear = new Clear$1({});
  return {
    c() {
      div = element("div");
      h1 = element("h1");
      h1.textContent = textContent;
      t1 = space();
      p0 = element("p");
      t2 = text$3("No API Routes found for\n		");
      code0 = element("code");
      t3 = text$3(
        /*root*/
        ctx[0]
      );
      t4 = space();
      p1 = element("p");
      p1.innerHTML = textContent_1;
      t15 = space();
      button = element("button");
      create_component(clear.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(h1) !== "svelte-1nemy2n")
        h1.textContent = textContent;
      t1 = claim_space(div_nodes);
      p0 = claim_element(div_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "No API Routes found for\n		");
      code0 = claim_element(p0_nodes, "CODE", { class: true });
      var code0_nodes = children(code0);
      t3 = claim_text(
        code0_nodes,
        /*root*/
        ctx[0]
      );
      code0_nodes.forEach(detach);
      p0_nodes.forEach(detach);
      t4 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(p1) !== "svelte-2ediv8")
        p1.innerHTML = textContent_1;
      div_nodes.forEach(detach);
      t15 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(clear.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(code0, "class", "svelte-e1ha0f");
      attr(p0, "class", "attention svelte-e1ha0f");
      attr(div, "class", "wrap prose svelte-e1ha0f");
      attr(button, "class", "svelte-e1ha0f");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, h1);
      append_hydration(div, t1);
      append_hydration(div, p0);
      append_hydration(p0, t2);
      append_hydration(p0, code0);
      append_hydration(code0, t3);
      append_hydration(div, t4);
      append_hydration(div, p1);
      insert_hydration(target, t15, anchor);
      insert_hydration(target, button, anchor);
      mount_component(clear, button, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current2 || dirty & /*root*/
      1)
        set_data(
          t3,
          /*root*/
          ctx2[0]
        );
    },
    i(local) {
      if (current2)
        return;
      transition_in(clear.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(clear.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t15);
        detach(button);
      }
      destroy_component(clear);
      mounted = false;
      dispose();
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { root } = $$props;
  const click_handler = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
  };
  return [root, dispatch, click_handler];
}
class NoApi extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$t, create_fragment$B, safe_not_equal, { root: 0 });
  }
}
const api_logo = "data:image/svg+xml,%3csvg%20width='28'%20height='28'%20viewBox='0%200%2028%2028'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M26.9425%202.94265C27.4632%202.42195%2027.4632%201.57773%2026.9425%201.05703C26.4218%200.536329%2025.5776%200.536329%2025.0569%201.05703L22.5713%203.54256C21.1213%202.59333%2019.5367%202.43378%2018.1753%202.64006C16.5495%202.88638%2015.1127%203.66838%2014.3905%204.39053L12.3905%206.39053C12.1405%206.64058%2012%206.97972%2012%207.33334C12%207.68697%2012.1405%208.0261%2012.3905%208.27615L19.7239%2015.6095C20.2446%2016.1302%2021.0888%2016.1302%2021.6095%2015.6095L23.6095%2013.6095C24.3316%2012.8873%2025.1136%2011.4505%2025.36%209.82475C25.5663%208.46312%2025.4066%206.87827%2024.4571%205.42807L26.9425%202.94265Z'%20fill='%233c4555'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M12.276%2012.9426C12.7967%2012.4219%2012.7967%2011.5777%2012.276%2011.057C11.7553%2010.5363%2010.9111%2010.5363%2010.3904%2011.057L8.66651%2012.7809L8.27615%2012.3905C8.0261%2012.1405%207.68697%2012%207.33334%2012C6.97972%2012%206.64058%2012.1405%206.39053%2012.3905L4.39053%2014.3905C3.66838%2015.1127%202.88638%2016.5495%202.64006%2018.1753C2.43377%2019.5367%202.59333%2021.1214%203.54262%2022.5714L1.05703%2025.057C0.536329%2025.5777%200.536329%2026.4219%201.05703%2026.9426C1.57773%2027.4633%202.42195%2027.4633%202.94265%2026.9426L5.42817%2024.4571C6.87835%2025.4066%208.46315%2025.5663%209.82475%2025.36C11.4505%2025.1136%2012.8873%2024.3316%2013.6095%2023.6095L15.6095%2021.6095C16.1302%2021.0888%2016.1302%2020.2446%2015.6095%2019.7239L15.2188%2019.3332L16.9426%2017.6093C17.4633%2017.0886%2017.4633%2016.2444%2016.9426%2015.7237C16.4219%2015.203%2015.5777%2015.203%2015.057%2015.7237L13.3332%2017.4475L10.5521%2014.6665L12.276%2012.9426Z'%20fill='%23FF7C00'/%3e%3c/svg%3e";
function create_else_block$7(ctx) {
  let button;
  let t;
  let button_class_value;
  let current2;
  let mounted;
  let dispose;
  let if_block = (
    /*icon*/
    ctx[7] && create_if_block_2$c(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, id: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t = claim_space(button_nodes);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", button_class_value = /*size*/
      ctx[4] + " " + /*variant*/
      ctx[3] + " " + /*elem_classes*/
      ctx[1].join(" ") + " svelte-1137axg");
      attr(
        button,
        "id",
        /*elem_id*/
        ctx[0]
      );
      button.disabled = /*disabled*/
      ctx[8];
      toggle_class(button, "hidden", !/*visible*/
      ctx[2]);
      set_style(
        button,
        "flex-grow",
        /*scale*/
        ctx[9]
      );
      set_style(
        button,
        "width",
        /*scale*/
        ctx[9] === 0 ? "fit-content" : null
      );
      set_style(button, "min-width", typeof /*min_width*/
      ctx[10] === "number" ? `calc(min(${/*min_width*/
      ctx[10]}px, 100%))` : null);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration(button, t);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$c(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*size, variant, elem_classes*/
      26 && button_class_value !== (button_class_value = /*size*/
      ctx2[4] + " " + /*variant*/
      ctx2[3] + " " + /*elem_classes*/
      ctx2[1].join(" ") + " svelte-1137axg")) {
        attr(button, "class", button_class_value);
      }
      if (!current2 || dirty & /*elem_id*/
      1) {
        attr(
          button,
          "id",
          /*elem_id*/
          ctx2[0]
        );
      }
      if (!current2 || dirty & /*disabled*/
      256) {
        button.disabled = /*disabled*/
        ctx2[8];
      }
      if (!current2 || dirty & /*size, variant, elem_classes, visible*/
      30) {
        toggle_class(button, "hidden", !/*visible*/
        ctx2[2]);
      }
      if (dirty & /*scale*/
      512) {
        set_style(
          button,
          "flex-grow",
          /*scale*/
          ctx2[9]
        );
      }
      if (dirty & /*scale*/
      512) {
        set_style(
          button,
          "width",
          /*scale*/
          ctx2[9] === 0 ? "fit-content" : null
        );
      }
      if (dirty & /*min_width*/
      1024) {
        set_style(button, "min-width", typeof /*min_width*/
        ctx2[10] === "number" ? `calc(min(${/*min_width*/
        ctx2[10]}px, 100%))` : null);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$k(ctx) {
  let a;
  let t;
  let a_class_value;
  let current2;
  let if_block = (
    /*icon*/
    ctx[7] && create_if_block_1$c(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  return {
    c() {
      a = element("a");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        rel: true,
        "aria-disabled": true,
        class: true,
        id: true
      });
      var a_nodes = children(a);
      if (if_block)
        if_block.l(a_nodes);
      t = claim_space(a_nodes);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        a,
        "href",
        /*link*/
        ctx[6]
      );
      attr(a, "rel", "noopener noreferrer");
      attr(
        a,
        "aria-disabled",
        /*disabled*/
        ctx[8]
      );
      attr(a, "class", a_class_value = /*size*/
      ctx[4] + " " + /*variant*/
      ctx[3] + " " + /*elem_classes*/
      ctx[1].join(" ") + " svelte-1137axg");
      attr(
        a,
        "id",
        /*elem_id*/
        ctx[0]
      );
      toggle_class(a, "hidden", !/*visible*/
      ctx[2]);
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx[8]
      );
      set_style(
        a,
        "flex-grow",
        /*scale*/
        ctx[9]
      );
      set_style(
        a,
        "pointer-events",
        /*disabled*/
        ctx[8] ? "none" : null
      );
      set_style(
        a,
        "width",
        /*scale*/
        ctx[9] === 0 ? "fit-content" : null
      );
      set_style(a, "min-width", typeof /*min_width*/
      ctx[10] === "number" ? `calc(min(${/*min_width*/
      ctx[10]}px, 100%))` : null);
    },
    m(target, anchor) {
      insert_hydration(target, a, anchor);
      if (if_block)
        if_block.m(a, null);
      append_hydration(a, t);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$c(ctx2);
          if_block.c();
          if_block.m(a, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*link*/
      64) {
        attr(
          a,
          "href",
          /*link*/
          ctx2[6]
        );
      }
      if (!current2 || dirty & /*disabled*/
      256) {
        attr(
          a,
          "aria-disabled",
          /*disabled*/
          ctx2[8]
        );
      }
      if (!current2 || dirty & /*size, variant, elem_classes*/
      26 && a_class_value !== (a_class_value = /*size*/
      ctx2[4] + " " + /*variant*/
      ctx2[3] + " " + /*elem_classes*/
      ctx2[1].join(" ") + " svelte-1137axg")) {
        attr(a, "class", a_class_value);
      }
      if (!current2 || dirty & /*elem_id*/
      1) {
        attr(
          a,
          "id",
          /*elem_id*/
          ctx2[0]
        );
      }
      if (!current2 || dirty & /*size, variant, elem_classes, visible*/
      30) {
        toggle_class(a, "hidden", !/*visible*/
        ctx2[2]);
      }
      if (!current2 || dirty & /*size, variant, elem_classes, disabled*/
      282) {
        toggle_class(
          a,
          "disabled",
          /*disabled*/
          ctx2[8]
        );
      }
      if (dirty & /*scale*/
      512) {
        set_style(
          a,
          "flex-grow",
          /*scale*/
          ctx2[9]
        );
      }
      if (dirty & /*disabled*/
      256) {
        set_style(
          a,
          "pointer-events",
          /*disabled*/
          ctx2[8] ? "none" : null
        );
      }
      if (dirty & /*scale*/
      512) {
        set_style(
          a,
          "width",
          /*scale*/
          ctx2[9] === 0 ? "fit-content" : null
        );
      }
      if (dirty & /*min_width*/
      1024) {
        set_style(a, "min-width", typeof /*min_width*/
        ctx2[10] === "number" ? `calc(min(${/*min_width*/
        ctx2[10]}px, 100%))` : null);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$c(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h() {
      attr(img, "class", "button-icon svelte-1137axg");
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[7].url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = `${/*value*/
      ctx[5]} icon`);
      toggle_class(
        img,
        "right-padded",
        /*value*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*icon*/
      128 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[7].url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*value*/
      32 && img_alt_value !== (img_alt_value = `${/*value*/
      ctx2[5]} icon`)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*value*/
      32) {
        toggle_class(
          img,
          "right-padded",
          /*value*/
          ctx2[5]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block_1$c(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h() {
      attr(img, "class", "button-icon svelte-1137axg");
      if (!src_url_equal(img.src, img_src_value = /*icon*/
      ctx[7].url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = `${/*value*/
      ctx[5]} icon`);
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*icon*/
      128 && !src_url_equal(img.src, img_src_value = /*icon*/
      ctx2[7].url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*value*/
      32 && img_alt_value !== (img_alt_value = `${/*value*/
      ctx2[5]} icon`)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block$k, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*link*/
      ctx2[6] && /*link*/
      ctx2[6].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { elem_id = "" } = $$props;
  let { elem_classes = [] } = $$props;
  let { visible = true } = $$props;
  let { variant = "secondary" } = $$props;
  let { size = "lg" } = $$props;
  let { value = null } = $$props;
  let { link: link2 = null } = $$props;
  let { icon = null } = $$props;
  let { disabled = false } = $$props;
  let { scale = null } = $$props;
  let { min_width = void 0 } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("elem_id" in $$props2)
      $$invalidate(0, elem_id = $$props2.elem_id);
    if ("elem_classes" in $$props2)
      $$invalidate(1, elem_classes = $$props2.elem_classes);
    if ("visible" in $$props2)
      $$invalidate(2, visible = $$props2.visible);
    if ("variant" in $$props2)
      $$invalidate(3, variant = $$props2.variant);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("value" in $$props2)
      $$invalidate(5, value = $$props2.value);
    if ("link" in $$props2)
      $$invalidate(6, link2 = $$props2.link);
    if ("icon" in $$props2)
      $$invalidate(7, icon = $$props2.icon);
    if ("disabled" in $$props2)
      $$invalidate(8, disabled = $$props2.disabled);
    if ("scale" in $$props2)
      $$invalidate(9, scale = $$props2.scale);
    if ("min_width" in $$props2)
      $$invalidate(10, min_width = $$props2.min_width);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  return [
    elem_id,
    elem_classes,
    visible,
    variant,
    size,
    value,
    link2,
    icon,
    disabled,
    scale,
    min_width,
    $$scope,
    slots,
    click_handler
  ];
}
class Button extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$s, create_fragment$A, safe_not_equal, {
      elem_id: 0,
      elem_classes: 1,
      visible: 2,
      variant: 3,
      size: 4,
      value: 5,
      link: 6,
      icon: 7,
      disabled: 8,
      scale: 9,
      min_width: 10
    });
  }
}
function create_default_slot$b(ctx) {
  let div;
  let t0;
  let p;
  let textContent = "API Recorder";
  return {
    c() {
      div = element("div");
      t0 = space();
      p = element("p");
      p.textContent = textContent;
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach);
      t0 = claim_space(nodes);
      p = claim_element(nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p) !== "svelte-1ywx371")
        p.textContent = textContent;
      this.h();
    },
    h() {
      attr(div, "class", "loading-dot self-baseline svelte-1i1gjw2");
      attr(p, "class", "self-baseline btn-text svelte-1i1gjw2");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p);
      }
    }
  };
}
function create_if_block$j(ctx) {
  let t;
  return {
    c() {
      t = text$3("s");
    },
    l(nodes) {
      t = claim_text(nodes, "s");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_fragment$z(ctx) {
  let h2;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let t3;
  let span1;
  let basebutton;
  let t4;
  let p;
  let span0;
  let t5;
  let t6;
  let br2;
  let t7;
  let button;
  let clear;
  let current2;
  let mounted;
  let dispose;
  basebutton = new Button({
    props: {
      size: "sm",
      variant: "secondary",
      elem_id: "start-api-recorder",
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  basebutton.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  let if_block = (
    /*api_count*/
    ctx[1] > 1 && create_if_block$j()
  );
  clear = new Clear$1({});
  return {
    c() {
      h2 = element("h2");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text$3("API documentation\n		");
      div0 = element("div");
      t2 = text$3(
        /*root*/
        ctx[0]
      );
      t3 = space();
      span1 = element("span");
      create_component(basebutton.$$.fragment);
      t4 = space();
      p = element("p");
      span0 = element("span");
      t5 = text$3(
        /*api_count*/
        ctx[1]
      );
      t6 = text$3(" API endpoint");
      if (if_block)
        if_block.c();
      br2 = element("br");
      t7 = space();
      button = element("button");
      create_component(clear.$$.fragment);
      this.h();
    },
    l(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      img = claim_element(h2_nodes, "IMG", { src: true, alt: true, class: true });
      t0 = claim_space(h2_nodes);
      div1 = claim_element(h2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, "API documentation\n		");
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t2 = claim_text(
        div0_nodes,
        /*root*/
        ctx[0]
      );
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t3 = claim_space(h2_nodes);
      span1 = claim_element(h2_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(basebutton.$$.fragment, span1_nodes);
      t4 = claim_space(span1_nodes);
      p = claim_element(span1_nodes, "P", {});
      var p_nodes = children(p);
      span0 = claim_element(p_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t5 = claim_text(
        span0_nodes,
        /*api_count*/
        ctx[1]
      );
      span0_nodes.forEach(detach);
      t6 = claim_text(p_nodes, " API endpoint");
      if (if_block)
        if_block.l(p_nodes);
      br2 = claim_element(p_nodes, "BR", {});
      p_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      h2_nodes.forEach(detach);
      t7 = claim_space(nodes);
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(clear.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = api_logo))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "class", "svelte-1i1gjw2");
      attr(div0, "class", "url svelte-1i1gjw2");
      attr(div1, "class", "title svelte-1i1gjw2");
      attr(span0, "class", "url svelte-1i1gjw2");
      attr(span1, "class", "counts svelte-1i1gjw2");
      attr(h2, "class", "svelte-1i1gjw2");
      attr(button, "class", "svelte-1i1gjw2");
    },
    m(target, anchor) {
      insert_hydration(target, h2, anchor);
      append_hydration(h2, img);
      append_hydration(h2, t0);
      append_hydration(h2, div1);
      append_hydration(div1, t1);
      append_hydration(div1, div0);
      append_hydration(div0, t2);
      append_hydration(h2, t3);
      append_hydration(h2, span1);
      mount_component(basebutton, span1, null);
      append_hydration(span1, t4);
      append_hydration(span1, p);
      append_hydration(p, span0);
      append_hydration(span0, t5);
      append_hydration(p, t6);
      if (if_block)
        if_block.m(p, null);
      append_hydration(p, br2);
      insert_hydration(target, t7, anchor);
      insert_hydration(target, button, anchor);
      mount_component(clear, button, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current2 || dirty & /*root*/
      1)
        set_data(
          t2,
          /*root*/
          ctx2[0]
        );
      const basebutton_changes = {};
      if (dirty & /*$$scope*/
      32) {
        basebutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      basebutton.$set(basebutton_changes);
      if (!current2 || dirty & /*api_count*/
      2)
        set_data(
          t5,
          /*api_count*/
          ctx2[1]
        );
      if (
        /*api_count*/
        ctx2[1] > 1
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$j();
          if_block.c();
          if_block.m(p, br2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(basebutton.$$.fragment, local);
      transition_in(clear.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(basebutton.$$.fragment, local);
      transition_out(clear.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t7);
        detach(button);
      }
      destroy_component(basebutton);
      if (if_block)
        if_block.d();
      destroy_component(clear);
      mounted = false;
      dispose();
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { root } = $$props;
  let { api_count } = $$props;
  const dispatch = createEventDispatcher();
  const click_handler = () => dispatch("close", { api_recorder_visible: true });
  const click_handler_1 = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("api_count" in $$props2)
      $$invalidate(1, api_count = $$props2.api_count);
  };
  return [root, api_count, dispatch, click_handler, click_handler_1];
}
class ApiBanner extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$r, create_fragment$z, safe_not_equal, { root: 0, api_count: 1 });
  }
}
function pretty_si(num) {
  let units = ["", "k", "M", "G", "T", "P", "E", "Z"];
  let i = 0;
  while (num > 1e3 && i < units.length - 1) {
    num /= 1e3;
    i++;
  }
  let unit = units[i];
  return (Number.isInteger(num) ? num : num.toFixed(1)) + unit;
}
function create_fragment$y(ctx) {
  let div;
  let svg2;
  let g0;
  let path0;
  let path1;
  let path2;
  let path3;
  let g1;
  let path4;
  let path5;
  let path6;
  let path7;
  return {
    c() {
      div = element("div");
      svg2 = svg_element("svg");
      g0 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      g1 = svg_element("g");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg2 = claim_svg_element(div_nodes, "svg", {
        viewBox: true,
        fill: true,
        xmlns: true,
        class: true
      });
      var svg_nodes = children(svg2);
      g0 = claim_svg_element(svg_nodes, "g", { style: true });
      var g0_nodes = children(g0);
      path0 = claim_svg_element(g0_nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        class: true
      });
      children(path0).forEach(detach);
      path1 = claim_svg_element(g0_nodes, "path", { d: true, fill: true, class: true });
      children(path1).forEach(detach);
      path2 = claim_svg_element(g0_nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        class: true
      });
      children(path2).forEach(detach);
      path3 = claim_svg_element(g0_nodes, "path", { d: true, fill: true, class: true });
      children(path3).forEach(detach);
      g0_nodes.forEach(detach);
      g1 = claim_svg_element(svg_nodes, "g", { style: true });
      var g1_nodes = children(g1);
      path4 = claim_svg_element(g1_nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        class: true
      });
      children(path4).forEach(detach);
      path5 = claim_svg_element(g1_nodes, "path", { d: true, fill: true, class: true });
      children(path5).forEach(detach);
      path6 = claim_svg_element(g1_nodes, "path", {
        d: true,
        fill: true,
        "fill-opacity": true,
        class: true
      });
      children(path6).forEach(detach);
      path7 = claim_svg_element(g1_nodes, "path", { d: true, fill: true, class: true });
      children(path7).forEach(detach);
      g1_nodes.forEach(detach);
      svg_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z");
      attr(path0, "fill", "#FF7C00");
      attr(path0, "fill-opacity", "0.4");
      attr(path0, "class", "svelte-zyxd38");
      attr(path1, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z");
      attr(path1, "fill", "#FF7C00");
      attr(path1, "class", "svelte-zyxd38");
      attr(path2, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z");
      attr(path2, "fill", "#FF7C00");
      attr(path2, "fill-opacity", "0.4");
      attr(path2, "class", "svelte-zyxd38");
      attr(path3, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z");
      attr(path3, "fill", "#FF7C00");
      attr(path3, "class", "svelte-zyxd38");
      set_style(g0, "transform", "translate(" + /*$top*/
      ctx[1][0] + "px, " + /*$top*/
      ctx[1][1] + "px)");
      attr(path4, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z");
      attr(path4, "fill", "#FF7C00");
      attr(path4, "fill-opacity", "0.4");
      attr(path4, "class", "svelte-zyxd38");
      attr(path5, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z");
      attr(path5, "fill", "#FF7C00");
      attr(path5, "class", "svelte-zyxd38");
      attr(path6, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z");
      attr(path6, "fill", "#FF7C00");
      attr(path6, "fill-opacity", "0.4");
      attr(path6, "class", "svelte-zyxd38");
      attr(path7, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z");
      attr(path7, "fill", "#FF7C00");
      attr(path7, "class", "svelte-zyxd38");
      set_style(g1, "transform", "translate(" + /*$bottom*/
      ctx[2][0] + "px, " + /*$bottom*/
      ctx[2][1] + "px)");
      attr(svg2, "viewBox", "-1200 -1200 3000 3000");
      attr(svg2, "fill", "none");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "class", "svelte-zyxd38");
      attr(div, "class", "svelte-zyxd38");
      toggle_class(
        div,
        "margin",
        /*margin*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, svg2);
      append_hydration(svg2, g0);
      append_hydration(g0, path0);
      append_hydration(g0, path1);
      append_hydration(g0, path2);
      append_hydration(g0, path3);
      append_hydration(svg2, g1);
      append_hydration(g1, path4);
      append_hydration(g1, path5);
      append_hydration(g1, path6);
      append_hydration(g1, path7);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$top*/
      2) {
        set_style(g0, "transform", "translate(" + /*$top*/
        ctx2[1][0] + "px, " + /*$top*/
        ctx2[1][1] + "px)");
      }
      if (dirty & /*$bottom*/
      4) {
        set_style(g1, "transform", "translate(" + /*$bottom*/
        ctx2[2][0] + "px, " + /*$bottom*/
        ctx2[2][1] + "px)");
      }
      if (dirty & /*margin*/
      1) {
        toggle_class(
          div,
          "margin",
          /*margin*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $top;
  let $bottom;
  let { margin = true } = $$props;
  const top = spring([0, 0]);
  component_subscribe($$self, top, (value) => $$invalidate(1, $top = value));
  const bottom = spring([0, 0]);
  component_subscribe($$self, bottom, (value) => $$invalidate(2, $bottom = value));
  let dismounted;
  async function animate() {
    await Promise.all([top.set([125, 140]), bottom.set([-125, -140])]);
    await Promise.all([top.set([-125, 140]), bottom.set([125, -140])]);
    await Promise.all([top.set([-125, 0]), bottom.set([125, -0])]);
    await Promise.all([top.set([125, 0]), bottom.set([-125, 0])]);
  }
  async function run() {
    await animate();
    if (!dismounted)
      run();
  }
  async function loading() {
    await Promise.all([top.set([125, 0]), bottom.set([-125, 0])]);
    run();
  }
  onMount(() => {
    loading();
    return () => dismounted = true;
  });
  $$self.$$set = ($$props2) => {
    if ("margin" in $$props2)
      $$invalidate(0, margin = $$props2.margin);
  };
  return [margin, $top, $bottom, top, bottom];
}
class Loader extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$q, create_fragment$y, safe_not_equal, { margin: 0 });
  }
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let svelte_element_levels = [
    { "data-testid": (
      /*test_id*/
      ctx[10]
    ) },
    { id: (
      /*elem_id*/
      ctx[5]
    ) },
    {
      class: svelte_element_class_value = "block " + /*elem_classes*/
      ctx[6].join(" ") + " svelte-hjh1qu"
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*tag*/
        ctx[18]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[18] || "null").toUpperCase(),
        {
          "data-testid": true,
          id: true,
          class: true
        }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_dynamic_element_data(
        /*tag*/
        ctx[18]
      )(svelte_element, svelte_element_data);
      toggle_class(
        svelte_element,
        "hidden",
        /*visible*/
        ctx[13] === false
      );
      toggle_class(
        svelte_element,
        "padded",
        /*padding*/
        ctx[9]
      );
      toggle_class(
        svelte_element,
        "flex",
        /*flex*/
        ctx[0]
      );
      toggle_class(
        svelte_element,
        "border_focus",
        /*border_mode*/
        ctx[8] === "focus"
      );
      toggle_class(
        svelte_element,
        "border_contrast",
        /*border_mode*/
        ctx[8] === "contrast"
      );
      toggle_class(svelte_element, "hide-container", !/*explicit_call*/
      ctx[11] && !/*container*/
      ctx[12]);
      toggle_class(
        svelte_element,
        "auto-margin",
        /*scale*/
        ctx[16] === null
      );
      set_style(
        svelte_element,
        "height",
        /*get_dimension*/
        ctx[19](
          /*height*/
          ctx[1]
        )
      );
      set_style(
        svelte_element,
        "min-height",
        /*get_dimension*/
        ctx[19](
          /*min_height*/
          ctx[2]
        )
      );
      set_style(
        svelte_element,
        "max-height",
        /*get_dimension*/
        ctx[19](
          /*max_height*/
          ctx[3]
        )
      );
      set_style(svelte_element, "width", typeof /*width*/
      ctx[4] === "number" ? `calc(min(${/*width*/
      ctx[4]}px, 100%))` : (
        /*get_dimension*/
        ctx[19](
          /*width*/
          ctx[4]
        )
      ));
      set_style(
        svelte_element,
        "border-style",
        /*variant*/
        ctx[7]
      );
      set_style(
        svelte_element,
        "overflow",
        /*allow_overflow*/
        ctx[14] ? (
          /*overflow_behavior*/
          ctx[15]
        ) : "hidden"
      );
      set_style(
        svelte_element,
        "flex-grow",
        /*scale*/
        ctx[16]
      );
      set_style(svelte_element, "min-width", `calc(min(${/*min_width*/
      ctx[17]}px, 100%))`);
      set_style(svelte_element, "border-width", `var(--block-border-width)`);
    },
    m(target, anchor) {
      insert_hydration(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[18]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current2 || dirty & /*test_id*/
        1024) && { "data-testid": (
          /*test_id*/
          ctx2[10]
        ) },
        (!current2 || dirty & /*elem_id*/
        32) && { id: (
          /*elem_id*/
          ctx2[5]
        ) },
        (!current2 || dirty & /*elem_classes*/
        64 && svelte_element_class_value !== (svelte_element_class_value = "block " + /*elem_classes*/
        ctx2[6].join(" ") + " svelte-hjh1qu")) && { class: svelte_element_class_value }
      ]));
      toggle_class(
        svelte_element,
        "hidden",
        /*visible*/
        ctx2[13] === false
      );
      toggle_class(
        svelte_element,
        "padded",
        /*padding*/
        ctx2[9]
      );
      toggle_class(
        svelte_element,
        "flex",
        /*flex*/
        ctx2[0]
      );
      toggle_class(
        svelte_element,
        "border_focus",
        /*border_mode*/
        ctx2[8] === "focus"
      );
      toggle_class(
        svelte_element,
        "border_contrast",
        /*border_mode*/
        ctx2[8] === "contrast"
      );
      toggle_class(svelte_element, "hide-container", !/*explicit_call*/
      ctx2[11] && !/*container*/
      ctx2[12]);
      toggle_class(
        svelte_element,
        "auto-margin",
        /*scale*/
        ctx2[16] === null
      );
      if (dirty & /*height*/
      2) {
        set_style(
          svelte_element,
          "height",
          /*get_dimension*/
          ctx2[19](
            /*height*/
            ctx2[1]
          )
        );
      }
      if (dirty & /*min_height*/
      4) {
        set_style(
          svelte_element,
          "min-height",
          /*get_dimension*/
          ctx2[19](
            /*min_height*/
            ctx2[2]
          )
        );
      }
      if (dirty & /*max_height*/
      8) {
        set_style(
          svelte_element,
          "max-height",
          /*get_dimension*/
          ctx2[19](
            /*max_height*/
            ctx2[3]
          )
        );
      }
      if (dirty & /*width*/
      16) {
        set_style(svelte_element, "width", typeof /*width*/
        ctx2[4] === "number" ? `calc(min(${/*width*/
        ctx2[4]}px, 100%))` : (
          /*get_dimension*/
          ctx2[19](
            /*width*/
            ctx2[4]
          )
        ));
      }
      if (dirty & /*variant*/
      128) {
        set_style(
          svelte_element,
          "border-style",
          /*variant*/
          ctx2[7]
        );
      }
      if (dirty & /*allow_overflow, overflow_behavior*/
      49152) {
        set_style(
          svelte_element,
          "overflow",
          /*allow_overflow*/
          ctx2[14] ? (
            /*overflow_behavior*/
            ctx2[15]
          ) : "hidden"
        );
      }
      if (dirty & /*scale*/
      65536) {
        set_style(
          svelte_element,
          "flex-grow",
          /*scale*/
          ctx2[16]
        );
      }
      if (dirty & /*min_width*/
      131072) {
        set_style(svelte_element, "min-width", `calc(min(${/*min_width*/
        ctx2[17]}px, 100%))`);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$x(ctx) {
  let current2;
  let svelte_element = (
    /*tag*/
    ctx[18] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
    },
    l(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[18]
      ) {
        svelte_element.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(svelte_element, local);
      current2 = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current2 = false;
    },
    d(detaching) {
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { height = void 0 } = $$props;
  let { min_height = void 0 } = $$props;
  let { max_height = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { elem_id = "" } = $$props;
  let { elem_classes = [] } = $$props;
  let { variant = "solid" } = $$props;
  let { border_mode = "base" } = $$props;
  let { padding = true } = $$props;
  let { type = "normal" } = $$props;
  let { test_id = void 0 } = $$props;
  let { explicit_call = false } = $$props;
  let { container = true } = $$props;
  let { visible = true } = $$props;
  let { allow_overflow = true } = $$props;
  let { overflow_behavior = "auto" } = $$props;
  let { scale = null } = $$props;
  let { min_width = 0 } = $$props;
  let { flex = false } = $$props;
  if (!visible)
    flex = false;
  let tag2 = type === "fieldset" ? "fieldset" : "div";
  const get_dimension = (dimension_value) => {
    if (dimension_value === void 0) {
      return void 0;
    }
    if (typeof dimension_value === "number") {
      return dimension_value + "px";
    } else if (typeof dimension_value === "string") {
      return dimension_value;
    }
  };
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("min_height" in $$props2)
      $$invalidate(2, min_height = $$props2.min_height);
    if ("max_height" in $$props2)
      $$invalidate(3, max_height = $$props2.max_height);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("elem_id" in $$props2)
      $$invalidate(5, elem_id = $$props2.elem_id);
    if ("elem_classes" in $$props2)
      $$invalidate(6, elem_classes = $$props2.elem_classes);
    if ("variant" in $$props2)
      $$invalidate(7, variant = $$props2.variant);
    if ("border_mode" in $$props2)
      $$invalidate(8, border_mode = $$props2.border_mode);
    if ("padding" in $$props2)
      $$invalidate(9, padding = $$props2.padding);
    if ("type" in $$props2)
      $$invalidate(20, type = $$props2.type);
    if ("test_id" in $$props2)
      $$invalidate(10, test_id = $$props2.test_id);
    if ("explicit_call" in $$props2)
      $$invalidate(11, explicit_call = $$props2.explicit_call);
    if ("container" in $$props2)
      $$invalidate(12, container = $$props2.container);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("allow_overflow" in $$props2)
      $$invalidate(14, allow_overflow = $$props2.allow_overflow);
    if ("overflow_behavior" in $$props2)
      $$invalidate(15, overflow_behavior = $$props2.overflow_behavior);
    if ("scale" in $$props2)
      $$invalidate(16, scale = $$props2.scale);
    if ("min_width" in $$props2)
      $$invalidate(17, min_width = $$props2.min_width);
    if ("flex" in $$props2)
      $$invalidate(0, flex = $$props2.flex);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  return [
    flex,
    height,
    min_height,
    max_height,
    width,
    elem_id,
    elem_classes,
    variant,
    border_mode,
    padding,
    test_id,
    explicit_call,
    container,
    visible,
    allow_overflow,
    overflow_behavior,
    scale,
    min_width,
    tag2,
    get_dimension,
    type,
    $$scope,
    slots
  ];
}
class Block extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$p, create_fragment$x, safe_not_equal, {
      height: 1,
      min_height: 2,
      max_height: 3,
      width: 4,
      elem_id: 5,
      elem_classes: 6,
      variant: 7,
      border_mode: 8,
      padding: 9,
      type: 20,
      test_id: 10,
      explicit_call: 11,
      container: 12,
      visible: 13,
      allow_overflow: 14,
      overflow_behavior: 15,
      scale: 16,
      min_width: 17,
      flex: 0
    });
  }
}
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(text2, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text2;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text2) {
    return new Token(text2, SourceLocation.range(this, endToken));
  }
}
class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error = "KaTeX parse error: " + message;
    var start;
    var end;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start = loc.start;
      end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": ";
      }
      var underlined = input.slice(start, end).replace(/[^]/g, "$&");
      var left;
      if (start > 15) {
        left = "" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }
    var self2 = new Error(error);
    self2.name = "ParseError";
    self2.__proto__ = ParseError.prototype;
    self2.position = start;
    if (start != null && end != null) {
      self2.length = end - start;
    }
    self2.rawMessage = message;
    return self2;
  }
}
ParseError.prototype.__proto__ = Error.prototype;
var contains = function contains2(list2, elem) {
  return list2.indexOf(elem) !== -1;
};
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape$3(text2) {
  return String(text2).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};
var protocolFromUrl = function protocolFromUrl2(url) {
  var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  if (protocol[2] !== ":") {
    return null;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  return protocol[1].toLowerCase();
};
var utils = {
  contains,
  deflt,
  escape: escape$3,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color) => "#" + color
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def2, defs) => {
      defs.push(def2);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s) => Math.max(0, s),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Settings {
  constructor(options2) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options2 = options2 || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options2[prop] !== void 0 ? schema.processor ? schema.processor(options2[prop]) : options2[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      var protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false;
      }
      context.protocol = protocol;
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}
class Style {
  constructor(id2, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id2;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i = 0; i < scriptData.length; i++) {
    var script = scriptData[i];
    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block2 = script.blocks[_i];
      if (codepoint >= block2[0] && codepoint <= block2[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
function supportedCodepoint(codepoint) {
  for (var i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y) {
  var x = y / 2;
  return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path2 = "";
  switch (size) {
    case "sqrtMain":
      path2 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height) {
  switch (name) {
    case "":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label2, midHeight) {
  switch (label2) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children2) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children2;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.less; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "": "A",
  "": "D",
  "": "o",
  "": "a",
  "": "d",
  "": "o",
  // Cyrillic
  "": "A",
  "": "B",
  "": "B",
  "": "F",
  "": "A",
  "": "E",
  "": "K",
  "": "3",
  "": "N",
  "": "N",
  "": "K",
  "": "N",
  "": "M",
  "": "H",
  "": "O",
  "": "N",
  "": "P",
  "": "C",
  "": "T",
  "": "y",
  "": "O",
  "": "X",
  "": "U",
  "": "h",
  "": "W",
  "": "W",
  "": "B",
  "": "X",
  "": "B",
  "": "3",
  "": "X",
  "": "R",
  "": "a",
  "": "b",
  "": "a",
  "": "r",
  "": "y",
  "": "e",
  "": "m",
  "": "e",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "m",
  "": "n",
  "": "o",
  "": "n",
  "": "p",
  "": "c",
  "": "o",
  "": "y",
  "": "b",
  "": "x",
  "": "n",
  "": "n",
  "": "w",
  "": "w",
  "": "a",
  "": "m",
  "": "a",
  "": "e",
  "": "m",
  "": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size) {
  var sizeIndex;
  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
};
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }
    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);
    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size;
    switch (this.style.id) {
      case 4:
      case 5:
        size = 3;
        break;
      case 6:
      case 7:
        size = 1;
        break;
      default:
        size = 6;
    }
    return this.extend({
      style: this.style.text(),
      size
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color) {
    return this.extend({
      color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
}
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options2) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options2.fontMetrics().ptPerEm / options2.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options2.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options2.style.isTight()) {
      unitOptions = options2.havingStyle(options2.style.text());
    } else {
      unitOptions = options2;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options2) {
      scale *= unitOptions.sizeMultiplier / options2.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options2.maxSize);
};
var makeEm = function makeEm2(n) {
  return +n.toFixed(4) + "em";
};
var createClass = function createClass2(classes) {
  return classes.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes, options2, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};
  if (options2) {
    if (options2.style.isTight()) {
      this.classes.push("mtight");
    }
    var color = options2.getColor();
    if (color) {
      this.style.color = color;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node = document.createElement(tagName);
  node.className = createClass(this.classes);
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      node.style[style] = this.style[style];
    }
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      node.setAttribute(attr2, this.attributes[attr2]);
    }
  }
  for (var i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }
  return node;
};
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils.escape(styles2) + '"';
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
    }
  }
  markup += ">";
  for (var i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
class Span {
  constructor(classes, children2, options2, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options2, style);
    this.children = children2 || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
class Anchor {
  constructor(href, classes, children2, options2) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options2);
    this.children = children2 || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
}
class Img {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node.style[style] = this.style[style];
      }
    }
    return node;
  }
  toMarkup() {
    var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
}
var iCombinations = {
  "": "",
  "": "",
  "": "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  "": ""
};
class SymbolNode {
  constructor(text2, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text2;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span");
        span.style[style] = this.style[style];
      }
    }
    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    var escaped = utils.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
}
class SvgNode {
  constructor(children2, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children2 || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
      }
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }
    return node;
  }
  toMarkup() {
    if (this.alternate) {
      return '<path d="' + utils.escape(this.alternate) + '"/>';
    } else {
      return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
    }
  }
}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    return node;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
      }
    }
    markup += "/>";
    return markup;
  }
}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };
  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}
var math = "math";
var text$2 = "text";
var main$1 = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main$1, rel, "", "\\equiv", true);
defineSymbol(math, main$1, rel, "", "\\prec", true);
defineSymbol(math, main$1, rel, "", "\\succ", true);
defineSymbol(math, main$1, rel, "", "\\sim", true);
defineSymbol(math, main$1, rel, "", "\\perp");
defineSymbol(math, main$1, rel, "", "\\preceq", true);
defineSymbol(math, main$1, rel, "", "\\succeq", true);
defineSymbol(math, main$1, rel, "", "\\simeq", true);
defineSymbol(math, main$1, rel, "", "\\mid", true);
defineSymbol(math, main$1, rel, "", "\\ll", true);
defineSymbol(math, main$1, rel, "", "\\gg", true);
defineSymbol(math, main$1, rel, "", "\\asymp", true);
defineSymbol(math, main$1, rel, "", "\\parallel");
defineSymbol(math, main$1, rel, "", "\\bowtie", true);
defineSymbol(math, main$1, rel, "", "\\smile", true);
defineSymbol(math, main$1, rel, "", "\\sqsubseteq", true);
defineSymbol(math, main$1, rel, "", "\\sqsupseteq", true);
defineSymbol(math, main$1, rel, "", "\\doteq", true);
defineSymbol(math, main$1, rel, "", "\\frown", true);
defineSymbol(math, main$1, rel, "", "\\ni", true);
defineSymbol(math, main$1, rel, "", "\\propto", true);
defineSymbol(math, main$1, rel, "", "\\vdash", true);
defineSymbol(math, main$1, rel, "", "\\dashv", true);
defineSymbol(math, main$1, rel, "", "\\owns");
defineSymbol(math, main$1, punct, ".", "\\ldotp");
defineSymbol(math, main$1, punct, "", "\\cdotp");
defineSymbol(math, main$1, textord, "#", "\\#");
defineSymbol(text$2, main$1, textord, "#", "\\#");
defineSymbol(math, main$1, textord, "&", "\\&");
defineSymbol(text$2, main$1, textord, "&", "\\&");
defineSymbol(math, main$1, textord, "", "\\aleph", true);
defineSymbol(math, main$1, textord, "", "\\forall", true);
defineSymbol(math, main$1, textord, "", "\\hbar", true);
defineSymbol(math, main$1, textord, "", "\\exists", true);
defineSymbol(math, main$1, textord, "", "\\nabla", true);
defineSymbol(math, main$1, textord, "", "\\flat", true);
defineSymbol(math, main$1, textord, "", "\\ell", true);
defineSymbol(math, main$1, textord, "", "\\natural", true);
defineSymbol(math, main$1, textord, "", "\\clubsuit", true);
defineSymbol(math, main$1, textord, "", "\\wp", true);
defineSymbol(math, main$1, textord, "", "\\sharp", true);
defineSymbol(math, main$1, textord, "", "\\diamondsuit", true);
defineSymbol(math, main$1, textord, "", "\\Re", true);
defineSymbol(math, main$1, textord, "", "\\heartsuit", true);
defineSymbol(math, main$1, textord, "", "\\Im", true);
defineSymbol(math, main$1, textord, "", "\\spadesuit", true);
defineSymbol(math, main$1, textord, "", "\\S", true);
defineSymbol(text$2, main$1, textord, "", "\\S");
defineSymbol(math, main$1, textord, "", "\\P", true);
defineSymbol(text$2, main$1, textord, "", "\\P");
defineSymbol(math, main$1, textord, "", "\\dag");
defineSymbol(text$2, main$1, textord, "", "\\dag");
defineSymbol(text$2, main$1, textord, "", "\\textdagger");
defineSymbol(math, main$1, textord, "", "\\ddag");
defineSymbol(text$2, main$1, textord, "", "\\ddag");
defineSymbol(text$2, main$1, textord, "", "\\textdaggerdbl");
defineSymbol(math, main$1, close, "", "\\rmoustache", true);
defineSymbol(math, main$1, open, "", "\\lmoustache", true);
defineSymbol(math, main$1, close, "", "\\rgroup", true);
defineSymbol(math, main$1, open, "", "\\lgroup", true);
defineSymbol(math, main$1, bin, "", "\\mp", true);
defineSymbol(math, main$1, bin, "", "\\ominus", true);
defineSymbol(math, main$1, bin, "", "\\uplus", true);
defineSymbol(math, main$1, bin, "", "\\sqcap", true);
defineSymbol(math, main$1, bin, "", "\\ast");
defineSymbol(math, main$1, bin, "", "\\sqcup", true);
defineSymbol(math, main$1, bin, "", "\\bigcirc", true);
defineSymbol(math, main$1, bin, "", "\\bullet", true);
defineSymbol(math, main$1, bin, "", "\\ddagger");
defineSymbol(math, main$1, bin, "", "\\wr", true);
defineSymbol(math, main$1, bin, "", "\\amalg");
defineSymbol(math, main$1, bin, "&", "\\And");
defineSymbol(math, main$1, rel, "", "\\longleftarrow", true);
defineSymbol(math, main$1, rel, "", "\\Leftarrow", true);
defineSymbol(math, main$1, rel, "", "\\Longleftarrow", true);
defineSymbol(math, main$1, rel, "", "\\longrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\Rightarrow", true);
defineSymbol(math, main$1, rel, "", "\\Longrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\leftrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\longleftrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\Leftrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\Longleftrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\mapsto", true);
defineSymbol(math, main$1, rel, "", "\\longmapsto", true);
defineSymbol(math, main$1, rel, "", "\\nearrow", true);
defineSymbol(math, main$1, rel, "", "\\hookleftarrow", true);
defineSymbol(math, main$1, rel, "", "\\hookrightarrow", true);
defineSymbol(math, main$1, rel, "", "\\searrow", true);
defineSymbol(math, main$1, rel, "", "\\leftharpoonup", true);
defineSymbol(math, main$1, rel, "", "\\rightharpoonup", true);
defineSymbol(math, main$1, rel, "", "\\swarrow", true);
defineSymbol(math, main$1, rel, "", "\\leftharpoondown", true);
defineSymbol(math, main$1, rel, "", "\\rightharpoondown", true);
defineSymbol(math, main$1, rel, "", "\\nwarrow", true);
defineSymbol(math, main$1, rel, "", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "", "\\nless", true);
defineSymbol(math, ams, rel, "", "\\@nleqslant");
defineSymbol(math, ams, rel, "", "\\@nleqq");
defineSymbol(math, ams, rel, "", "\\lneq", true);
defineSymbol(math, ams, rel, "", "\\lneqq", true);
defineSymbol(math, ams, rel, "", "\\@lvertneqq");
defineSymbol(math, ams, rel, "", "\\lnsim", true);
defineSymbol(math, ams, rel, "", "\\lnapprox", true);
defineSymbol(math, ams, rel, "", "\\nprec", true);
defineSymbol(math, ams, rel, "", "\\npreceq", true);
defineSymbol(math, ams, rel, "", "\\precnsim", true);
defineSymbol(math, ams, rel, "", "\\precnapprox", true);
defineSymbol(math, ams, rel, "", "\\nsim", true);
defineSymbol(math, ams, rel, "", "\\@nshortmid");
defineSymbol(math, ams, rel, "", "\\nmid", true);
defineSymbol(math, ams, rel, "", "\\nvdash", true);
defineSymbol(math, ams, rel, "", "\\nvDash", true);
defineSymbol(math, ams, rel, "", "\\ntriangleleft");
defineSymbol(math, ams, rel, "", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "", "\\subsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "", "\\ngtr", true);
defineSymbol(math, ams, rel, "", "\\@ngeqslant");
defineSymbol(math, ams, rel, "", "\\@ngeqq");
defineSymbol(math, ams, rel, "", "\\gneq", true);
defineSymbol(math, ams, rel, "", "\\gneqq", true);
defineSymbol(math, ams, rel, "", "\\@gvertneqq");
defineSymbol(math, ams, rel, "", "\\gnsim", true);
defineSymbol(math, ams, rel, "", "\\gnapprox", true);
defineSymbol(math, ams, rel, "", "\\nsucc", true);
defineSymbol(math, ams, rel, "", "\\nsucceq", true);
defineSymbol(math, ams, rel, "", "\\succnsim", true);
defineSymbol(math, ams, rel, "", "\\succnapprox", true);
defineSymbol(math, ams, rel, "", "\\ncong", true);
defineSymbol(math, ams, rel, "", "\\@nshortparallel");
defineSymbol(math, ams, rel, "", "\\nparallel", true);
defineSymbol(math, ams, rel, "", "\\nVDash", true);
defineSymbol(math, ams, rel, "", "\\ntriangleright");
defineSymbol(math, ams, rel, "", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "", "\\supsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "", "\\nVdash", true);
defineSymbol(math, ams, rel, "", "\\precneqq", true);
defineSymbol(math, ams, rel, "", "\\succneqq", true);
defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "", "\\unlhd");
defineSymbol(math, ams, bin, "", "\\unrhd");
defineSymbol(math, ams, rel, "", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "", "\\vartriangle");
defineSymbol(math, ams, textord, "", "\\hslash");
defineSymbol(math, ams, textord, "", "\\triangledown");
defineSymbol(math, ams, textord, "", "\\lozenge");
defineSymbol(math, ams, textord, "", "\\circledS");
defineSymbol(math, ams, textord, "", "\\circledR");
defineSymbol(text$2, ams, textord, "", "\\circledR");
defineSymbol(math, ams, textord, "", "\\measuredangle", true);
defineSymbol(math, ams, textord, "", "\\nexists");
defineSymbol(math, ams, textord, "", "\\mho");
defineSymbol(math, ams, textord, "", "\\Finv", true);
defineSymbol(math, ams, textord, "", "\\Game", true);
defineSymbol(math, ams, textord, "", "\\backprime");
defineSymbol(math, ams, textord, "", "\\blacktriangle");
defineSymbol(math, ams, textord, "", "\\blacktriangledown");
defineSymbol(math, ams, textord, "", "\\blacksquare");
defineSymbol(math, ams, textord, "", "\\blacklozenge");
defineSymbol(math, ams, textord, "", "\\bigstar");
defineSymbol(math, ams, textord, "", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "", "\\complement", true);
defineSymbol(math, ams, textord, "", "\\eth", true);
defineSymbol(text$2, main$1, textord, "", "");
defineSymbol(math, ams, textord, "", "\\diagup");
defineSymbol(math, ams, textord, "", "\\diagdown");
defineSymbol(math, ams, textord, "", "\\square");
defineSymbol(math, ams, textord, "", "\\Box");
defineSymbol(math, ams, textord, "", "\\Diamond");
defineSymbol(math, ams, textord, "", "\\yen", true);
defineSymbol(text$2, ams, textord, "", "\\yen", true);
defineSymbol(math, ams, textord, "", "\\checkmark", true);
defineSymbol(text$2, ams, textord, "", "\\checkmark");
defineSymbol(math, ams, textord, "", "\\beth", true);
defineSymbol(math, ams, textord, "", "\\daleth", true);
defineSymbol(math, ams, textord, "", "\\gimel", true);
defineSymbol(math, ams, textord, "", "\\digamma", true);
defineSymbol(math, ams, textord, "", "\\varkappa");
defineSymbol(math, ams, open, "", "\\@ulcorner", true);
defineSymbol(math, ams, close, "", "\\@urcorner", true);
defineSymbol(math, ams, open, "", "\\@llcorner", true);
defineSymbol(math, ams, close, "", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "", "\\leqq", true);
defineSymbol(math, ams, rel, "", "\\leqslant", true);
defineSymbol(math, ams, rel, "", "\\eqslantless", true);
defineSymbol(math, ams, rel, "", "\\lesssim", true);
defineSymbol(math, ams, rel, "", "\\lessapprox", true);
defineSymbol(math, ams, rel, "", "\\approxeq", true);
defineSymbol(math, ams, bin, "", "\\lessdot");
defineSymbol(math, ams, rel, "", "\\lll", true);
defineSymbol(math, ams, rel, "", "\\lessgtr", true);
defineSymbol(math, ams, rel, "", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "", "\\doteqdot");
defineSymbol(math, ams, rel, "", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "", "\\backsim", true);
defineSymbol(math, ams, rel, "", "\\backsimeq", true);
defineSymbol(math, ams, rel, "", "\\subseteqq", true);
defineSymbol(math, ams, rel, "", "\\Subset", true);
defineSymbol(math, ams, rel, "", "\\sqsubset", true);
defineSymbol(math, ams, rel, "", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "", "\\precsim", true);
defineSymbol(math, ams, rel, "", "\\precapprox", true);
defineSymbol(math, ams, rel, "", "\\vartriangleleft");
defineSymbol(math, ams, rel, "", "\\trianglelefteq");
defineSymbol(math, ams, rel, "", "\\vDash", true);
defineSymbol(math, ams, rel, "", "\\Vvdash", true);
defineSymbol(math, ams, rel, "", "\\smallsmile");
defineSymbol(math, ams, rel, "", "\\smallfrown");
defineSymbol(math, ams, rel, "", "\\bumpeq", true);
defineSymbol(math, ams, rel, "", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "", "\\geqq", true);
defineSymbol(math, ams, rel, "", "\\geqslant", true);
defineSymbol(math, ams, rel, "", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "", "\\gtrsim", true);
defineSymbol(math, ams, rel, "", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "", "\\gtrdot");
defineSymbol(math, ams, rel, "", "\\ggg", true);
defineSymbol(math, ams, rel, "", "\\gtrless", true);
defineSymbol(math, ams, rel, "", "\\gtreqless", true);
defineSymbol(math, ams, rel, "", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "", "\\eqcirc", true);
defineSymbol(math, ams, rel, "", "\\circeq", true);
defineSymbol(math, ams, rel, "", "\\triangleq", true);
defineSymbol(math, ams, rel, "", "\\thicksim");
defineSymbol(math, ams, rel, "", "\\thickapprox");
defineSymbol(math, ams, rel, "", "\\supseteqq", true);
defineSymbol(math, ams, rel, "", "\\Supset", true);
defineSymbol(math, ams, rel, "", "\\sqsupset", true);
defineSymbol(math, ams, rel, "", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "", "\\succsim", true);
defineSymbol(math, ams, rel, "", "\\succapprox", true);
defineSymbol(math, ams, rel, "", "\\vartriangleright");
defineSymbol(math, ams, rel, "", "\\trianglerighteq");
defineSymbol(math, ams, rel, "", "\\Vdash", true);
defineSymbol(math, ams, rel, "", "\\shortmid");
defineSymbol(math, ams, rel, "", "\\shortparallel");
defineSymbol(math, ams, rel, "", "\\between", true);
defineSymbol(math, ams, rel, "", "\\pitchfork", true);
defineSymbol(math, ams, rel, "", "\\varpropto");
defineSymbol(math, ams, rel, "", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "", "\\therefore", true);
defineSymbol(math, ams, rel, "", "\\backepsilon");
defineSymbol(math, ams, rel, "", "\\blacktriangleright");
defineSymbol(math, ams, rel, "", "\\because", true);
defineSymbol(math, ams, rel, "", "\\llless");
defineSymbol(math, ams, rel, "", "\\gggtr");
defineSymbol(math, ams, bin, "", "\\lhd");
defineSymbol(math, ams, bin, "", "\\rhd");
defineSymbol(math, ams, rel, "", "\\eqsim", true);
defineSymbol(math, main$1, rel, "", "\\Join");
defineSymbol(math, ams, rel, "", "\\Doteq", true);
defineSymbol(math, ams, bin, "", "\\dotplus", true);
defineSymbol(math, ams, bin, "", "\\smallsetminus");
defineSymbol(math, ams, bin, "", "\\Cap", true);
defineSymbol(math, ams, bin, "", "\\Cup", true);
defineSymbol(math, ams, bin, "", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "", "\\boxminus", true);
defineSymbol(math, ams, bin, "", "\\boxplus", true);
defineSymbol(math, ams, bin, "", "\\divideontimes", true);
defineSymbol(math, ams, bin, "", "\\ltimes", true);
defineSymbol(math, ams, bin, "", "\\rtimes", true);
defineSymbol(math, ams, bin, "", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "", "\\curlywedge", true);
defineSymbol(math, ams, bin, "", "\\curlyvee", true);
defineSymbol(math, ams, bin, "", "\\circleddash", true);
defineSymbol(math, ams, bin, "", "\\circledast", true);
defineSymbol(math, ams, bin, "", "\\centerdot");
defineSymbol(math, ams, bin, "", "\\intercal", true);
defineSymbol(math, ams, bin, "", "\\doublecap");
defineSymbol(math, ams, bin, "", "\\doublecup");
defineSymbol(math, ams, bin, "", "\\boxtimes", true);
defineSymbol(math, ams, rel, "", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "", "\\Lsh", true);
defineSymbol(math, ams, rel, "", "\\upuparrows", true);
defineSymbol(math, ams, rel, "", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "", "\\downharpoonleft", true);
defineSymbol(math, main$1, rel, "", "\\origof", true);
defineSymbol(math, main$1, rel, "", "\\imageof", true);
defineSymbol(math, ams, rel, "", "\\multimap", true);
defineSymbol(math, ams, rel, "", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "", "\\looparrowright", true);
defineSymbol(math, ams, rel, "", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "", "\\Rsh", true);
defineSymbol(math, ams, rel, "", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "", "\\leadsto");
defineSymbol(math, ams, rel, "", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "", "\\restriction");
defineSymbol(math, main$1, textord, "", "`");
defineSymbol(math, main$1, textord, "$", "\\$");
defineSymbol(text$2, main$1, textord, "$", "\\$");
defineSymbol(text$2, main$1, textord, "$", "\\textdollar");
defineSymbol(math, main$1, textord, "%", "\\%");
defineSymbol(text$2, main$1, textord, "%", "\\%");
defineSymbol(math, main$1, textord, "_", "\\_");
defineSymbol(text$2, main$1, textord, "_", "\\_");
defineSymbol(text$2, main$1, textord, "_", "\\textunderscore");
defineSymbol(math, main$1, textord, "", "\\angle", true);
defineSymbol(math, main$1, textord, "", "\\infty", true);
defineSymbol(math, main$1, textord, "", "\\prime");
defineSymbol(math, main$1, textord, "", "\\triangle");
defineSymbol(math, main$1, textord, "", "\\Gamma", true);
defineSymbol(math, main$1, textord, "", "\\Delta", true);
defineSymbol(math, main$1, textord, "", "\\Theta", true);
defineSymbol(math, main$1, textord, "", "\\Lambda", true);
defineSymbol(math, main$1, textord, "", "\\Xi", true);
defineSymbol(math, main$1, textord, "", "\\Pi", true);
defineSymbol(math, main$1, textord, "", "\\Sigma", true);
defineSymbol(math, main$1, textord, "", "\\Upsilon", true);
defineSymbol(math, main$1, textord, "", "\\Phi", true);
defineSymbol(math, main$1, textord, "", "\\Psi", true);
defineSymbol(math, main$1, textord, "", "\\Omega", true);
defineSymbol(math, main$1, textord, "A", "");
defineSymbol(math, main$1, textord, "B", "");
defineSymbol(math, main$1, textord, "E", "");
defineSymbol(math, main$1, textord, "Z", "");
defineSymbol(math, main$1, textord, "H", "");
defineSymbol(math, main$1, textord, "I", "");
defineSymbol(math, main$1, textord, "K", "");
defineSymbol(math, main$1, textord, "M", "");
defineSymbol(math, main$1, textord, "N", "");
defineSymbol(math, main$1, textord, "O", "");
defineSymbol(math, main$1, textord, "P", "");
defineSymbol(math, main$1, textord, "T", "");
defineSymbol(math, main$1, textord, "X", "");
defineSymbol(math, main$1, textord, "", "\\neg", true);
defineSymbol(math, main$1, textord, "", "\\lnot");
defineSymbol(math, main$1, textord, "", "\\top");
defineSymbol(math, main$1, textord, "", "\\bot");
defineSymbol(math, main$1, textord, "", "\\emptyset");
defineSymbol(math, ams, textord, "", "\\varnothing");
defineSymbol(math, main$1, mathord, "", "\\alpha", true);
defineSymbol(math, main$1, mathord, "", "\\beta", true);
defineSymbol(math, main$1, mathord, "", "\\gamma", true);
defineSymbol(math, main$1, mathord, "", "\\delta", true);
defineSymbol(math, main$1, mathord, "", "\\epsilon", true);
defineSymbol(math, main$1, mathord, "", "\\zeta", true);
defineSymbol(math, main$1, mathord, "", "\\eta", true);
defineSymbol(math, main$1, mathord, "", "\\theta", true);
defineSymbol(math, main$1, mathord, "", "\\iota", true);
defineSymbol(math, main$1, mathord, "", "\\kappa", true);
defineSymbol(math, main$1, mathord, "", "\\lambda", true);
defineSymbol(math, main$1, mathord, "", "\\mu", true);
defineSymbol(math, main$1, mathord, "", "\\nu", true);
defineSymbol(math, main$1, mathord, "", "\\xi", true);
defineSymbol(math, main$1, mathord, "", "\\omicron", true);
defineSymbol(math, main$1, mathord, "", "\\pi", true);
defineSymbol(math, main$1, mathord, "", "\\rho", true);
defineSymbol(math, main$1, mathord, "", "\\sigma", true);
defineSymbol(math, main$1, mathord, "", "\\tau", true);
defineSymbol(math, main$1, mathord, "", "\\upsilon", true);
defineSymbol(math, main$1, mathord, "", "\\phi", true);
defineSymbol(math, main$1, mathord, "", "\\chi", true);
defineSymbol(math, main$1, mathord, "", "\\psi", true);
defineSymbol(math, main$1, mathord, "", "\\omega", true);
defineSymbol(math, main$1, mathord, "", "\\varepsilon", true);
defineSymbol(math, main$1, mathord, "", "\\vartheta", true);
defineSymbol(math, main$1, mathord, "", "\\varpi", true);
defineSymbol(math, main$1, mathord, "", "\\varrho", true);
defineSymbol(math, main$1, mathord, "", "\\varsigma", true);
defineSymbol(math, main$1, mathord, "", "\\varphi", true);
defineSymbol(math, main$1, bin, "", "*", true);
defineSymbol(math, main$1, bin, "+", "+");
defineSymbol(math, main$1, bin, "", "-", true);
defineSymbol(math, main$1, bin, "", "\\cdot", true);
defineSymbol(math, main$1, bin, "", "\\circ", true);
defineSymbol(math, main$1, bin, "", "\\div", true);
defineSymbol(math, main$1, bin, "", "\\pm", true);
defineSymbol(math, main$1, bin, "", "\\times", true);
defineSymbol(math, main$1, bin, "", "\\cap", true);
defineSymbol(math, main$1, bin, "", "\\cup", true);
defineSymbol(math, main$1, bin, "", "\\setminus", true);
defineSymbol(math, main$1, bin, "", "\\land");
defineSymbol(math, main$1, bin, "", "\\lor");
defineSymbol(math, main$1, bin, "", "\\wedge", true);
defineSymbol(math, main$1, bin, "", "\\vee", true);
defineSymbol(math, main$1, textord, "", "\\surd");
defineSymbol(math, main$1, open, "", "\\langle", true);
defineSymbol(math, main$1, open, "", "\\lvert");
defineSymbol(math, main$1, open, "", "\\lVert");
defineSymbol(math, main$1, close, "?", "?");
defineSymbol(math, main$1, close, "!", "!");
defineSymbol(math, main$1, close, "", "\\rangle", true);
defineSymbol(math, main$1, close, "", "\\rvert");
defineSymbol(math, main$1, close, "", "\\rVert");
defineSymbol(math, main$1, rel, "=", "=");
defineSymbol(math, main$1, rel, ":", ":");
defineSymbol(math, main$1, rel, "", "\\approx", true);
defineSymbol(math, main$1, rel, "", "\\cong", true);
defineSymbol(math, main$1, rel, "", "\\ge");
defineSymbol(math, main$1, rel, "", "\\geq", true);
defineSymbol(math, main$1, rel, "", "\\gets");
defineSymbol(math, main$1, rel, ">", "\\gt", true);
defineSymbol(math, main$1, rel, "", "\\in", true);
defineSymbol(math, main$1, rel, "", "\\@not");
defineSymbol(math, main$1, rel, "", "\\subset", true);
defineSymbol(math, main$1, rel, "", "\\supset", true);
defineSymbol(math, main$1, rel, "", "\\subseteq", true);
defineSymbol(math, main$1, rel, "", "\\supseteq", true);
defineSymbol(math, ams, rel, "", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "", "\\nsupseteq", true);
defineSymbol(math, main$1, rel, "", "\\models");
defineSymbol(math, main$1, rel, "", "\\leftarrow", true);
defineSymbol(math, main$1, rel, "", "\\le");
defineSymbol(math, main$1, rel, "", "\\leq", true);
defineSymbol(math, main$1, rel, "<", "\\lt", true);
defineSymbol(math, main$1, rel, "", "\\rightarrow", true);
defineSymbol(math, main$1, rel, "", "\\to");
defineSymbol(math, ams, rel, "", "\\ngeq", true);
defineSymbol(math, ams, rel, "", "\\nleq", true);
defineSymbol(math, main$1, spacing, "", "\\ ");
defineSymbol(math, main$1, spacing, "", "\\space");
defineSymbol(math, main$1, spacing, "", "\\nobreakspace");
defineSymbol(text$2, main$1, spacing, "", "\\ ");
defineSymbol(text$2, main$1, spacing, "", " ");
defineSymbol(text$2, main$1, spacing, "", "\\space");
defineSymbol(text$2, main$1, spacing, "", "\\nobreakspace");
defineSymbol(math, main$1, spacing, null, "\\nobreak");
defineSymbol(math, main$1, spacing, null, "\\allowbreak");
defineSymbol(math, main$1, punct, ",", ",");
defineSymbol(math, main$1, punct, ";", ";");
defineSymbol(math, ams, bin, "", "\\barwedge", true);
defineSymbol(math, ams, bin, "", "\\veebar", true);
defineSymbol(math, main$1, bin, "", "\\odot", true);
defineSymbol(math, main$1, bin, "", "\\oplus", true);
defineSymbol(math, main$1, bin, "", "\\otimes", true);
defineSymbol(math, main$1, textord, "", "\\partial", true);
defineSymbol(math, main$1, bin, "", "\\oslash", true);
defineSymbol(math, ams, bin, "", "\\circledcirc", true);
defineSymbol(math, ams, bin, "", "\\boxdot", true);
defineSymbol(math, main$1, bin, "", "\\bigtriangleup");
defineSymbol(math, main$1, bin, "", "\\bigtriangledown");
defineSymbol(math, main$1, bin, "", "\\dagger");
defineSymbol(math, main$1, bin, "", "\\diamond");
defineSymbol(math, main$1, bin, "", "\\star");
defineSymbol(math, main$1, bin, "", "\\triangleleft");
defineSymbol(math, main$1, bin, "", "\\triangleright");
defineSymbol(math, main$1, open, "{", "\\{");
defineSymbol(text$2, main$1, textord, "{", "\\{");
defineSymbol(text$2, main$1, textord, "{", "\\textbraceleft");
defineSymbol(math, main$1, close, "}", "\\}");
defineSymbol(text$2, main$1, textord, "}", "\\}");
defineSymbol(text$2, main$1, textord, "}", "\\textbraceright");
defineSymbol(math, main$1, open, "{", "\\lbrace");
defineSymbol(math, main$1, close, "}", "\\rbrace");
defineSymbol(math, main$1, open, "[", "\\lbrack", true);
defineSymbol(text$2, main$1, textord, "[", "\\lbrack", true);
defineSymbol(math, main$1, close, "]", "\\rbrack", true);
defineSymbol(text$2, main$1, textord, "]", "\\rbrack", true);
defineSymbol(math, main$1, open, "(", "\\lparen", true);
defineSymbol(math, main$1, close, ")", "\\rparen", true);
defineSymbol(text$2, main$1, textord, "<", "\\textless", true);
defineSymbol(text$2, main$1, textord, ">", "\\textgreater", true);
defineSymbol(math, main$1, open, "", "\\lfloor", true);
defineSymbol(math, main$1, close, "", "\\rfloor", true);
defineSymbol(math, main$1, open, "", "\\lceil", true);
defineSymbol(math, main$1, close, "", "\\rceil", true);
defineSymbol(math, main$1, textord, "\\", "\\backslash");
defineSymbol(math, main$1, textord, "", "|");
defineSymbol(math, main$1, textord, "", "\\vert");
defineSymbol(text$2, main$1, textord, "|", "\\textbar", true);
defineSymbol(math, main$1, textord, "", "\\|");
defineSymbol(math, main$1, textord, "", "\\Vert");
defineSymbol(text$2, main$1, textord, "", "\\textbardbl");
defineSymbol(text$2, main$1, textord, "~", "\\textasciitilde");
defineSymbol(text$2, main$1, textord, "\\", "\\textbackslash");
defineSymbol(text$2, main$1, textord, "^", "\\textasciicircum");
defineSymbol(math, main$1, rel, "", "\\uparrow", true);
defineSymbol(math, main$1, rel, "", "\\Uparrow", true);
defineSymbol(math, main$1, rel, "", "\\downarrow", true);
defineSymbol(math, main$1, rel, "", "\\Downarrow", true);
defineSymbol(math, main$1, rel, "", "\\updownarrow", true);
defineSymbol(math, main$1, rel, "", "\\Updownarrow", true);
defineSymbol(math, main$1, op, "", "\\coprod");
defineSymbol(math, main$1, op, "", "\\bigvee");
defineSymbol(math, main$1, op, "", "\\bigwedge");
defineSymbol(math, main$1, op, "", "\\biguplus");
defineSymbol(math, main$1, op, "", "\\bigcap");
defineSymbol(math, main$1, op, "", "\\bigcup");
defineSymbol(math, main$1, op, "", "\\int");
defineSymbol(math, main$1, op, "", "\\intop");
defineSymbol(math, main$1, op, "", "\\iint");
defineSymbol(math, main$1, op, "", "\\iiint");
defineSymbol(math, main$1, op, "", "\\prod");
defineSymbol(math, main$1, op, "", "\\sum");
defineSymbol(math, main$1, op, "", "\\bigotimes");
defineSymbol(math, main$1, op, "", "\\bigoplus");
defineSymbol(math, main$1, op, "", "\\bigodot");
defineSymbol(math, main$1, op, "", "\\oint");
defineSymbol(math, main$1, op, "", "\\oiint");
defineSymbol(math, main$1, op, "", "\\oiiint");
defineSymbol(math, main$1, op, "", "\\bigsqcup");
defineSymbol(math, main$1, op, "", "\\smallint");
defineSymbol(text$2, main$1, inner, "", "\\textellipsis");
defineSymbol(math, main$1, inner, "", "\\mathellipsis");
defineSymbol(text$2, main$1, inner, "", "\\ldots", true);
defineSymbol(math, main$1, inner, "", "\\ldots", true);
defineSymbol(math, main$1, inner, "", "\\@cdots", true);
defineSymbol(math, main$1, inner, "", "\\ddots", true);
defineSymbol(math, main$1, textord, "", "\\varvdots");
defineSymbol(math, main$1, accent, "", "\\acute");
defineSymbol(math, main$1, accent, "", "\\grave");
defineSymbol(math, main$1, accent, "", "\\ddot");
defineSymbol(math, main$1, accent, "~", "\\tilde");
defineSymbol(math, main$1, accent, "", "\\bar");
defineSymbol(math, main$1, accent, "", "\\breve");
defineSymbol(math, main$1, accent, "", "\\check");
defineSymbol(math, main$1, accent, "^", "\\hat");
defineSymbol(math, main$1, accent, "", "\\vec");
defineSymbol(math, main$1, accent, "", "\\dot");
defineSymbol(math, main$1, accent, "", "\\mathring");
defineSymbol(math, main$1, mathord, "", "\\@imath");
defineSymbol(math, main$1, mathord, "", "\\@jmath");
defineSymbol(math, main$1, textord, "", "");
defineSymbol(math, main$1, textord, "", "");
defineSymbol(text$2, main$1, textord, "", "\\i", true);
defineSymbol(text$2, main$1, textord, "", "\\j", true);
defineSymbol(text$2, main$1, textord, "", "\\ss", true);
defineSymbol(text$2, main$1, textord, "", "\\ae", true);
defineSymbol(text$2, main$1, textord, "", "\\oe", true);
defineSymbol(text$2, main$1, textord, "", "\\o", true);
defineSymbol(text$2, main$1, textord, "", "\\AE", true);
defineSymbol(text$2, main$1, textord, "", "\\OE", true);
defineSymbol(text$2, main$1, textord, "", "\\O", true);
defineSymbol(text$2, main$1, accent, "", "\\'");
defineSymbol(text$2, main$1, accent, "", "\\`");
defineSymbol(text$2, main$1, accent, "", "\\^");
defineSymbol(text$2, main$1, accent, "", "\\~");
defineSymbol(text$2, main$1, accent, "", "\\=");
defineSymbol(text$2, main$1, accent, "", "\\u");
defineSymbol(text$2, main$1, accent, "", "\\.");
defineSymbol(text$2, main$1, accent, "", "\\c");
defineSymbol(text$2, main$1, accent, "", "\\r");
defineSymbol(text$2, main$1, accent, "", "\\v");
defineSymbol(text$2, main$1, accent, "", '\\"');
defineSymbol(text$2, main$1, accent, "", "\\H");
defineSymbol(text$2, main$1, accent, "", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text$2, main$1, textord, "", "--", true);
defineSymbol(text$2, main$1, textord, "", "\\textendash");
defineSymbol(text$2, main$1, textord, "", "---", true);
defineSymbol(text$2, main$1, textord, "", "\\textemdash");
defineSymbol(text$2, main$1, textord, "", "`", true);
defineSymbol(text$2, main$1, textord, "", "\\textquoteleft");
defineSymbol(text$2, main$1, textord, "", "'", true);
defineSymbol(text$2, main$1, textord, "", "\\textquoteright");
defineSymbol(text$2, main$1, textord, "", "``", true);
defineSymbol(text$2, main$1, textord, "", "\\textquotedblleft");
defineSymbol(text$2, main$1, textord, "", "''", true);
defineSymbol(text$2, main$1, textord, "", "\\textquotedblright");
defineSymbol(math, main$1, textord, "", "\\degree", true);
defineSymbol(text$2, main$1, textord, "", "\\degree");
defineSymbol(text$2, main$1, textord, "", "\\textdegree", true);
defineSymbol(math, main$1, textord, "", "\\pounds");
defineSymbol(math, main$1, textord, "", "\\mathsterling", true);
defineSymbol(text$2, main$1, textord, "", "\\pounds");
defineSymbol(text$2, main$1, textord, "", "\\textsterling", true);
defineSymbol(math, ams, textord, "", "\\maltese");
defineSymbol(text$2, ams, textord, "", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main$1, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text$2, main$1, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math, main$1, mathord, _ch2, _ch2);
  defineSymbol(text$2, main$1, textord, _ch2, _ch2);
}
defineSymbol(math, ams, textord, "C", "");
defineSymbol(text$2, ams, textord, "C", "");
defineSymbol(math, ams, textord, "H", "");
defineSymbol(text$2, ams, textord, "H", "");
defineSymbol(math, ams, textord, "N", "");
defineSymbol(text$2, ams, textord, "N", "");
defineSymbol(math, ams, textord, "P", "");
defineSymbol(text$2, ams, textord, "P", "");
defineSymbol(math, ams, textord, "Q", "");
defineSymbol(text$2, ams, textord, "Q", "");
defineSymbol(math, ams, textord, "R", "");
defineSymbol(text$2, ams, textord, "R", "");
defineSymbol(math, ams, textord, "Z", "");
defineSymbol(text$2, ams, textord, "Z", "");
defineSymbol(math, main$1, mathord, "h", "");
defineSymbol(text$2, main$1, mathord, "h", "");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56684 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main$1, mathord, _ch3, wideChar);
    defineSymbol(text$2, main$1, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main$1, mathord, _ch3, wideChar);
    defineSymbol(text$2, main$1, textord, _ch3, wideChar);
  }
}
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main$1, mathord, "k", wideChar);
defineSymbol(text$2, main$1, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text$2, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text$2, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text$2, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text$2, main$1, textord, _ch4, wideChar);
}
var extraLatin = "";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main$1, mathord, _ch5, _ch5);
  defineSymbol(text$2, main$1, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H = wideChar2.charCodeAt(0);
  var L = wideChar2.charCodeAt(1);
  var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
  var j = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }
  return {
    value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value, fontName, mode, options2, classes) {
  var lookup2 = lookupSymbol(value, fontName, mode);
  var metrics = lookup2.metrics;
  value = lookup2.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options2 && options2.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }
  if (options2) {
    symbolNode.maxFontSize = options2.sizeMultiplier;
    if (options2.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color = options2.getColor();
    if (color) {
      symbolNode.style.color = color;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value, mode, options2, classes) {
  if (classes === void 0) {
    classes = [];
  }
  if (options2.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options2, classes.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options2, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options2, classes.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value, mode, options2, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options2, type) {
  var mode = group.mode;
  var text2 = group.text;
  var classes = ["mord"];
  var isFont = mode === "math" || mode === "text" && options2.font;
  var fontOrFamily = isFont ? options2.font : options2.fontFamily;
  var wideFontName = "";
  var wideFontClass = "";
  if (text2.charCodeAt(0) === 55349) {
    [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
  }
  if (wideFontName.length > 0) {
    return makeSymbol(text2, wideFontName, mode, options2, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text2, mode, options2, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options2.fontWeight, options2.fontShape);
      fontClasses = [fontOrFamily, options2.fontWeight, options2.fontShape];
    }
    if (lookupSymbol(text2, fontName, mode).metrics) {
      return makeSymbol(text2, fontName, mode, options2, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
      var parts = [];
      for (var i = 0; i < text2.length; i++) {
        parts.push(makeSymbol(text2[i], fontName, mode, options2, classes.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text2, "Math-Italic", mode, options2, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text2] && symbols[mode][text2].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName, mode, options2, classes.concat("amsrm", options2.fontWeight, options2.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName2, mode, options2, classes.concat(options2.fontWeight, options2.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options2.fontWeight, options2.fontShape);
      return makeSymbol(text2, _fontName3, mode, options2, classes.concat(_fontName3, options2.fontWeight, options2.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev, next) => {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  }
  if (prev.classes.length === 1) {
    var cls = prev.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }
  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i = 0; i < chars.length - 1; i++) {
    var prev = chars[i];
    var next = chars[i + 1];
    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth);
      prev.italic = next.italic;
      chars.splice(i + 1, 1);
      i--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i = 0; i < elem.children.length; i++) {
    var child = elem.children[i];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes, children2, options2, style) {
  var span = new Span(classes, children2, options2, style);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes, children2, options2, style) => new Span(classes, children2, options2, style);
var makeLineSpan = function makeLineSpan2(className, options2, thickness) {
  var line = makeSpan$2([className], [], options2);
  line.height = Math.max(thickness || options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes, children2, options2) {
  var anchor = new Anchor(href, classes, children2, options2);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children2) {
  var fragment = new DocumentFragment(children2);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options2) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options2);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children2 = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i = 1; i < oldChildren.length; i++) {
      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children2.push({
        type: "kern",
        size
      });
      children2.push(oldChildren[i]);
    }
    return {
      children: children2,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options2) {
  var {
    children: children2,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i = 0; i < children2.length; i++) {
    var child = children2[i];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children2.length; _i2++) {
    var _child = children2[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options2) => {
  var rule = makeSpan$2(["mspace"], [], options2);
  var size = calculateSize(measurement, options2);
  rule.style.marginRight = makeEm(size);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value, options2) {
  var [pathName, width, height] = svgData[value];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options2);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options2, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i = 0; i < expression.length; i++) {
    var output = buildGroup$1(expression[i], options2);
    if (output instanceof DocumentFragment) {
      var children2 = output.children;
      groups.push(...children2);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options2;
  if (expression.length === 1) {
    var node = expression[0];
    if (node.type === "sizing") {
      glueOptions = options2.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options2.havingStyle(styleMap$1[node.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options2);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options2);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = prev.classes[0];
    var type = node2.classes[0];
    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node2.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node2);
    var space2 = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space2) {
      return buildCommon.makeGlue(space2, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
  if (next) {
    nodes.push(next);
  }
  var i = 0;
  for (; i < nodes.length; i++) {
    var node = nodes[i];
    var partialGroup = checkPartialGroup(node);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
      continue;
    }
    var nonspace = !node.hasClass("mspace");
    if (nonspace) {
      var result = callback(node, prev.node);
      if (result) {
        if (prev.insertAfter) {
          prev.insertAfter(result);
        } else {
          nodes.unshift(result);
          i++;
        }
      }
    }
    if (nonspace) {
      prev.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev.node = makeSpan$1(["leftmost"]);
    }
    prev.insertAfter = /* @__PURE__ */ ((index) => (n) => {
      nodes.splice(index + 1, 0, n);
      i++;
    })(i);
  }
  if (next) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node) {
  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node, side) {
  var partialGroup = checkPartialGroup(node);
  if (partialGroup) {
    var children2 = partialGroup.children;
    if (children2.length) {
      if (side === "right") {
        return getOutermostNode2(children2[children2.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children2[0], "left");
      }
    }
  }
  return node;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
  if (!node) {
    return null;
  }
  if (side) {
    node = getOutermostNode(node, side);
  }
  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options2, classes) {
  var moreClasses = ["nulldelimiter"].concat(options2.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options2, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options2);
    if (baseOptions && options2.size !== baseOptions.size) {
      groupNode = makeSpan$1(options2.sizingClasses(baseOptions), [groupNode], options2);
      var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children2, options2) {
  var body = makeSpan$1(["base"], children2, options2);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options2) {
  var tag2 = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag2 = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options2, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children2 = [];
  var parts = [];
  for (var i = 0; i < expression.length; i++) {
    parts.push(expression[i]);
    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      var nobreak = false;
      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts.push(expression[i]);
        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children2.push(buildHTMLUnbreakable(parts, options2));
        parts = [];
      }
    } else if (expression[i].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children2.push(buildHTMLUnbreakable(parts, options2));
        parts = [];
      }
      children2.push(expression[i]);
    }
  }
  if (parts.length > 0) {
    children2.push(buildHTMLUnbreakable(parts, options2));
  }
  var tagChild;
  if (tag2) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag2, options2, true));
    tagChild.classes = ["tag"];
    children2.push(tagChild);
  } else if (eqnNum) {
    children2.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children2);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children2) {
  return new DocumentFragment(children2);
}
class MathNode {
  constructor(type, children2, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children2 || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="';
        markup += utils.escape(this.attributes[attr2]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}
class TextNode {
  constructor(text2) {
    this.text = void 0;
    this.text = text2;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text2, mode, options2) {
  if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options2 && (options2.fontFamily && options2.fontFamily.slice(4, 6) === "tt" || options2.font && options2.font.slice(4, 6) === "tt"))) {
    text2 = symbols[mode][text2].replace;
  }
  return new mathMLTree.TextNode(text2);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options2) {
  if (options2.fontFamily === "texttt") {
    return "monospace";
  } else if (options2.fontFamily === "textsf") {
    if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options2.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options2.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options2.fontShape === "textit") {
    return "italic";
  } else if (options2.fontWeight === "textbf") {
    return "bold";
  }
  var font = options2.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text2 = group.text;
  if (utils.contains(["\\imath", "\\jmath"], text2)) {
    return null;
  }
  if (symbols[mode][text2] && symbols[mode][text2].replace) {
    text2 = symbols[mode][text2].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text2, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
var buildExpression2 = function buildExpression3(expression, options2, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options2);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i = 0; i < expression.length; i++) {
    var _group = buildGroup2(expression[i], options2);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
        var child = _group.children[0];
        if (child instanceof TextNode && child.text === ".") {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var _child = _group.children[0];
          if (_child instanceof TextNode && _child.text.length > 0) {
            _child.text = _child.text.slice(0, 1) + "" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options2, isOrdgroup) {
  return makeRow(buildExpression2(expression, options2, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options2) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options2);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options2, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options2);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];
    if (settings.leqno) {
      classes.push("leqno");
    }
    if (settings.fleqn) {
      classes.push("fleqn");
    }
    node = buildCommon.makeSpan(classes, [node]);
  }
  return node;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options2 = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options2, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options2);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options2, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options2);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options2 = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options2);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label2) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label2.replace(/^\\/, "")])]);
  node.setAttribute("stretchy", "true");
  return node;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options2) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label2 = group.label.slice(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label2)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label2 === "widehat" || label2 === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label2 + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label2 === "widehat" || label2 === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label2 + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options2),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label2];
      var [paths, _minWidth, _viewBoxHeight] = data;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i = 0; i < numSvgChildren; i++) {
        var _path = new PathNode(paths[i]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options2);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options2),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label2, topPad, bottomPad, options2) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label2)) {
    img = buildCommon.makeSpan(["stretchy", label2], [], options2);
    if (label2 === "fbox") {
      var color = options2.color && options2.getColor();
      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label2)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label2)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options2);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  }
  return node;
}
function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }
  return typedNode;
}
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    return node;
  }
  return null;
}
var htmlBuilder$a = (grp, options2) => {
  var base;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base = group.base;
    grp.base = base;
    supSubGroup = assertSpan(buildGroup$1(grp, options2));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  }
  var body = buildGroup$1(base, options2.havingCrampedStyle());
  var mustShift = group.isShifty && utils.isCharacterBox(base);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils.getBaseElem(base);
    var baseGroup = buildGroup$1(baseChar, options2.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options2.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options2);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options2, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left = skew;
    if (!accentFull) {
      left -= width / 2;
    }
    accentBody.style.left = makeEm(left);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options2);
  } else {
    accentBody = stretchy.svgSpan(group, options2);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options2);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options2);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options2) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options2), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base
    };
  },
  htmlBuilder: (group, options2) => {
    var innerGroup = buildGroup$1(group.base, options2);
    var accentBody = stretchy.svgSpan(group, options2);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options2);
  },
  mathmlBuilder: (group, options2) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options2), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
var paddedNode = (group) => {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options2) {
    var style = options2.style;
    var newOptions = options2.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options2), options2);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options2.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options2), options2);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options2);
    var arrowShift = -options2.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options2.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options2.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options2);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options2);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options2));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options2));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options2));
      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }
    return node;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options2) {
  var elements = buildExpression$1(group.body, options2, true);
  return makeSpan2([group.mclass], elements, options2);
}
function mathmlBuilder$8(group, options2) {
  var node;
  var inner2 = buildExpression2(group.body, options2);
  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em";
      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node.attributes.lspace = "0.0556em";
      node.attributes.width = "+0.1111em";
    }
  }
  return node;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options2) {
    var elements = buildExpression$1(group.body, options2, true);
    var node = buildCommon.makeSpan([group.mclass], elements, options2);
    node.style.textShadow = "0.02em 0.01em 0.04px";
    return node;
  },
  mathmlBuilder(group, style) {
    var inner2 = buildExpression2(group.body, style);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};
var isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};
function cdArrow(arrowChar, labels, parser) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser) {
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i = 0; i < parsedRows.length; i++) {
    var rowNodes = parsedRows[i];
    var cell = newCell();
    for (var j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        cell.body.push(rowNodes[j]);
      } else {
        row.push(cell);
        j += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1)
          ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }
              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
        }
        var arrow = cdArrow(arrowChar, labels, parser);
        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var newOptions = options2.havingStyle(options2.style.sup());
    var label2 = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options2), options2);
    label2.classes.push("cd-label-" + group.side);
    label2.style.bottom = makeEm(0.8 - label2.depth);
    label2.height = 0;
    label2.depth = 0;
    return label2;
  },
  mathmlBuilder(group, options2) {
    var label2 = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options2)]);
    label2 = new mathMLTree.MathNode("mpadded", [label2]);
    label2.setAttribute("width", "0");
    if (group.side === "left") {
      label2.setAttribute("lspace", "-1width");
    }
    label2.setAttribute("voffset", "0.7em");
    label2 = new mathMLTree.MathNode("mstyle", [label2]);
    label2.setAttribute("displaystyle", "false");
    label2.setAttribute("scriptlevel", "1");
    return label2;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options2), options2);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options2)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number2 = "";
    for (var i = 0; i < group.length; i++) {
      var node = assertNodeType(group[i], "textord");
      number2 += node.text;
    }
    var code2 = parseInt(number2);
    var text2;
    if (isNaN(code2)) {
      throw new ParseError("\\@char has non-numeric argument " + number2);
    } else if (code2 < 0 || code2 >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number2);
    } else if (code2 <= 65535) {
      text2 = String.fromCharCode(code2);
    } else {
      code2 -= 65536;
      text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: text2
    };
  }
});
var htmlBuilder$8 = (group, options2) => {
  var elements = buildExpression$1(group.body, options2.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$7 = (group, options2) => {
  var inner2 = buildExpression2(group.body, options2.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner2);
  node.setAttribute("mathcolor", group.color);
  return node;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color = assertNodeType(args[0], "color-token").color;
    parser.gullet.macros.set("\\current@color", color);
    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options2) {
    var span = buildCommon.makeSpan(["mspace"], [], options2);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options2));
      }
    }
    return span;
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options2)));
      }
    }
    return node;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser) => {
  var tok = parser.gullet.popToken();
  if (tok.text === "=") {
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser, name, tok, global2) => {
  var macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global2);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token = parser.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options2, classes) {
  var newOptions = options2.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options2)), [delim], options2);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options2.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options2, style) {
  var newOptions = options2.havingBaseStyle(style);
  var shift = (1 - options2.sizeMultiplier / newOptions.sizeMultiplier) * options2.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style, center, options2, mode, classes) {
  var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options2);
  var span = styleWrap(text2, style, options2, classes);
  if (center) {
    centerSpan(span, options2, style);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value, size, mode, options2) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options2);
};
var makeLargeDelim = function makeLargeDelim2(delim, size, center, options2, mode, classes) {
  var inner2 = mathrmSize(delim, size, mode, options2);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options2), Style$1.TEXT, options2, classes);
  if (center) {
    centerSpan(span, options2, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height, options2) {
  var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options2);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options2, mode, classes) {
  var top;
  var middle;
  var repeat;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\downarrow") {
    top = repeat = "";
  } else if (delim === "\\Downarrow") {
    top = repeat = "";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat = "";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils.contains(doubleVerts, delim)) {
    repeat = "";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options2.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options2.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path2 = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg2 = new SvgNode([path2], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg2], options2);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options2));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, _innerHeight, options2));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options2));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  }
  var newOptions = options2.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options2, classes);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options2) {
  var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg2 = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg2], options2);
};
var makeSqrtImage = function makeSqrtImage2(height, options2) {
  var newOptions = options2.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options2.minRuleThickness - options2.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options2);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options2);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options2);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options2.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size, options2, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options2, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options2, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options2) {
  var start = Math.min(2, 3 - options2.style.size);
  for (var i = start; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i].type === "small") {
      var newOptions = options2.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options2, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  var sequence;
  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options2);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options2, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options2, mode, classes);
  } else {
    return makeStackedDelim(delim, height, center, options2, mode, classes);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options2, mode, classes) {
  var axisHeight = options2.fontMetrics().axisHeight * options2.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options2.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options2, mode, classes);
};
var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options2) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter.sizedDelim(group.delim, group.size, options2, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children2 = [];
    if (group.delim !== ".") {
      children2.push(makeText(group.delim, group.mode));
    }
    var node = new mathMLTree.MathNode("mo", children2);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.setAttribute("fence", "true");
    } else {
      node.setAttribute("fence", "false");
    }
    node.setAttribute("stretchy", "true");
    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color = context.parser.gullet.macros.get("\\current@color");
    if (color && typeof color !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser;
    ++parser.leftrightDepth;
    var body = parser.parseExpression(false);
    --parser.leftrightDepth;
    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options2) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options2, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i = 0; i < inner2.length; i++) {
      if (inner2[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i].height, innerHeight);
        innerDepth = Math.max(inner2[i].depth, innerDepth);
      }
    }
    innerHeight *= options2.sizeMultiplier;
    innerDepth *= options2.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options2, ["mopen"]);
    } else {
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options2, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner2.length; _i++) {
        var middleDelim = inner2[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options2, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options2.withColor(group.rightColor) : options2;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options2);
  },
  mathmlBuilder: (group, options2) => {
    assertParsed(group);
    var inner2 = buildExpression2(group.body, options2);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options2) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options2, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options2, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options: options2
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options2) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options2) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options2), options2);
  var label2 = group.label.slice(1);
  var scale = options2.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils.isCharacterBox(group.body);
  if (label2 === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options2.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options2.fontMetrics().xHeight;
  } else if (label2 === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options2);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options2);
    var newOptions = options2.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options2);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label2)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label2 === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label2)) {
      ruleThickness = Math.max(
        options2.fontMetrics().fboxrule,
        // default
        options2.minRuleThickness
        // User override.
      );
      topPad = options2.fontMetrics().fboxsep + (label2 === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label2 === "angl") {
      ruleThickness = Math.max(options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label2, topPad, bottomPad, options2);
    if (/fbox|boxed|fcolorbox/.test(label2)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label2 === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options2);
  } else {
    var classes = /cancel|phase/.test(label2) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes
        }
      ]
    }, options2);
  }
  if (/cancel/.test(label2)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label2) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options2);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options2);
  }
};
var mathmlBuilder$6 = (group, options2) => {
  var fboxsep = 0;
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options2)]);
  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node.setAttribute("notation", "box");
      break;
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options2.fontMetrics().fboxsep * options2.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt");
      node.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options2.fontMetrics().fboxrule,
          // default
          options2.minRuleThickness
          // user override
        );
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
function getHLines(parser) {
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
}
function parseArray(parser, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();
  if (!singleRow) {
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser));
  while (true) {
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };
    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }
    row.push(cell);
    var next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser.consume();
    } else if (next === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      var size = void 0;
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options2) {
  var r;
  var c;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options2.fontMetrics().arrayRuleWidth,
    options2.minRuleThickness
    // User override.
  );
  var pt = 1 / options2.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options2.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options2.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options2) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c = 0; c < inrow.length; ++c) {
      var elt = buildGroup$1(inrow[c], options2);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c] = elt;
    }
    var rowGap = group.rowGaps[r];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options2);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r] = outrow;
    setHLinePos(hLinesBeforeRow[r + 1]);
  }
  var offset = totalHeight / 2 + options2.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag3) => tag3)) {
    for (r = 0; r < nr; ++r) {
      var rw = body[r];
      var shift = rw.pos - offset;
      var tag2 = group.tags[r];
      var tagSpan = void 0;
      if (tag2 === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options2);
      } else if (tag2 === false) {
        tagSpan = buildCommon.makeSpan([], [], options2);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag2, options2, true), options2);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }
  for (
    c = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c < nc || colDescrNum < colDescriptions.length;
    ++c, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options2.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options2);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options2);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options2, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options2, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options2);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options2);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options2);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options2);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options2) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag2 = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i = 0; i < group.body.length; i++) {
    var rw = group.body[i];
    var row = [];
    for (var j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options2)]));
    }
    if (group.tags && group.tags[i]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag2);
      } else {
        row.push(tag2);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }
  return table;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i = 0; i < args[0].body.length; i++) {
      var textord2 = assertNodeType(args[0].body[i], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca2 = node.text;
      if ("lcr".indexOf(ca2) !== -1) {
        return {
          type: "align",
          align: ca2
        };
      } else if (ca2 === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca2 === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca2, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca2 = node.text;
      if ("lc".indexOf(ca2) !== -1) {
        return {
          type: "align",
          align: ca2
        };
      }
      throw new ParseError("Unknown column alignment: " + ca2, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (utils.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env);
      var context = {
        mode: parser.mode,
        envName,
        parser
      };
      var result = env.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options2) => {
  var font = group.font;
  var newOptions = options2.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options2) => {
  var font = group.font;
  var newOptions = options2.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size, originalStyle) => {
  var style = originalStyle;
  if (size === "display") {
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
    style = Style$1.TEXT;
  } else if (size === "script") {
    style = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }
  return style;
};
var htmlBuilder$4 = (group, options2) => {
  var style = adjustStyle(group.size, options2.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options2.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options2);
  if (group.continued) {
    var hStrut = 8.5 / options2.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options2.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options2.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options2);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options2);
      rule = buildCommon.makeLineSpan("frac-line", options2, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options2);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options2.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options2.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options2.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options2.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options2.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options2.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options2);
  } else {
    var axisHeight = options2.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options2);
  }
  newOptions = options2.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options2.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options2.sizeMultiplier;
  var delimSize;
  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options2.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options2.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options2.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options2, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options2, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options2)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options2);
};
var mathmlBuilder$3 = (group, options2) => {
  var node = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options2), buildGroup2(group.denom, options2)]);
  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options2);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style = adjustStyle(group.size, options2.style);
  if (style.size !== options2.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options2) => {
  var style = options2.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options2.havingStyle(style.sup()), options2) : buildGroup$1(grp.sub, options2.havingStyle(style.sub()), options2);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options2.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options2);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options2);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options2);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options2);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options2);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
};
var mathmlBuilder$2 = (group, options2) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options2), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2, false);
    return buildCommon.makeAnchor(group.href, [], elements, options2);
  },
  mathmlBuilder: (group, options2) => {
    var math2 = buildExpressionRow(group.body, options2);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i = 0; i < href.length; i++) {
      var c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options2) {
    var elements = buildExpression$1(group.body, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options2));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;
      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;
      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;
      case "\\htmlData": {
        var data = value.split(",");
        for (var i = 0; i < data.length; i++) {
          var keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2, false);
    var classes = ["enclosing"];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes, elements, options2);
    for (var attr2 in group.attributes) {
      if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
        span.setAttribute(attr2, group.attributes[attr2]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options2) => {
    return buildExpressionRow(group.body, options2);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.html, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    return buildExpressionRow(group.mathml, options2);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i = 0; i < attributes.length; i++) {
        var keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width = sizeData(str);
              break;
            case "height":
              height = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options2) => {
    var height = calculateSize(group.height, options2);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options2) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options2);
    }
    var style = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style.width = makeEm(width);
    }
    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }
    var node = new Img(group.src, group.alt, style);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options2);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options2) - height;
      node.setAttribute("valign", makeEm(-depth));
    }
    node.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options2);
      node.setAttribute("width", makeEm(width));
    }
    node.setAttribute("src", group.src);
    return node;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }
        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  htmlBuilder(group, options2) {
    return buildCommon.makeGlue(group.dimension, options2);
  },
  mathmlBuilder(group, options2) {
    var dimension = calculateSize(group.dimension, options2);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options2);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options2);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);
    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }
    node.children.unshift(strut);
    node = buildCommon.makeSpan(["thinbox"], [node], options2);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options2);
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close2);
    parser.expect(close2);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options2) => {
  switch (options2.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options2) => {
    var body = chooseMathStyle(group, options2);
    var elements = buildExpression$1(body, options2, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    var body = chooseMathStyle(group, options2);
    return buildExpressionRow(body, options2);
  }
});
var assembleSupSub = (base, supGroup, subGroup, options2, style, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options2.havingStyle(style.sup()), options2);
    sup2 = {
      elem,
      kern: Math.max(options2.fontMetrics().bigOpSpacing1, options2.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options2.havingStyle(style.sub()), options2);
    sub2 = {
      elem: _elem,
      kern: Math.max(options2.fontMetrics().bigOpSpacing2, options2.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options2.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }]
    }, options2);
  } else if (sub2) {
    var top = base.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options2);
  } else if (sup2) {
    var _bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options2.fontMetrics().bigOpSpacing5
      }]
    }, options2);
  } else {
    return base;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options2);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options2);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options2) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style = options2.style;
  var large = false;
  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    large = true;
  }
  var base;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base = buildCommon.makeSymbol(group.name, fontName, "math", options2, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options2);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options2);
      group.name = "\\" + stash;
      base.classes.unshift("mop");
      base.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options2, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base = inner2[0];
      base.classes[0] = "mop";
    } else {
      base = buildCommon.makeSpan(["mop"], inner2, options2);
    }
  } else {
    var output = [];
    for (var i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode, options2));
    }
    base = buildCommon.makeSpan(["mop"], output, options2);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base.height - base.depth) / 2 - options2.fontMetrics().axisHeight;
    slant = base.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options2, style, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }
    return base;
  }
};
var mathmlBuilder$1 = (group, options2) => {
  var node;
  if (group.symbol) {
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (utils.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node = new MathNode("mo", buildExpression2(group.body, options2));
  } else {
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("", "text")]);
    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }
  return node;
};
var singleCharBigOps = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options2) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options2.withFont("mathrm"), true);
    for (var i = 0; i < expression.length; i++) {
      var child = expression[i];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base = buildCommon.makeSpan(["mop"], expression, options2);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options2);
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options2, options2.style, 0, 0);
  } else {
    return base;
  }
};
var mathmlBuilder2 = (group, options2) => {
  var expression = buildExpression2(group.body, options2.withFont("mathrm"));
  var isAllString = true;
  for (var i = 0; i < expression.length; i++) {
    var node = expression[i];
    if (node instanceof mathMLTree.SpaceNode)
      ;
    else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node2) => node2.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options2) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options2, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options2, true), options2);
  },
  mathmlBuilder(group, options2) {
    return buildExpressionRow(group.body, options2, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder(group, options2) {
    var innerGroup = buildGroup$1(group.body, options2.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options2);
    var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options2), operator]);
    node.setAttribute("accent", "true");
    return node;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options2) => {
    var elements = buildExpression$1(group.body, options2.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression2(group.body, options2);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2.withPhantom())]);
    node.height = 0;
    node.depth = 0;
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    }
    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options2);
    return buildCommon.makeSpan(["mord"], [node], options2);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression2(ordargument(group.body), options2);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options2) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options2);
  },
  mathmlBuilder: (group, options2) => {
    var inner2 = buildExpression2(ordargument(group.body), options2);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options2) {
    var body = buildGroup$1(group.body, options2);
    var dy = calculateSize(group.dy, options2);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options2);
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options2) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options2);
    var width = calculateSize(group.width, options2);
    var height = calculateSize(group.height, options2);
    var shift = group.shift ? calculateSize(group.shift, options2) : 0;
    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift);
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;
    rule.maxFontSize = height * 1.125 * options2.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options2) {
    var width = calculateSize(group.width, options2);
    var height = calculateSize(group.height, options2);
    var shift = group.shift ? calculateSize(group.shift, options2) : 0;
    var color = options2.color && options2.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value, options2, baseOptions) {
  var inner2 = buildExpression$1(value, options2, false);
  var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i = 0; i < inner2.length; i++) {
    var pos = inner2[i].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i].classes, options2.sizingClasses(baseOptions));
    } else if (inner2[i].classes[pos + 1] === "reset-size" + options2.size) {
      inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i].height *= multiplier;
    inner2[i].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options2) => {
  var newOptions = options2.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options2);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options2) => {
    var newOptions = options2.havingSize(group.size);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i = 0; i < tbArg.body.length; ++i) {
        var node = tbArg.body[i];
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options2) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }
    if (group.smashHeight) {
      node.height = 0;
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node.depth = 0;
      if (node.children) {
        for (var _i = 0; _i < node.children.length; _i++) {
          node.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options2);
    return buildCommon.makeSpan(["mord"], [smashedNode], options2);
  },
  mathmlBuilder: (group, options2) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }
    return node;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  htmlBuilder(group, options2) {
    var inner2 = buildGroup$1(group.body, options2.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options2.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options2);
    var metrics = options2.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options2.style.id < Style$1.TEXT.id) {
      phi = options2.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options2);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options2);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options2);
    } else {
      var newOptions = options2.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options2);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options2);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options2);
    }
  },
  mathmlBuilder(group, options2) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options2), buildGroup2(index, options2)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options2)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },
  htmlBuilder(group, options2) {
    var newStyle = styleMap[group.style];
    var newOptions = options2.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options2);
  },
  mathmlBuilder(group, options2) {
    var newStyle = styleMap[group.style];
    var newOptions = options2.havingStyle(newStyle);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr2 = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr2[0]);
    node.setAttribute("displaystyle", attr2[1]);
    return node;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options2) {
  var base = group.base;
  if (!base) {
    return null;
  } else if (base.type === "op") {
    var delegate = base.limits && (options2.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options2.style.size === Style$1.DISPLAY.size || base.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options2) {
    var builderDelegate = htmlBuilderDelegate(group, options2);
    if (builderDelegate) {
      return builderDelegate(group, options2);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options2);
    var supm;
    var subm;
    var metrics = options2.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options2.havingStyle(options2.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options2);
      if (!isCharacterBox3) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options2.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options2.havingStyle(options2.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options2);
      if (!isCharacterBox3) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options2.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options2.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options2.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options2.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options2);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options2);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options2);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options2);
  },
  mathmlBuilder(group, options2) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children2 = [buildGroup2(group.base, options2)];
    if (group.sub) {
      children2.push(buildGroup2(group.sub, options2));
    }
    if (group.sup) {
      children2.push(buildGroup2(group.sup, options2));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;
      if (base && base.type === "op" && base.limits && (options2.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options2.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options2.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options2.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options2.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options2.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children2);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options2) {
    return buildCommon.mathsym(group.text, group.mode, options2, ["m" + group.family]);
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options2);
      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node.setAttribute("stretchy", "false");
    }
    return node;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options2) {
    return buildCommon.makeOrd(group, options2, "mathord");
  },
  mathmlBuilder(group, options2) {
    var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options2)]);
    var variant = getVariant(group, options2) || "italic";
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options2) {
    return buildCommon.makeOrd(group, options2, "textord");
  },
  mathmlBuilder(group, options2) {
    var text2 = makeText(group.text, group.mode, options2);
    var variant = getVariant(group, options2) || "normal";
    var node;
    if (group.mode === "text") {
      node = new mathMLTree.MathNode("mtext", [text2]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text2]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text2]);
    } else {
      node = new mathMLTree.MathNode("mi", [text2]);
    }
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options2) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options2, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options2)], options2);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options2);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options2) {
    var node;
    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options2) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options2)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options2)])])]);
    table.setAttribute("width", "100%");
    return table;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options2) => {
  var font = group.font;
  if (!font) {
    return options2;
  } else if (textFontFamilies[font]) {
    return options2.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options2.withTextFontWeight(textFontWeights[font]);
  } else {
    return options2.withTextFontShape(textFontShapes[font]);
  }
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options2) {
    var newOptions = optionsWithFont(group, options2);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options2) {
    var newOptions = optionsWithFont(group, options2);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var innerGroup = buildGroup$1(group.body, options2);
    var line = buildCommon.makeLineSpan("underline-line", options2);
    var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options2);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options2);
  },
  mathmlBuilder(group, options2) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options2), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options2) {
    var body = buildGroup$1(group.body, options2);
    var axisHeight = options2.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options2);
  },
  mathmlBuilder(group, options2) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options2) {
    var text2 = makeVerb(group);
    var body = [];
    var newOptions = options2.havingStyle(options2.style.text());
    for (var i = 0; i < text2.length; i++) {
      var c = text2[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options2)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options2) {
    var text2 = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text2]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "" : "");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[-]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
class Lexer {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char, code2) {
    this.catcodes[char] = code2;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text2 = match[6] || match[3] || (match[2] ? "\\ " : " ");
    if (this.catcodes[text2] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}
let Namespace$1 = class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name, value, global2) {
    if (global2 === void 0) {
      global2 = false;
    }
    if (global2) {
      for (var i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }
    if (value == null) {
      delete this.current[name];
    } else {
      this.current[name] = value;
    }
  }
};
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token = context.popToken();
  var base;
  var number2 = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number2 = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number2 = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    number2 = digitToNumber[token.text];
    if (number2 == null || number2 >= base) {
      throw new ParseError("Invalid base-" + base + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number2 *= base;
      number2 += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number2 + "}";
});
var newcommand = (context, existsOK, nonexistsOK) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  context.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name = tok.text;
  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
defineMacro("", "\\mathscr{B}");
defineMacro("", "\\mathscr{E}");
defineMacro("", "\\mathscr{F}");
defineMacro("", "\\mathscr{H}");
defineMacro("", "\\mathscr{I}");
defineMacro("", "\\mathscr{L}");
defineMacro("", "\\mathscr{M}");
defineMacro("", "\\mathscr{R}");
defineMacro("", "\\mathfrak{C}");
defineMacro("", "\\mathfrak{H}");
defineMacro("", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
defineMacro("\\ne", "\\neq");
defineMacro("", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
defineMacro("", "\\notin");
defineMacro("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\perp");
defineMacro("", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("", "\\notni");
defineMacro("", "\\ulcorner");
defineMacro("", "\\urcorner");
defineMacro("", "\\llcorner");
defineMacro("", "\\lrcorner");
defineMacro("", "\\copyright");
defineMacro("", "\\textregistered");
defineMacro("", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (utils.contains(["bin", "rel"], symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("", "\\dblcolon");
defineMacro("", "\\eqcolon");
defineMacro("", "\\coloneqq");
defineMacro("", "\\eqqcolon");
defineMacro("", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
defineMacro("", "\\llbracket");
defineMacro("", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
defineMacro("", "\\lBrace");
defineMacro("", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
defineMacro("", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one) => (context) => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right,
    ...arg,
    ...left
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace$1(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    var tokens = [];
    var isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start = this.future();
    var tok;
    var depth = 0;
    var match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }
      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims = delimiters2[0];
      for (var i = 0; i < delims.length; i++) {
        var tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(amount) {
    this.expansionCount += amount;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.countExpansion(1);
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i = tokens.length - 1; i >= 0; --i) {
        var tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i];
          if (tok.text === "#") {
            tokens.splice(i + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    var definition = this.macros.get(name);
    if (definition == null) {
      return definition;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
}
var unicodeSubRegEx = /^[]/;
var uSubsAndSups = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "w",
  "": "x",
  "": "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
});
var unicodeAccents = {
  "": {
    "text": "\\'",
    "math": "\\acute"
  },
  "": {
    "text": "\\`",
    "math": "\\grave"
  },
  "": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "": {
    "text": "\\=",
    "math": "\\bar"
  },
  "": {
    "text": "\\u",
    "math": "\\breve"
  },
  "": {
    "text": "\\v",
    "math": "\\check"
  },
  "": {
    "text": "\\^",
    "math": "\\hat"
  },
  "": {
    "text": "\\.",
    "math": "\\dot"
  },
  "": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "": {
    "text": "\\H"
  },
  "": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "b",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "d",
  "": "d",
  "": "d",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "f",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "j",
  "": "j",
  "": "k",
  "": "k",
  "": "k",
  "": "l",
  "": "l",
  "": "l",
  "": "m",
  "": "m",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "p",
  "": "p",
  "": "r",
  "": "r",
  "": "r",
  "": "r",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "t",
  "": "t",
  "": "t",
  "": "t",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "v",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "x",
  "": "x",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "z",
  "": "z",
  "": "z",
  "": "z",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "B",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "D",
  "": "D",
  "": "D",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "F",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "J",
  "": "K",
  "": "K",
  "": "K",
  "": "L",
  "": "L",
  "": "L",
  "": "M",
  "": "M",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "P",
  "": "P",
  "": "R",
  "": "R",
  "": "R",
  "": "R",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "T",
  "": "T",
  "": "T",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "V",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "X",
  "": "X",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
};
class Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text2, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text2) {
      throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse2 = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse2;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse2 = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse2;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group = this.parseGroup(name);
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text2) {
    var textordArray = [];
    for (var i = 0; i < text2.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text2[i]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base = this.parseGroup("atom", breakOnTokenText);
    if (this.mode === "text") {
      return base;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var isSub = unicodeSubRegEx.test(lex.text);
        var subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        while (true) {
          var token = this.fetch().text;
          if (!uSubsAndSups[token]) {
            break;
          }
          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        var body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i = 0; i < totalArgs; i++) {
      var argType = funcData.argTypes && funcData.argTypes[i];
      var isOptional = i < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group = this.parseGroup(name);
        if (_group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return _group;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex2, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color = match[0];
    if (/^[0-9a-f]{6}$/i.test(color)) {
      color = "#" + color;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text2 = firstToken.text;
    var result;
    if (text2 === "{" || text2 === "\\begingroup") {
      this.consume();
      var groupEnd = text2 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text2 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text2, firstToken);
        }
        result = this.formatUnsupportedCmd(text2);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n = group.length - 1;
    for (var i = 0; i < n; ++i) {
      var a = group[i];
      var v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text2 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text2)) {
      this.consume();
      var arg = text2.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      text2 = unicodeSymbols[text2[0]] + text2.slice(1);
    }
    var match = combiningDiacriticalMarksEndRegex.exec(text2);
    if (match) {
      text2 = text2.substring(0, match.index);
      if (text2 === "i") {
        text2 = "";
      } else if (text2 === "j") {
        text2 = "";
      }
    }
    var symbol;
    if (symbols[this.mode][text2]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text2].group;
      var loc = SourceLocation.range(nucleus);
      var s;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text2
        };
      } else {
        s = {
          type: group,
          mode: this.mode,
          loc,
          text: text2
        };
      }
      symbol = s;
    } else if (text2.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text2.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text2
      };
    } else {
      return null;
    }
    this.consume();
    if (match) {
      for (var i = 0; i < match[0].length; i++) {
        var accent2 = match[0][i];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
}
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser = new Parser(toParse, settings);
  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse();
  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"];
  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token("\\df@tag")])
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options2) {
  baseNode.textContent = "";
  var node = renderToDomTree(expression, options2).toNode();
  baseNode.appendChild(node);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options2) {
  var markup = renderToDomTree(expression, options2).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options2) {
  var settings = new Settings(options2);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error, expression, options2) {
  if (options2.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error.toString());
  node.setAttribute("style", "color:" + options2.errorColor);
  return node;
};
var renderToDomTree = function renderToDomTree2(expression, options2) {
  var settings = new Settings(options2);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options2) {
  var settings = new Settings(options2);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var katex = {
  /**
   * Current KaTeX version
   */
  version: "0.16.10",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};
var findEndOfMath = function findEndOfMath2(delimiter2, text2, startIndex) {
  var index = startIndex;
  var braceLevel = 0;
  var delimLength = delimiter2.length;
  while (index < text2.length) {
    var character = text2[index];
    if (braceLevel <= 0 && text2.slice(index, index + delimLength) === delimiter2) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }
    index++;
  }
  return -1;
};
var escapeRegex = function escapeRegex2(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var amsRegex = /^\\begin{/;
var splitAtDelimiters = function splitAtDelimiters2(text2, delimiters2) {
  var index;
  var data = [];
  var regexLeft = new RegExp("(" + delimiters2.map((x) => escapeRegex(x.left)).join("|") + ")");
  while (true) {
    index = text2.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data.push({
        type: "text",
        data: text2.slice(0, index)
      });
      text2 = text2.slice(index);
    }
    var i = delimiters2.findIndex((delim) => text2.startsWith(delim.left));
    index = findEndOfMath(delimiters2[i].right, text2, delimiters2[i].left.length);
    if (index === -1) {
      break;
    }
    var rawData = text2.slice(0, index + delimiters2[i].right.length);
    var math2 = amsRegex.test(rawData) ? rawData : text2.slice(delimiters2[i].left.length, index);
    data.push({
      type: "math",
      data: math2,
      rawData,
      display: delimiters2[i].display
    });
    text2 = text2.slice(index + delimiters2[i].right.length);
  }
  if (text2 !== "") {
    data.push({
      type: "text",
      data: text2
    });
  }
  return data;
};
var renderMathInText = function renderMathInText2(text2, optionsCopy) {
  var data = splitAtDelimiters(text2, optionsCopy.delimiters);
  if (data.length === 1 && data[0].type === "text") {
    return null;
  }
  var fragment = document.createDocumentFragment();
  for (var i = 0; i < data.length; i++) {
    if (data[i].type === "text") {
      fragment.appendChild(document.createTextNode(data[i].data));
    } else {
      var span = document.createElement("span");
      var math2 = data[i].data;
      optionsCopy.displayMode = data[i].display;
      try {
        if (optionsCopy.preProcess) {
          math2 = optionsCopy.preProcess(math2);
        }
        katex.render(math2, span, optionsCopy);
      } catch (e) {
        if (!(e instanceof katex.ParseError)) {
          throw e;
        }
        optionsCopy.errorCallback("KaTeX auto-render: Failed to parse `" + data[i].data + "` with ", e);
        fragment.appendChild(document.createTextNode(data[i].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }
  return fragment;
};
var renderElem = function renderElem2(elem, optionsCopy) {
  for (var i = 0; i < elem.childNodes.length; i++) {
    var childNode = elem.childNodes[i];
    if (childNode.nodeType === 3) {
      var textContentConcat = childNode.textContent;
      var sibling = childNode.nextSibling;
      var nSiblings = 0;
      while (sibling && sibling.nodeType === Node.TEXT_NODE) {
        textContentConcat += sibling.textContent;
        sibling = sibling.nextSibling;
        nSiblings++;
      }
      var frag = renderMathInText(textContentConcat, optionsCopy);
      if (frag) {
        for (var j = 0; j < nSiblings; j++) {
          childNode.nextSibling.remove();
        }
        i += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      } else {
        i += nSiblings;
      }
    } else if (childNode.nodeType === 1) {
      (function() {
        var className = " " + childNode.className + " ";
        var shouldRender = optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 && optionsCopy.ignoredClasses.every((x) => className.indexOf(" " + x + " ") === -1);
        if (shouldRender) {
          renderElem2(childNode, optionsCopy);
        }
      })();
    }
  }
};
var renderMathInElement = function renderMathInElement2(elem, options2) {
  if (!elem) {
    throw new Error("No element provided to render");
  }
  var optionsCopy = {};
  for (var option in options2) {
    if (options2.hasOwnProperty(option)) {
      optionsCopy[option] = options2[option];
    }
  }
  optionsCopy.delimiters = optionsCopy.delimiters || [
    {
      left: "$$",
      right: "$$",
      display: true
    },
    {
      left: "\\(",
      right: "\\)",
      display: false
    },
    // LaTeX uses $$, but it ruins the display of normal `$` in text:
    // {left: "$", right: "$", display: false},
    // $ must come after $$
    // Render AMS environments even if outside $$$$ delimiters.
    {
      left: "\\begin{equation}",
      right: "\\end{equation}",
      display: true
    },
    {
      left: "\\begin{align}",
      right: "\\end{align}",
      display: true
    },
    {
      left: "\\begin{alignat}",
      right: "\\end{alignat}",
      display: true
    },
    {
      left: "\\begin{gather}",
      right: "\\end{gather}",
      display: true
    },
    {
      left: "\\begin{CD}",
      right: "\\end{CD}",
      display: true
    },
    {
      left: "\\[",
      right: "\\]",
      display: true
    }
  ];
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || ["script", "noscript", "style", "textarea", "pre", "code", "option"];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;
  optionsCopy.macros = optionsCopy.macros || {};
  renderElem(elem, optionsCopy);
};
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
let _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
const escapeTest$1 = /[&<>"']/;
const escapeReplace$1 = new RegExp(escapeTest$1.source, "g");
const escapeTestNoEncode$1 = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode$1 = new RegExp(escapeTestNoEncode$1.source, "g");
const escapeReplacements$1 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement$1 = (ch) => escapeReplacements$1[ch];
function escape$1$1(html2, encode) {
  if (encode) {
    if (escapeTest$1.test(html2)) {
      return html2.replace(escapeReplace$1, getEscapeReplacement$1);
    }
  } else {
    if (escapeTestNoEncode$1.test(html2)) {
      return html2.replace(escapeReplaceNoEncode$1, getEscapeReplacement$1);
    }
  }
  return html2;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html2) {
  return html2.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex2, opt) {
  let source = typeof regex2 === "string" ? regex2 : regex2.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
const noopTest = { exec: () => null };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer) {
  const href = link2.href;
  const title = link2.title ? escape$1$1(link2.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$1$1(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class _Tokenizer {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      list2.items[list2.items.length - 1].raw = raw.trimEnd();
      list2.items[list2.items.length - 1].text = itemContents.trimEnd();
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!/[:|]/.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
    const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (/^ *-+: *$/.test(align)) {
        item.align.push("right");
      } else if (/^ *:-+: *$/.test(align)) {
        item.align.push("center");
      } else if (/^ *:-+ *$/.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (const header of headers) {
      item.header.push({
        text: header,
        tokens: this.lexer.inline(header)
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell)
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$1$1(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape$1$1(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$1$1(cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape$1$1(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src) {
    var _a2;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$1$1(cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = ((_a2 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a2[0]) ?? "";
        } while (prevCapZero !== cap[0]);
        text2 = escape$1$1(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = cap[0];
      } else {
        text2 = escape$1$1(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const newline = /^(?: *(?:\n|$))+/;
const blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
const bullet = /(?:[*+-]|\d{1,9}[.)])/;
const lheading = edit(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).getRegex();
const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
const blockText = /^[^\n]+/;
const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
const def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
const _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
const html$2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
const paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
const blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html: html$2,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
const gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
const blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
const blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
const escape$2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
const br = /^( {2,}|\\)\n(?!\s*$)/;
const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
const _punctuation = "\\p{P}\\p{S}";
const punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
const emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
const emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
const anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
const _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
const tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
const reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
const nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
const reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
const inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$2,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
const inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
const inlineGfm = {
  ...inlineNormal,
  escape: edit(escape$2).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
const inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
const block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
const inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
class _Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer = new _Lexer(options2);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer = new _Lexer(options2);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class _Renderer {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  code(code2, infostring, escaped) {
    var _a2;
    const lang = (_a2 = (infostring || "").match(/^\S*/)) == null ? void 0 : _a2[0];
    code2 = code2.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code2 : escape$1$1(code2, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape$1$1(lang) + '">' + (escaped ? code2 : escape$1$1(code2, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2, block2) {
    return html2;
  }
  heading(text2, level, raw) {
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text2, task, checked) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag2 = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  em(text2) {
    return `<em>${text2}</em>`;
  }
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text2) {
    return `<del>${text2}</del>`;
  }
  link(href, title, text2) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text2;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  image(href, title, text2) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text2;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(text2) {
    return text2;
  }
}
class _TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class _Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser = new _Parser(options2);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser = new _Parser(options2);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j = 0; j < tableToken.header.length; j++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j = 0; j < tableToken.rows.length; j++) {
            const row = tableToken.rows[j];
            cell = "";
            for (let k = 0; k < row.length; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j = 0; j < listToken.items.length; j++) {
            const item = listToken.items[j];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox2 = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox2 + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox2 + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox2 + " "
                  });
                }
              } else {
                itemBody += checkbox2 + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer2) {
    renderer2 = renderer2 || this.renderer;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out += renderer2.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out += renderer2.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out += renderer2.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer2));
          break;
        }
        case "image": {
          const imageToken = token;
          out += renderer2.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out += renderer2.strong(this.parseInline(strongToken.tokens, renderer2));
          break;
        }
        case "em": {
          const emToken = token;
          out += renderer2.em(this.parseInline(emToken.tokens, renderer2));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out += renderer2.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer2.br();
          break;
        }
        case "del": {
          const delToken = token;
          out += renderer2.del(this.parseInline(delToken.tokens, renderer2));
          break;
        }
        case "text": {
          const textToken = token;
          out += renderer2.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class _Hooks {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
}
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
class Marked {
  constructor(...args) {
    __privateAdd(this, _parseMarkdown);
    __privateAdd(this, _onError);
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
    __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a2, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer2 = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer2)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer2[rendererProp];
          renderer2[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer2, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer2, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer2;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens) {
            values = values.concat(walkTokens.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 ?? this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 ?? this.defaults);
  }
}
_parseMarkdown = new WeakSet();
parseMarkdown_fn = function(lexer, parser) {
  return (src, options2) => {
    const origOpt = { ...options2 };
    const opt = { ...this.defaults, ...origOpt };
    if (this.defaults.async === true && origOpt.async === false) {
      if (!opt.silent) {
        console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
      }
      opt.async = true;
    }
    const throwError = __privateMethod(this, _onError, onError_fn).call(this, !!opt.silent, !!opt.async);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      let tokens = lexer(src, opt);
      if (opt.hooks) {
        tokens = opt.hooks.processAllTokens(tokens);
      }
      if (opt.walkTokens) {
        this.walkTokens(tokens, opt.walkTokens);
      }
      let html2 = parser(tokens, opt);
      if (opt.hooks) {
        html2 = opt.hooks.postprocess(html2);
      }
      return html2;
    } catch (e) {
      return throwError(e);
    }
  };
};
_onError = new WeakSet();
onError_fn = function(silent, async) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape$1$1(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    throw e;
  };
};
const markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
function markedHighlight(options2) {
  if (typeof options2 === "function") {
    options2 = {
      highlight: options2
    };
  }
  if (!options2 || typeof options2.highlight !== "function") {
    throw new Error("Must provide highlight function");
  }
  if (typeof options2.langPrefix !== "string") {
    options2.langPrefix = "language-";
  }
  if (typeof options2.emptyLangClass !== "string") {
    options2.emptyLangClass = "";
  }
  return {
    async: !!options2.async,
    walkTokens(token) {
      if (token.type !== "code") {
        return;
      }
      const lang = getLang(token.lang);
      if (options2.async) {
        return Promise.resolve(options2.highlight(token.text, lang, token.lang || "")).then(updateToken(token));
      }
      const code2 = options2.highlight(token.text, lang, token.lang || "");
      if (code2 instanceof Promise) {
        throw new Error("markedHighlight is not set to async but the highlight function is async. Set the async option to true on markedHighlight to await the async highlight function.");
      }
      updateToken(token)(code2);
    },
    useNewRenderer: true,
    renderer: {
      code(code2, infoString, escaped) {
        if (typeof code2 === "object") {
          escaped = code2.escaped;
          infoString = code2.lang;
          code2 = code2.text;
        }
        const lang = getLang(infoString);
        const classValue = lang ? options2.langPrefix + escape$1(lang) : options2.emptyLangClass;
        const classAttr = classValue ? ` class="${classValue}"` : "";
        code2 = code2.replace(/\n$/, "");
        return `<pre><code${classAttr}>${escaped ? code2 : escape$1(code2, true)}
</code></pre>`;
      }
    }
  };
}
function getLang(lang) {
  return (lang || "").match(/\S*/)[0];
}
function updateToken(token) {
  return (code2) => {
    if (typeof code2 === "string" && code2 !== token.text) {
      token.escaped = true;
      token.text = code2;
    }
  };
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$1(html2, encode) {
  if (encode) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
const regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
const own = Object.hasOwnProperty;
class BananaSlug {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences;
    this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(value, maintainCase) {
    const self2 = this;
    let result = slug(value, maintainCase === true);
    const originalSlug = result;
    while (own.call(self2.occurrences, result)) {
      self2.occurrences[originalSlug]++;
      result = originalSlug + "-" + self2.occurrences[originalSlug];
    }
    self2.occurrences[result] = 0;
    return result;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
}
function slug(value, maintainCase) {
  if (typeof value !== "string")
    return "";
  if (!maintainCase)
    value = value.toLowerCase();
  return value.replace(regex, "").replace(/ /g, "-");
}
let slugger$1 = new BananaSlug();
let headings = [];
function gfmHeadingId({ prefix = "", globalSlugs = false } = {}) {
  return {
    headerIds: false,
    // prevent deprecation warning; remove this once headerIds option is removed
    hooks: {
      preprocess(src) {
        if (!globalSlugs) {
          resetHeadings();
        }
        return src;
      }
    },
    renderer: {
      heading(text2, level, raw) {
        raw = raw.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "");
        const id2 = `${prefix}${slugger$1.slug(raw)}`;
        const heading2 = { level, text: text2, id: id2 };
        headings.push(heading2);
        return `<h${level} id="${id2}">${text2}</h${level}>
`;
      }
    }
  };
}
function resetHeadings() {
  headings = [];
  slugger$1 = new BananaSlug();
}
var prism = { exports: {} };
(function(module) {
  var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _ = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode(tokens) {
          if (tokens instanceof Token2) {
            return new Token2(tokens.type, encode(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone2;
          var id2;
          switch (_.util.type(o)) {
            case "Object":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = /** @type {Record<string, any>} */
              {};
              visited[id2] = clone2;
              for (var key in o) {
                if (o.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o[key], visited);
                }
              }
              return (
                /** @type {any} */
                clone2
              );
            case "Array":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = [];
              visited[id2] = clone2;
              /** @type {Array} */
              /** @type {any} */
              o.forEach(function(v, i) {
                clone2[i] = deepClone(v, visited);
              });
              return (
                /** @type {any} */
                clone2
              );
            default:
              return o;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(element2) {
          while (element2) {
            var m = lang.exec(element2.className);
            if (m) {
              return m[1].toLowerCase();
            }
            element2 = element2.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(element2, language) {
          element2.className = element2.className.replace(RegExp(lang, "gi"), "");
          element2.classList.add("language-" + language);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document === "undefined") {
            return null;
          }
          if ("currentScript" in document && 1 < 2) {
            return (
              /** @type {any} */
              document.currentScript
            );
          }
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts) {
                if (scripts[i].src == src) {
                  return scripts[i];
                }
              }
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(element2, className, defaultActivation) {
          var no = "no-" + className;
          while (element2) {
            var classList = element2.classList;
            if (classList.contains(className)) {
              return true;
            }
            if (classList.contains(no)) {
              return false;
            }
            element2 = element2.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id2, redef) {
          var lang2 = _.util.clone(_.languages[id2]);
          for (var key in redef) {
            lang2[key] = redef[key];
          }
          return lang2;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _.languages;
          var grammar = root[inside];
          var ret = {};
          for (var token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }
          var old = root[inside];
          root[inside] = ret;
          _.languages.DFS(_.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              var property = o[i];
              var propertyType = _.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prisms API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(async, callback) {
        _.highlightAllUnder(document, async, callback);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element2; element2 = env.elements[i++]; ) {
          _.highlightElement(element2, async === true, env.callback);
        }
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(element2, async, callback) {
        var language = _.util.getLanguage(element2);
        var grammar = _.languages[language];
        _.util.setLanguage(element2, language);
        var parent = element2.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre") {
          _.util.setLanguage(parent, language);
        }
        var code2 = element2.textContent;
        var env = {
          element: element2,
          language,
          grammar,
          code: code2
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _.hooks.run("after-highlight", env);
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
          parent.setAttribute("tabindex", "0");
        }
        if (!env.code) {
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        }
      },
      /**
       * Low-level function, only use if you know what youre doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _.tokenize(env.code, env.grammar);
        _.hooks.run("after-tokenize", env);
        return Token2.stringify(_.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token in rest) {
            grammar[token] = rest[token];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name, callback) {
          var hooks = _.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name, env) {
          var callbacks = _.hooks.all[name];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i = 0, callback; callback = callbacks[i++]; ) {
            callback(env);
          }
        }
      },
      Token: Token2
    };
    _self2.Prism = _;
    function Token2(type, content, alias, matchedStr) {
      this.type = type;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
    }
    Token2.stringify = function stringify(o, language) {
      if (typeof o == "string") {
        return o;
      }
      if (Array.isArray(o)) {
        var s = "";
        o.forEach(function(e) {
          s += stringify(e, language);
        });
        return s;
      }
      var env = {
        type: o.type,
        content: stringify(o.content, language),
        tag: "span",
        classes: ["token", o.type],
        attributes: {},
        language
      };
      var aliases = o.alias;
      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }
      _.hooks.run("wrap", env);
      var attributes = "";
      for (var name in env.attributes) {
        attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
      }
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text2, lookbehind) {
      pattern.lastIndex = pos;
      var match = pattern.exec(text2);
      if (match && lookbehind && match[1]) {
        var lookbehindLength = match[1].length;
        match.index += lookbehindLength;
        match[0] = match[0].slice(lookbehindLength);
      }
      return match;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }
        var patterns = grammar[token];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token + "," + j) {
            return;
          }
          var patternObj = patterns[j];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token2) {
              continue;
            }
            var removeCount = 1;
            var match;
            if (greedy) {
              match = matchPattern(pattern, pos, text2, lookbehind);
              if (!match || match.index >= text2.length) {
                break;
              }
              var from = match.index;
              var to = match.index + match[0].length;
              var p = pos;
              p += currentNode.value.length;
              while (from >= p) {
                currentNode = currentNode.next;
                p += currentNode.value.length;
              }
              p -= currentNode.value.length;
              pos = p;
              if (currentNode.value instanceof Token2) {
                continue;
              }
              for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                removeCount++;
                p += k.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p);
              match.index -= pos;
            } else {
              match = matchPattern(pattern, 0, str, lookbehind);
              if (!match) {
                continue;
              }
            }
            var from = match.index;
            var matchStr = match[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token2(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token + "," + j,
                reach
              };
              matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = { value: null, prev: null, next: null };
      var tail = { value: null, prev: head, next: null };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list2, node, value) {
      var next = node.next;
      var newNode = { value, prev: node, next };
      node.next = newNode;
      next.prev = newNode;
      list2.length++;
      return newNode;
    }
    function removeRange(list2, node, count) {
      var next = node.next;
      for (var i = 0; i < count && next !== list2.tail; i++) {
        next = next.next;
      }
      node.next = next;
      next.prev = node;
      list2.length -= i;
    }
    function toArray(list2) {
      var array = [];
      var node = list2.head.next;
      while (node !== list2.tail) {
        array.push(node.value);
        node = node.next;
      }
      return array;
    }
    if (!_self2.document) {
      if (!_self2.addEventListener) {
        return _;
      }
      if (!_.disableWorkerMessageHandler) {
        _self2.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code2 = message.code;
          var immediateClose = message.immediateClose;
          _self2.postMessage(_.highlight(code2, _.languages[lang2], lang2));
          if (immediateClose) {
            _self2.close();
          }
        }, false);
      }
      return _;
    }
    var script = _.util.currentScript();
    if (script) {
      _.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _.manual = true;
      }
    }
    function highlightAutomaticallyCallback() {
      if (!_.manual) {
        _.highlightAll();
      }
    }
    if (!_.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
    return _;
  }(_self);
  if (module.exports) {
    module.exports = Prism2;
  }
  if (typeof commonjsGlobal !== "undefined") {
    commonjsGlobal.Prism = Prism2;
  }
  Prism2.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
  Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
  Prism2.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism2.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism2.languages[lang]
      };
      var def2 = {};
      def2[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism2.languages.insertBefore("markup", "cdata", def2);
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang) {
      Prism2.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism2.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism2.languages.html = Prism2.languages.markup;
  Prism2.languages.mathml = Prism2.languages.markup;
  Prism2.languages.svg = Prism2.languages.markup;
  Prism2.languages.xml = Prism2.languages.extend("markup", {});
  Prism2.languages.ssml = Prism2.languages.xml;
  Prism2.languages.atom = Prism2.languages.xml;
  Prism2.languages.rss = Prism2.languages.xml;
  (function(Prism3) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      "comment": /\/\*[\s\S]*?\*\//,
      "atrule": {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          "rule": /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          "keyword": {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
          // See rest below
        }
      },
      "url": {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          "function": /^url/i,
          "punctuation": /^\(|\)$/,
          "string": {
            pattern: RegExp("^" + string.source + "$"),
            alias: "url"
          }
        }
      },
      "selector": {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      "string": {
        pattern: string,
        greedy: true
      },
      "property": {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      "important": /!important\b/i,
      "function": {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      "punctuation": /[(){};:,]/
    };
    Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
    var markup = Prism3.languages.markup;
    if (markup) {
      markup.tag.addInlined("style", "css");
      markup.tag.addAttribute("style", "css");
    }
  })(Prism2);
  Prism2.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
  Prism2.languages.javascript = Prism2.languages.extend("clike", {
    "class-name": [
      Prism2.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism2.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism2.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism2.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism2.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism2.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism2.languages.markup) {
    Prism2.languages.markup.tag.addInlined("script", "javascript");
    Prism2.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    );
  }
  Prism2.languages.js = Prism2.languages.javascript;
  (function() {
    if (typeof Prism2 === "undefined" || typeof document === "undefined") {
      return;
    }
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    var LOADING_MESSAGE = "Loading";
    var FAILURE_MESSAGE = function(status, message) {
      return " Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = " Error: File does not exist or is empty";
    var EXTENSIONS = {
      "js": "javascript",
      "py": "python",
      "rb": "ruby",
      "ps1": "powershell",
      "psm1": "powershell",
      "sh": "bash",
      "bat": "batch",
      "h": "c",
      "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    function loadFile(src, success, error) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            success(xhr.responseText);
          } else {
            if (xhr.status >= 400) {
              error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
            } else {
              error(FAILURE_EMPTY_MESSAGE);
            }
          }
        }
      };
      xhr.send(null);
    }
    function parseRange(range) {
      var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
      if (m) {
        var start = Number(m[1]);
        var comma = m[2];
        var end = m[3];
        if (!comma) {
          return [start, start];
        }
        if (!end) {
          return [start, void 0];
        }
        return [start, Number(end)];
      }
      return void 0;
    }
    Prism2.hooks.add("before-highlightall", function(env) {
      env.selector += ", " + SELECTOR;
    });
    Prism2.hooks.add("before-sanity-check", function(env) {
      var pre = (
        /** @type {HTMLPreElement} */
        env.element
      );
      if (pre.matches(SELECTOR)) {
        env.code = "";
        pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
        var code2 = pre.appendChild(document.createElement("CODE"));
        code2.textContent = LOADING_MESSAGE;
        var src = pre.getAttribute("data-src");
        var language = env.language;
        if (language === "none") {
          var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
          language = EXTENSIONS[extension] || extension;
        }
        Prism2.util.setLanguage(code2, language);
        Prism2.util.setLanguage(pre, language);
        var autoloader = Prism2.plugins.autoloader;
        if (autoloader) {
          autoloader.loadLanguages(language);
        }
        loadFile(
          src,
          function(text2) {
            pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
            var range = parseRange(pre.getAttribute("data-range"));
            if (range) {
              var lines = text2.split(/\r\n?|\n/g);
              var start = range[0];
              var end = range[1] == null ? lines.length : range[1];
              if (start < 0) {
                start += lines.length;
              }
              start = Math.max(0, Math.min(start - 1, lines.length));
              if (end < 0) {
                end += lines.length;
              }
              end = Math.max(0, Math.min(end, lines.length));
              text2 = lines.slice(start, end).join("\n");
              if (!pre.hasAttribute("data-start")) {
                pre.setAttribute("data-start", String(start + 1));
              }
            }
            code2.textContent = text2;
            Prism2.highlightElement(code2);
          },
          function(error) {
            pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
            code2.textContent = error;
          }
        );
      }
    });
    Prism2.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function highlight(container) {
        var elements = (container || document).querySelectorAll(SELECTOR);
        for (var i = 0, element2; element2 = elements[i++]; ) {
          Prism2.highlightElement(element2);
        }
      }
    };
    var logged = false;
    Prism2.fileHighlight = function() {
      if (!logged) {
        console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
        logged = true;
      }
      Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  })();
})(prism);
var prismExports = prism.exports;
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismExports);
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function(Prism2) {
  var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
  var insideEqu = {
    "equation-command": {
      pattern: funcPattern,
      alias: "regex"
    }
  };
  Prism2.languages.latex = {
    "comment": /%.*/,
    // the verbatim environment prints whitespace to the document
    "cdata": {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true
    },
    /*
     * equations can be between $$ $$ or $ $ or \( \) or \[ \]
     * (all are multiline)
     */
    "equation": [
      {
        pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
        inside: insideEqu,
        alias: "string"
      },
      {
        pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
        lookbehind: true,
        inside: insideEqu,
        alias: "string"
      }
    ],
    /*
     * arguments which are keywords or references are highlighted
     * as keywords
     */
    "keyword": {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true
    },
    "url": {
      pattern: /(\\url\{)[^}]+(?=\})/,
      lookbehind: true
    },
    /*
     * section or chapter headlines are highlighted as bold so that
     * they stand out more
     */
    "headline": {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true,
      alias: "class-name"
    },
    "function": {
      pattern: funcPattern,
      alias: "selector"
    },
    "punctuation": /[[\]{}&]/
  };
  Prism2.languages.tex = Prism2.languages.latex;
  Prism2.languages.context = Prism2.languages.latex;
})(Prism);
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not foo {
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (= and +=).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      //  No expansion (so no inside).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // Normal string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
const LINK_ICON_CODE = `<svg class="md-link-icon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true" fill="currentColor"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>`;
const COPY_ICON_CODE = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 15" color="currentColor" aria-hidden="true" aria-label="Copy" stroke-width="1.3" width="15" height="15">
  <path fill="currentColor" d="M12.728 4.545v8.182H4.545V4.545zm0 -0.909H4.545a0.909 0.909 0 0 0 -0.909 0.909v8.182a0.909 0.909 0 0 0 0.909 0.909h8.182a0.909 0.909 0 0 0 0.909 -0.909V4.545a0.909 0.909 0 0 0 -0.909 -0.909"/>
  <path fill="currentColor" d="M1.818 8.182H0.909V1.818a0.909 0.909 0 0 1 0.909 -0.909h6.364v0.909H1.818Z"/>
</svg>

`;
const CHECK_ICON_CODE = `<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 17 17" aria-hidden="true" aria-label="Copied" fill="none" stroke="currentColor" stroke-width="1.3">
  <path d="m13.813 4.781 -7.438 7.438 -3.188 -3.188"/>
</svg>
`;
const COPY_BUTTON_CODE = `<button title="copy" class="copy_code_button">
  <span class="copy-text">${COPY_ICON_CODE}</span>
  <span class="check">${CHECK_ICON_CODE}</span>
</button>`;
const escape_test = /[&<>"']/;
const escape_replace = new RegExp(escape_test.source, "g");
const escape_test_no_encode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escape_replace_no_encode = new RegExp(escape_test_no_encode.source, "g");
const escape_replacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const get_escape_replacement = (ch) => escape_replacements[ch] || "";
function escape(html2, encode) {
  if (encode) {
    if (escape_test.test(html2)) {
      return html2.replace(escape_replace, get_escape_replacement);
    }
  } else {
    if (escape_test_no_encode.test(html2)) {
      return html2.replace(escape_replace_no_encode, get_escape_replacement);
    }
  }
  return html2;
}
function createLatexTokenizer(delimiters2) {
  const delimiterPatterns = delimiters2.map((delimiter2) => ({
    start: new RegExp(delimiter2.left.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")),
    end: new RegExp(delimiter2.right.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"))
  }));
  return {
    name: "latex",
    level: "block",
    start(src) {
      for (const pattern of delimiterPatterns) {
        const match = src.match(pattern.start);
        if (match) {
          return match.index;
        }
      }
      return -1;
    },
    tokenizer(src, tokens) {
      for (const pattern of delimiterPatterns) {
        const match = new RegExp(
          `${pattern.start.source}([\\s\\S]+?)${pattern.end.source}`
        ).exec(src);
        if (match) {
          return {
            type: "latex",
            raw: match[0],
            text: match[1].trim()
          };
        }
      }
    },
    renderer(token) {
      return `<div class="latex-block">${token.text}</div>`;
    }
  };
}
const renderer = {
  code(code2, infostring, escaped) {
    var _a2;
    const lang = ((_a2 = (infostring ?? "").match(/\S*/)) == null ? void 0 : _a2[0]) ?? "";
    code2 = code2.replace(/\n$/, "") + "\n";
    if (!lang) {
      return '<div class="code_wrap">' + COPY_BUTTON_CODE + "<pre><code>" + (escaped ? code2 : escape(code2, true)) + "</code></pre></div>\n";
    }
    return '<div class="code_wrap">' + COPY_BUTTON_CODE + '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code2 : escape(code2, true)) + "</code></pre></div>\n";
  }
};
const slugger = new BananaSlug();
function create_marked({
  header_links,
  line_breaks,
  latex_delimiters
}) {
  const marked2 = new Marked();
  marked2.use(
    {
      gfm: true,
      pedantic: false,
      breaks: line_breaks
    },
    markedHighlight({
      highlight: (code2, lang) => {
        if (prismExports.languages[lang]) {
          return prismExports.highlight(code2, prismExports.languages[lang], lang);
        }
        return code2;
      }
    }),
    { renderer }
  );
  if (header_links) {
    marked2.use(gfmHeadingId());
    marked2.use({
      extensions: [
        {
          name: "heading",
          level: "block",
          renderer(token) {
            const raw = token.raw.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "");
            const id2 = "h" + slugger.slug(raw);
            const level = token.depth;
            const text2 = this.parser.parseInline(token.tokens);
            return `<h${level} id="${id2}"><a class="md-header-anchor" href="#${id2}">${LINK_ICON_CODE}</a>${text2}</h${level}>
`;
          }
        }
      ]
    });
  }
  const latexTokenizer = createLatexTokenizer(latex_delimiters);
  marked2.use({
    extensions: [latexTokenizer]
  });
  return marked2;
}
const cloneDeep = (value) => {
  return JSON.parse(JSON.stringify(value));
};
const isElement = (value) => {
  return value.nodeType === 1;
};
const isElementFunky = (value) => {
  return FUNKY_TAG_NAMES.has(value.tagName);
};
const isElementAction = (value) => {
  return "action" in value;
};
const isElementIframe = (value) => {
  return value.tagName === "IFRAME";
};
const isElementFormAction = (value) => {
  return "formAction" in value;
};
const isElementHyperlink = (value) => {
  return "protocol" in value;
};
const isScriptOrDataUrl = /* @__PURE__ */ (() => {
  const re = /^(?:\w+script|data):/i;
  return (url) => {
    return re.test(url);
  };
})();
const isScriptOrDataUrlLoose = /* @__PURE__ */ (() => {
  const re = /(?:script|data):/i;
  return (url) => {
    return re.test(url);
  };
})();
const mergeMaps = (maps) => {
  const merged = {};
  for (let i = 0, l = maps.length; i < l; i++) {
    const map = maps[i];
    for (const key in map) {
      if (!merged[key]) {
        merged[key] = map[key];
      } else {
        merged[key] = merged[key].concat(map[key]);
      }
    }
  }
  return merged;
};
const traverseElementsBasic = (parent, callback) => {
  let current2 = parent.firstChild;
  while (current2) {
    const next = current2.nextSibling;
    if (isElement(current2)) {
      callback(current2, parent);
      if (current2.parentNode) {
        traverseElementsBasic(current2, callback);
      }
    }
    current2 = next;
  }
};
const traverseElementsIterator = (parent, callback) => {
  const iterator = document.createNodeIterator(parent, NodeFilter.SHOW_ELEMENT);
  let current2;
  while (current2 = iterator.nextNode()) {
    const parent2 = current2.parentNode;
    if (!parent2)
      continue;
    callback(current2, parent2);
  }
};
const traverseElements = (parent, callback) => {
  const hasIterator = !!globalThis.document && !!globalThis.document.createNodeIterator;
  if (hasIterator) {
    return traverseElementsIterator(parent, callback);
  } else {
    return traverseElementsBasic(parent, callback);
  }
};
const HTML_ELEMENTS_ALLOW = [
  "a",
  "abbr",
  "acronym",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "nav",
  "nobr",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "popup",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "section",
  "select",
  "selectmenu",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
const HTML_ELEMENTS_DISALLOW = [
  "basefont",
  "command",
  "data",
  "iframe",
  "image",
  "plaintext",
  "portal",
  "slot",
  // 'template', //TODO: Not exactly correct to never allow this, too strict
  "textarea",
  "title",
  "xmp"
];
const HTML_ELEMENTS = /* @__PURE__ */ new Set([
  ...HTML_ELEMENTS_ALLOW,
  ...HTML_ELEMENTS_DISALLOW
]);
const SVG_ELEMENTS_ALLOW = [
  "svg",
  "a",
  "altglyph",
  "altglyphdef",
  "altglyphitem",
  "animatecolor",
  "animatemotion",
  "animatetransform",
  "circle",
  "clippath",
  "defs",
  "desc",
  "ellipse",
  "filter",
  "font",
  "g",
  "glyph",
  "glyphref",
  "hkern",
  "image",
  "line",
  "lineargradient",
  "marker",
  "mask",
  "metadata",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialgradient",
  "rect",
  "stop",
  "style",
  "switch",
  "symbol",
  "text",
  "textpath",
  "title",
  "tref",
  "tspan",
  "view",
  "vkern",
  /* FILTERS */
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence"
];
const SVG_ELEMENTS_DISALLOW = [
  "animate",
  "color-profile",
  "cursor",
  "discard",
  "fedropshadow",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignobject",
  "hatch",
  "hatchpath",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "missing-glyph",
  "script",
  "set",
  "solidcolor",
  "unknown",
  "use"
];
const SVG_ELEMENTS = /* @__PURE__ */ new Set([
  ...SVG_ELEMENTS_ALLOW,
  ...SVG_ELEMENTS_DISALLOW
]);
const MATH_ELEMENTS_ALLOW = [
  "math",
  "menclose",
  "merror",
  "mfenced",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msup",
  "msubsup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover"
];
const MATH_ELEMENTS_DISALLOW = [
  "maction",
  "maligngroup",
  "malignmark",
  "mlongdiv",
  "mscarries",
  "mscarry",
  "msgroup",
  "mstack",
  "msline",
  "msrow",
  "semantics",
  "annotation",
  "annotation-xml",
  "mprescripts",
  "none"
];
const MATH_ELEMENTS = /* @__PURE__ */ new Set([
  ...MATH_ELEMENTS_ALLOW,
  ...MATH_ELEMENTS_DISALLOW
]);
const HTML_ATTRIBUTES_ALLOW = [
  "abbr",
  "accept",
  "accept-charset",
  "accesskey",
  "action",
  "align",
  "alink",
  "allow",
  "allowfullscreen",
  "alt",
  "anchor",
  "archive",
  "as",
  "async",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autopictureinpicture",
  "autoplay",
  "axis",
  "background",
  "behavior",
  "bgcolor",
  "border",
  "bordercolor",
  "capture",
  "cellpadding",
  "cellspacing",
  "challenge",
  "char",
  "charoff",
  "charset",
  "checked",
  "cite",
  "class",
  "classid",
  "clear",
  "code",
  "codebase",
  "codetype",
  "color",
  "cols",
  "colspan",
  "compact",
  "content",
  "contenteditable",
  "controls",
  "controlslist",
  "conversiondestination",
  "coords",
  "crossorigin",
  "csp",
  "data",
  "datetime",
  "declare",
  "decoding",
  "default",
  "defer",
  "dir",
  "direction",
  "dirname",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "disallowdocumentaccess",
  "download",
  "draggable",
  "elementtiming",
  "enctype",
  "end",
  "enterkeyhint",
  "event",
  "exportparts",
  "face",
  "for",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "frame",
  "frameborder",
  "headers",
  "height",
  "hidden",
  "high",
  "href",
  "hreflang",
  "hreftranslate",
  "hspace",
  "http-equiv",
  "id",
  "imagesizes",
  "imagesrcset",
  "importance",
  "impressiondata",
  "impressionexpiry",
  "incremental",
  "inert",
  "inputmode",
  "integrity",
  "invisible",
  "ismap",
  "keytype",
  "kind",
  "label",
  "lang",
  "language",
  "latencyhint",
  "leftmargin",
  "link",
  "list",
  "loading",
  "longdesc",
  "loop",
  "low",
  "lowsrc",
  "manifest",
  "marginheight",
  "marginwidth",
  "max",
  "maxlength",
  "mayscript",
  "media",
  "method",
  "min",
  "minlength",
  "multiple",
  "muted",
  "name",
  "nohref",
  "nomodule",
  "nonce",
  "noresize",
  "noshade",
  "novalidate",
  "nowrap",
  "object",
  "open",
  "optimum",
  "part",
  "pattern",
  "ping",
  "placeholder",
  "playsinline",
  "policy",
  "poster",
  "preload",
  "pseudo",
  "readonly",
  "referrerpolicy",
  "rel",
  "reportingorigin",
  "required",
  "resources",
  "rev",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "rules",
  "sandbox",
  "scheme",
  "scope",
  "scopes",
  "scrollamount",
  "scrolldelay",
  "scrolling",
  "select",
  "selected",
  "shadowroot",
  "shadowrootdelegatesfocus",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "src",
  "srclang",
  "srcset",
  "standby",
  "start",
  "step",
  "style",
  "summary",
  "tabindex",
  "target",
  "text",
  "title",
  "topmargin",
  "translate",
  "truespeed",
  "trusttoken",
  "type",
  "usemap",
  "valign",
  "value",
  "valuetype",
  "version",
  "virtualkeyboardpolicy",
  "vlink",
  "vspace",
  "webkitdirectory",
  "width",
  "wrap"
];
const SVG_ATTRIBUTES_ALLOW = [
  "accent-height",
  "accumulate",
  "additive",
  "alignment-baseline",
  "ascent",
  "attributename",
  "attributetype",
  "azimuth",
  "basefrequency",
  "baseline-shift",
  "begin",
  "bias",
  "by",
  "class",
  "clip",
  "clippathunits",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "diffuseconstant",
  "direction",
  "display",
  "divisor",
  "dominant-baseline",
  "dur",
  "edgemode",
  "elevation",
  "end",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "filterunits",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyph-name",
  "glyphref",
  "gradientunits",
  "gradienttransform",
  "height",
  "href",
  "id",
  "image-rendering",
  "in",
  "in2",
  "k",
  "k1",
  "k2",
  "k3",
  "k4",
  "kerning",
  "keypoints",
  "keysplines",
  "keytimes",
  "lang",
  "lengthadjust",
  "letter-spacing",
  "kernelmatrix",
  "kernelunitlength",
  "lighting-color",
  "local",
  "marker-end",
  "marker-mid",
  "marker-start",
  "markerheight",
  "markerunits",
  "markerwidth",
  "maskcontentunits",
  "maskunits",
  "max",
  "mask",
  "media",
  "method",
  "mode",
  "min",
  "name",
  "numoctaves",
  "offset",
  "operator",
  "opacity",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "paint-order",
  "path",
  "pathlength",
  "patterncontentunits",
  "patterntransform",
  "patternunits",
  "points",
  "preservealpha",
  "preserveaspectratio",
  "primitiveunits",
  "r",
  "rx",
  "ry",
  "radius",
  "refx",
  "refy",
  "repeatcount",
  "repeatdur",
  "restart",
  "result",
  "rotate",
  "scale",
  "seed",
  "shape-rendering",
  "specularconstant",
  "specularexponent",
  "spreadmethod",
  "startoffset",
  "stddeviation",
  "stitchtiles",
  "stop-color",
  "stop-opacity",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke",
  "stroke-width",
  "style",
  "surfacescale",
  "systemlanguage",
  "tabindex",
  "targetx",
  "targety",
  "transform",
  "transform-origin",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "textlength",
  "type",
  "u1",
  "u2",
  "unicode",
  "values",
  "viewbox",
  "visibility",
  "version",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "width",
  "word-spacing",
  "wrap",
  "writing-mode",
  "xchannelselector",
  "ychannelselector",
  "x",
  "x1",
  "x2",
  "xmlns",
  "y",
  "y1",
  "y2",
  "z",
  "zoomandpan"
];
const MATH_ATTRIBUTES_ALLOW = [
  "accent",
  "accentunder",
  "align",
  "bevelled",
  "close",
  "columnsalign",
  "columnlines",
  "columnspan",
  "denomalign",
  "depth",
  "dir",
  "display",
  "displaystyle",
  "encoding",
  "fence",
  "frame",
  "height",
  "href",
  "id",
  "largeop",
  "length",
  "linethickness",
  "lspace",
  "lquote",
  "mathbackground",
  "mathcolor",
  "mathsize",
  "mathvariant",
  "maxsize",
  "minsize",
  "movablelimits",
  "notation",
  "numalign",
  "open",
  "rowalign",
  "rowlines",
  "rowspacing",
  "rowspan",
  "rspace",
  "rquote",
  "scriptlevel",
  "scriptminsize",
  "scriptsizemultiplier",
  "selection",
  "separator",
  "separators",
  "stretchy",
  "subscriptshift",
  "supscriptshift",
  "symmetric",
  "voffset",
  "width",
  "xmlns"
];
const NAMESPACES = {
  HTML: "http://www.w3.org/1999/xhtml",
  SVG: "http://www.w3.org/2000/svg",
  MATH: "http://www.w3.org/1998/Math/MathML"
};
const NAMESPACES_ELEMENTS = {
  [NAMESPACES.HTML]: HTML_ELEMENTS,
  [NAMESPACES.SVG]: SVG_ELEMENTS,
  [NAMESPACES.MATH]: MATH_ELEMENTS
};
const NAMESPACES_ROOTS = {
  [NAMESPACES.HTML]: "html",
  [NAMESPACES.SVG]: "svg",
  [NAMESPACES.MATH]: "math"
};
const NAMESPACES_PREFIXES = {
  [NAMESPACES.HTML]: "",
  [NAMESPACES.SVG]: "svg:",
  [NAMESPACES.MATH]: "math:"
};
const FUNKY_TAG_NAMES = /* @__PURE__ */ new Set([
  "A",
  "AREA",
  "BUTTON",
  "FORM",
  "IFRAME",
  "INPUT"
]);
const DEFAULTS = {
  allowComments: true,
  allowCustomElements: false,
  allowUnknownMarkup: false,
  allowElements: [
    ...HTML_ELEMENTS_ALLOW,
    ...SVG_ELEMENTS_ALLOW.map((name) => `svg:${name}`),
    ...MATH_ELEMENTS_ALLOW.map((name) => `math:${name}`)
  ],
  allowAttributes: mergeMaps([
    Object.fromEntries(HTML_ATTRIBUTES_ALLOW.map((name) => [name, ["*"]])),
    Object.fromEntries(SVG_ATTRIBUTES_ALLOW.map((name) => [name, ["svg:*"]])),
    Object.fromEntries(MATH_ATTRIBUTES_ALLOW.map((name) => [name, ["math:*"]]))
  ])
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Amuchina_configuration, _Amuchina_allowElements, _Amuchina_allowAttributes;
class Amuchina {
  /* CONSTRUCTOR */
  constructor(configuration = {}) {
    _Amuchina_configuration.set(this, void 0);
    _Amuchina_allowElements.set(this, void 0);
    _Amuchina_allowAttributes.set(this, void 0);
    this.getConfiguration = () => {
      return cloneDeep(__classPrivateFieldGet(this, _Amuchina_configuration, "f"));
    };
    this.sanitize = (input) => {
      const allowElements2 = __classPrivateFieldGet(this, _Amuchina_allowElements, "f");
      const allowAttributes2 = __classPrivateFieldGet(this, _Amuchina_allowAttributes, "f");
      traverseElements(input, (node, parent) => {
        const namespace = node.namespaceURI || NAMESPACES.HTML;
        const namespaceParent = parent["namespaceURI"] || NAMESPACES.HTML;
        const elements = NAMESPACES_ELEMENTS[namespace];
        const root = NAMESPACES_ROOTS[namespace];
        const prefix = NAMESPACES_PREFIXES[namespace];
        const tag2 = node.tagName.toLowerCase();
        const tagPrefixed = `${prefix}${tag2}`;
        const all = "*";
        const allPrefixed = `${prefix}${all}`;
        if (!elements.has(tag2) || !allowElements2.has(tagPrefixed) || namespace !== namespaceParent && tag2 !== root) {
          parent.removeChild(node);
        } else {
          const attributes = node.getAttributeNames();
          const attributesLength = attributes.length;
          if (attributesLength) {
            for (let i = 0; i < attributesLength; i++) {
              const attribute = attributes[i];
              const allowedValues = allowAttributes2[attribute];
              if (!allowedValues || !allowedValues.has(allPrefixed) && !allowedValues.has(tagPrefixed)) {
                node.removeAttribute(attribute);
              }
            }
            if (isElementFunky(node)) {
              if (isElementHyperlink(node)) {
                const href = node.getAttribute("href");
                if (href && isScriptOrDataUrlLoose(href) && isScriptOrDataUrl(node.protocol)) {
                  node.removeAttribute("href");
                }
              } else if (isElementAction(node)) {
                if (isScriptOrDataUrl(node.action)) {
                  node.removeAttribute("action");
                }
              } else if (isElementFormAction(node)) {
                if (isScriptOrDataUrl(node.formAction)) {
                  node.removeAttribute("formaction");
                }
              } else if (isElementIframe(node)) {
                if (isScriptOrDataUrl(node.src)) {
                  node.removeAttribute("formaction");
                }
                node.setAttribute("sandbox", "allow-scripts");
              }
            }
          }
        }
      });
      return input;
    };
    this.sanitizeFor = (element2, input) => {
      throw new Error('"sanitizeFor" is not implemented yet');
    };
    const { allowComments, allowCustomElements, allowUnknownMarkup, blockElements, dropElements, dropAttributes } = configuration;
    if (allowComments === false)
      throw new Error('A false "allowComments" is not supported yet');
    if (allowCustomElements)
      throw new Error('A true "allowCustomElements" is not supported yet');
    if (allowUnknownMarkup)
      throw new Error('A true "allowUnknownMarkup" is not supported yet');
    if (blockElements)
      throw new Error('"blockElements" is not supported yet, use "allowElements" instead');
    if (dropElements)
      throw new Error('"dropElements" is not supported yet, use "allowElements" instead');
    if (dropAttributes)
      throw new Error('"dropAttributes" is not supported yet, use "allowAttributes" instead');
    __classPrivateFieldSet(this, _Amuchina_configuration, cloneDeep(DEFAULTS), "f");
    const { allowElements, allowAttributes } = configuration;
    if (allowElements)
      __classPrivateFieldGet(this, _Amuchina_configuration, "f").allowElements = configuration.allowElements;
    if (allowAttributes)
      __classPrivateFieldGet(this, _Amuchina_configuration, "f").allowAttributes = configuration.allowAttributes;
    __classPrivateFieldSet(this, _Amuchina_allowElements, new Set(__classPrivateFieldGet(this, _Amuchina_configuration, "f").allowElements), "f");
    __classPrivateFieldSet(this, _Amuchina_allowAttributes, Object.fromEntries(Object.entries(__classPrivateFieldGet(this, _Amuchina_configuration, "f").allowAttributes || {}).map(([element2, attributes]) => [element2, new Set(attributes)])), "f");
  }
}
_Amuchina_configuration = /* @__PURE__ */ new WeakMap(), _Amuchina_allowElements = /* @__PURE__ */ new WeakMap(), _Amuchina_allowAttributes = /* @__PURE__ */ new WeakMap();
Amuchina.getDefaultConfiguration = () => {
  return cloneDeep(DEFAULTS);
};
const is_external_url = (link2, root) => {
  try {
    return !!link2 && new URL(link2).origin !== new URL(root).origin;
  } catch (e) {
    return false;
  }
};
function sanitize(source, root) {
  const amuchina = new Amuchina();
  const node = new DOMParser().parseFromString(source, "text/html");
  walk_nodes(node.body, "A", (node2) => {
    if (node2 instanceof HTMLElement && "target" in node2) {
      if (is_external_url(node2.getAttribute("href"), root)) {
        node2.setAttribute("target", "_blank");
        node2.setAttribute("rel", "noopener noreferrer");
      }
    }
  });
  return amuchina.sanitize(node).body.innerHTML;
}
function walk_nodes(node, test, callback) {
  if (node && (node.nodeName === test || typeof test === "function")) {
    callback(node);
  }
  const children2 = (node == null ? void 0 : node.childNodes) || [];
  for (let i = 0; i < children2.length; i++) {
    walk_nodes(children2[i], test, callback);
  }
}
function create_fragment$w(ctx) {
  let span;
  let html_tag;
  return {
    c() {
      span = element("span");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      html_tag = claim_html_tag(span_nodes, false);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = null;
      attr(span, "class", "md svelte-7ddecg");
      toggle_class(
        span,
        "chatbot",
        /*chatbot*/
        ctx[0]
      );
      toggle_class(
        span,
        "prose",
        /*render_markdown*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      html_tag.m(
        /*html*/
        ctx[3],
        span
      );
      ctx[10](span);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*html*/
      8)
        html_tag.p(
          /*html*/
          ctx2[3]
        );
      if (dirty & /*chatbot*/
      1) {
        toggle_class(
          span,
          "chatbot",
          /*chatbot*/
          ctx2[0]
        );
      }
      if (dirty & /*render_markdown*/
      2) {
        toggle_class(
          span,
          "prose",
          /*render_markdown*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      ctx[10](null);
    }
  };
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function instance$o($$self, $$props, $$invalidate) {
  let { chatbot = true } = $$props;
  let { message } = $$props;
  let { sanitize_html = true } = $$props;
  let { latex_delimiters = [] } = $$props;
  let { render_markdown = true } = $$props;
  let { line_breaks = true } = $$props;
  let { header_links = false } = $$props;
  let { root } = $$props;
  let el;
  let html2;
  const marked2 = create_marked({
    header_links,
    line_breaks,
    latex_delimiters
  });
  function process_message(value) {
    let parsedValue = value;
    if (render_markdown) {
      const latexBlocks = [];
      latex_delimiters.forEach((delimiter2, index) => {
        const leftDelimiter = escapeRegExp(delimiter2.left);
        const rightDelimiter = escapeRegExp(delimiter2.right);
        const regex2 = new RegExp(`${leftDelimiter}([\\s\\S]+?)${rightDelimiter}`, "g");
        parsedValue = parsedValue.replace(regex2, (match, p1) => {
          latexBlocks.push(match);
          return `%%%LATEX_BLOCK_${latexBlocks.length - 1}%%%`;
        });
      });
      parsedValue = marked2.parse(parsedValue);
      parsedValue = parsedValue.replace(/%%%LATEX_BLOCK_(\d+)%%%/g, (match, p1) => latexBlocks[parseInt(p1, 10)]);
    }
    if (sanitize_html && sanitize) {
      parsedValue = sanitize(parsedValue, root);
    }
    return parsedValue;
  }
  async function render_html(value) {
    if (latex_delimiters.length > 0 && value) {
      const containsDelimiter = latex_delimiters.some((delimiter2) => value.includes(delimiter2.left) && value.includes(delimiter2.right));
      if (containsDelimiter) {
        renderMathInElement(el, {
          delimiters: latex_delimiters,
          throwOnError: false
        });
      }
    }
  }
  afterUpdate(async () => {
    if (el && document.body.contains(el)) {
      await render_html(message);
    } else {
      console.error("Element is not in the DOM");
    }
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("chatbot" in $$props2)
      $$invalidate(0, chatbot = $$props2.chatbot);
    if ("message" in $$props2)
      $$invalidate(4, message = $$props2.message);
    if ("sanitize_html" in $$props2)
      $$invalidate(5, sanitize_html = $$props2.sanitize_html);
    if ("latex_delimiters" in $$props2)
      $$invalidate(6, latex_delimiters = $$props2.latex_delimiters);
    if ("render_markdown" in $$props2)
      $$invalidate(1, render_markdown = $$props2.render_markdown);
    if ("line_breaks" in $$props2)
      $$invalidate(7, line_breaks = $$props2.line_breaks);
    if ("header_links" in $$props2)
      $$invalidate(8, header_links = $$props2.header_links);
    if ("root" in $$props2)
      $$invalidate(9, root = $$props2.root);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*message*/
    16) {
      if (message && message.trim()) {
        $$invalidate(3, html2 = process_message(message));
      } else {
        $$invalidate(3, html2 = "");
      }
    }
  };
  return [
    chatbot,
    render_markdown,
    el,
    html2,
    message,
    sanitize_html,
    latex_delimiters,
    line_breaks,
    header_links,
    root,
    span_binding
  ];
}
class MarkdownCode extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$o, create_fragment$w, safe_not_equal, {
      chatbot: 0,
      message: 4,
      sanitize_html: 5,
      latex_delimiters: 6,
      render_markdown: 1,
      line_breaks: 7,
      header_links: 8,
      root: 9
    });
  }
}
function create_fragment$v(ctx) {
  let div;
  let markdown;
  let current2;
  markdown = new MarkdownCode({
    props: {
      root: (
        /*root*/
        ctx[1]
      ),
      message: (
        /*info*/
        ctx[0]
      ),
      sanitize_html: true
    }
  });
  return {
    c() {
      div = element("div");
      create_component(markdown.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(markdown.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "svelte-j9uq24");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(markdown, div, null);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const markdown_changes = {};
      if (dirty & /*root*/
      2)
        markdown_changes.root = /*root*/
        ctx2[1];
      if (dirty & /*info*/
      1)
        markdown_changes.message = /*info*/
        ctx2[0];
      markdown.$set(markdown_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(markdown.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(markdown.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(markdown);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { info } = $$props;
  let { root } = $$props;
  $$self.$$set = ($$props2) => {
    if ("info" in $$props2)
      $$invalidate(0, info = $$props2.info);
    if ("root" in $$props2)
      $$invalidate(1, root = $$props2.root);
  };
  return [info, root];
}
let Info$1 = class Info extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$n, create_fragment$v, safe_not_equal, { info: 0, root: 1 });
  }
};
function create_if_block$i(ctx) {
  let info_1;
  let current2;
  info_1 = new Info$1({
    props: {
      root: (
        /*root*/
        ctx[2]
      ),
      info: (
        /*info*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(info_1.$$.fragment);
    },
    l(nodes) {
      claim_component(info_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(info_1, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const info_1_changes = {};
      if (dirty & /*root*/
      4)
        info_1_changes.root = /*root*/
        ctx2[2];
      if (dirty & /*info*/
      2)
        info_1_changes.info = /*info*/
        ctx2[1];
      info_1.$set(info_1_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(info_1.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(info_1.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(info_1, detaching);
    }
  };
}
function create_fragment$u(ctx) {
  let span;
  let t;
  let if_block_anchor;
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let if_block = (
    /*info*/
    ctx[1] && create_if_block$i(ctx)
  );
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { "data-testid": true, class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      attr(span, "data-testid", "block-info");
      attr(span, "class", "svelte-1gfkn6j");
      toggle_class(span, "sr-only", !/*show_label*/
      ctx[0]);
      toggle_class(span, "hide", !/*show_label*/
      ctx[0]);
      toggle_class(
        span,
        "has-info",
        /*info*/
        ctx[1] != null
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      insert_hydration(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*show_label*/
      1) {
        toggle_class(span, "sr-only", !/*show_label*/
        ctx2[0]);
      }
      if (!current2 || dirty & /*show_label*/
      1) {
        toggle_class(span, "hide", !/*show_label*/
        ctx2[0]);
      }
      if (!current2 || dirty & /*info*/
      2) {
        toggle_class(
          span,
          "has-info",
          /*info*/
          ctx2[1] != null
        );
      }
      if (
        /*info*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*info*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t);
        detach(if_block_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { show_label = true } = $$props;
  let { info = void 0 } = $$props;
  let { root } = $$props;
  $$self.$$set = ($$props2) => {
    if ("show_label" in $$props2)
      $$invalidate(0, show_label = $$props2.show_label);
    if ("info" in $$props2)
      $$invalidate(1, info = $$props2.info);
    if ("root" in $$props2)
      $$invalidate(2, root = $$props2.root);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [show_label, info, root, $$scope, slots];
}
class BlockTitle extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$m, create_fragment$u, safe_not_equal, { show_label: 0, info: 1, root: 2 });
  }
}
function create_if_block$h(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text$3(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*label*/
        ctx[1]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "svelte-1h72pol");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      2)
        set_data(
          t,
          /*label*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$t(ctx) {
  let button;
  let t0;
  let div;
  let switch_instance;
  let t1;
  let current2;
  let mounted;
  let dispose;
  let if_block = (
    /*show_label*/
    ctx[2] && create_if_block$h(ctx)
  );
  var switch_value = (
    /*Icon*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        "aria-haspopup": true,
        title: true,
        class: true
      });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t0 = claim_space(button_nodes);
      div = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "svelte-1h72pol");
      toggle_class(
        div,
        "small",
        /*size*/
        ctx[4] === "small"
      );
      toggle_class(
        div,
        "large",
        /*size*/
        ctx[4] === "large"
      );
      toggle_class(
        div,
        "medium",
        /*size*/
        ctx[4] === "medium"
      );
      button.disabled = /*disabled*/
      ctx[7];
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[1]
      );
      attr(
        button,
        "aria-haspopup",
        /*hasPopup*/
        ctx[8]
      );
      attr(
        button,
        "title",
        /*label*/
        ctx[1]
      );
      attr(button, "class", "svelte-1h72pol");
      toggle_class(
        button,
        "pending",
        /*pending*/
        ctx[3]
      );
      toggle_class(
        button,
        "padded",
        /*padded*/
        ctx[5]
      );
      toggle_class(
        button,
        "highlight",
        /*highlight*/
        ctx[6]
      );
      toggle_class(
        button,
        "transparent",
        /*transparent*/
        ctx[9]
      );
      set_style(button, "color", !/*disabled*/
      ctx[7] && /*_color*/
      ctx[11] ? (
        /*_color*/
        ctx[11]
      ) : "var(--block-label-text-color)");
      set_style(button, "--bg-color", !/*disabled*/
      ctx[7] ? (
        /*background*/
        ctx[10]
      ) : "auto");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration(button, t0);
      append_hydration(button, div);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append_hydration(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[15]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*show_label*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$h(ctx2);
          if_block.c();
          if_block.m(button, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*Icon*/
      1 && switch_value !== (switch_value = /*Icon*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t1);
        } else {
          switch_instance = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*size*/
      16) {
        toggle_class(
          div,
          "small",
          /*size*/
          ctx2[4] === "small"
        );
      }
      if (!current2 || dirty & /*size*/
      16) {
        toggle_class(
          div,
          "large",
          /*size*/
          ctx2[4] === "large"
        );
      }
      if (!current2 || dirty & /*size*/
      16) {
        toggle_class(
          div,
          "medium",
          /*size*/
          ctx2[4] === "medium"
        );
      }
      if (!current2 || dirty & /*disabled*/
      128) {
        button.disabled = /*disabled*/
        ctx2[7];
      }
      if (!current2 || dirty & /*label*/
      2) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[1]
        );
      }
      if (!current2 || dirty & /*hasPopup*/
      256) {
        attr(
          button,
          "aria-haspopup",
          /*hasPopup*/
          ctx2[8]
        );
      }
      if (!current2 || dirty & /*label*/
      2) {
        attr(
          button,
          "title",
          /*label*/
          ctx2[1]
        );
      }
      if (!current2 || dirty & /*pending*/
      8) {
        toggle_class(
          button,
          "pending",
          /*pending*/
          ctx2[3]
        );
      }
      if (!current2 || dirty & /*padded*/
      32) {
        toggle_class(
          button,
          "padded",
          /*padded*/
          ctx2[5]
        );
      }
      if (!current2 || dirty & /*highlight*/
      64) {
        toggle_class(
          button,
          "highlight",
          /*highlight*/
          ctx2[6]
        );
      }
      if (!current2 || dirty & /*transparent*/
      512) {
        toggle_class(
          button,
          "transparent",
          /*transparent*/
          ctx2[9]
        );
      }
      if (dirty & /*disabled, _color*/
      2176) {
        set_style(button, "color", !/*disabled*/
        ctx2[7] && /*_color*/
        ctx2[11] ? (
          /*_color*/
          ctx2[11]
        ) : "var(--block-label-text-color)");
      }
      if (dirty & /*disabled, background*/
      1152) {
        set_style(button, "--bg-color", !/*disabled*/
        ctx2[7] ? (
          /*background*/
          ctx2[10]
        ) : "auto");
      }
    },
    i(local) {
      if (current2)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      if (switch_instance)
        destroy_component(switch_instance);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let _color;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { Icon } = $$props;
  let { label: label2 = "" } = $$props;
  let { show_label = false } = $$props;
  let { pending = false } = $$props;
  let { size = "small" } = $$props;
  let { padded = true } = $$props;
  let { highlight = false } = $$props;
  let { disabled = false } = $$props;
  let { hasPopup = false } = $$props;
  let { color = "var(--block-label-text-color)" } = $$props;
  let { transparent = false } = $$props;
  let { background = "var(--block-background-fill)" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("Icon" in $$props2)
      $$invalidate(0, Icon = $$props2.Icon);
    if ("label" in $$props2)
      $$invalidate(1, label2 = $$props2.label);
    if ("show_label" in $$props2)
      $$invalidate(2, show_label = $$props2.show_label);
    if ("pending" in $$props2)
      $$invalidate(3, pending = $$props2.pending);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("padded" in $$props2)
      $$invalidate(5, padded = $$props2.padded);
    if ("highlight" in $$props2)
      $$invalidate(6, highlight = $$props2.highlight);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("hasPopup" in $$props2)
      $$invalidate(8, hasPopup = $$props2.hasPopup);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("transparent" in $$props2)
      $$invalidate(9, transparent = $$props2.transparent);
    if ("background" in $$props2)
      $$invalidate(10, background = $$props2.background);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*highlight, color*/
    4160) {
      $$invalidate(11, _color = highlight ? "var(--color-accent)" : color);
    }
  };
  return [
    Icon,
    label2,
    show_label,
    pending,
    size,
    padded,
    highlight,
    disabled,
    hasPopup,
    transparent,
    background,
    _color,
    color,
    $$scope,
    slots,
    click_handler
  ];
}
class IconButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$l, create_fragment$t, safe_not_equal, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 12,
      transparent: 9,
      background: 10
    });
  }
}
function create_fragment$s(ctx) {
  let svg2;
  let polyline;
  return {
    c() {
      svg2 = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        fill: true,
        stroke: true,
        "aria-hidden": true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg2);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "viewBox", "2 0 20 20");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "fill", "none");
      attr(svg2, "stroke", "currentColor");
      attr(svg2, "aria-hidden", "true");
      attr(svg2, "stroke-width", "1.5");
      attr(svg2, "stroke-linecap", "round");
      attr(svg2, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, polyline);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Check extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$s, safe_not_equal, {});
  }
}
function create_fragment$r(ctx) {
  let svg2;
  let g;
  let path0;
  let path1;
  return {
    c() {
      svg2 = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        version: true,
        xmlns: true,
        "xmlns:xlink": true,
        "xml:space": true,
        stroke: true,
        style: true
      });
      var svg_nodes = children(svg2);
      g = claim_svg_element(svg_nodes, "g", { transform: true });
      var g_nodes = children(g);
      path0 = claim_svg_element(g_nodes, "path", { d: true, style: true });
      children(path0).forEach(detach);
      g_nodes.forEach(detach);
      path1 = claim_svg_element(svg_nodes, "path", { d: true, style: true });
      children(path1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M18,6L6.087,17.913");
      set_style(path0, "fill", "none");
      set_style(path0, "fill-rule", "nonzero");
      set_style(path0, "stroke-width", "2px");
      attr(g, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)");
      attr(path1, "d", "M4.364,4.364L19.636,19.636");
      set_style(path1, "fill", "none");
      set_style(path1, "fill-rule", "nonzero");
      set_style(path1, "stroke-width", "2px");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "version", "1.1");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg2, "xml:space", "preserve");
      attr(svg2, "stroke", "currentColor");
      set_style(svg2, "fill-rule", "evenodd");
      set_style(svg2, "clip-rule", "evenodd");
      set_style(svg2, "stroke-linecap", "round");
      set_style(svg2, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, g);
      append_hydration(g, path0);
      append_hydration(svg2, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Clear2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$r, safe_not_equal, {});
  }
}
function create_fragment$q(ctx) {
  let svg2;
  let path0;
  let path1;
  return {
    c() {
      svg2 = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        color: true,
        "aria-hidden": true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg2);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "fill", "currentColor");
      attr(path0, "d", "M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z");
      attr(path1, "fill", "currentColor");
      attr(path1, "d", "M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "viewBox", "0 0 33 33");
      attr(svg2, "color", "currentColor");
      attr(svg2, "aria-hidden", "true");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, path0);
      append_hydration(svg2, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Copy extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$q, safe_not_equal, {});
  }
}
function create_fragment$p(ctx) {
  let svg2;
  let path2;
  return {
    c() {
      svg2 = svg_element("svg");
      path2 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        fill: true,
        stroke: true,
        viewBox: true,
        width: true,
        height: true,
        xmlns: true,
        "aria-hidden": true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg2);
      path2 = claim_svg_element(svg_nodes, "path", {
        "stroke-linecap": true,
        "stroke-linejoin": true,
        d: true
      });
      children(path2).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path2, "stroke-linecap", "round");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "d", "M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z");
      attr(svg2, "fill", "none");
      attr(svg2, "stroke", "currentColor");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "aria-hidden", "true");
      attr(svg2, "stroke-width", "2");
      attr(svg2, "stroke-linecap", "round");
      attr(svg2, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
let Error$1 = class Error2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$p, safe_not_equal, {});
  }
};
function create_fragment$o(ctx) {
  let svg2;
  let path2;
  return {
    c() {
      svg2 = svg_element("svg");
      path2 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        fill: true,
        stroke: true,
        viewBox: true,
        width: true,
        height: true,
        xmlns: true,
        "aria-hidden": true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg2);
      path2 = claim_svg_element(svg_nodes, "path", {
        "stroke-linecap": true,
        "stroke-linejoin": true,
        d: true
      });
      children(path2).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path2, "stroke-linecap", "round");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "d", "M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z");
      attr(svg2, "fill", "none");
      attr(svg2, "stroke", "currentColor");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "aria-hidden", "true");
      attr(svg2, "stroke-width", "2");
      attr(svg2, "stroke-linecap", "round");
      attr(svg2, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Info2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$o, safe_not_equal, {});
  }
}
function create_fragment$n(ctx) {
  let svg2;
  let g0;
  let g1;
  let g2;
  let path2;
  return {
    c() {
      svg2 = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g2 = svg_element("g");
      path2 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        viewBox: true,
        width: true,
        height: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg2);
      g0 = claim_svg_element(svg_nodes, "g", { id: true, "stroke-width": true });
      children(g0).forEach(detach);
      g1 = claim_svg_element(svg_nodes, "g", {
        id: true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(g1).forEach(detach);
      g2 = claim_svg_element(svg_nodes, "g", { id: true });
      var g2_nodes = children(g2);
      path2 = claim_svg_element(g2_nodes, "path", { d: true, fill: true });
      children(path2).forEach(detach);
      g2_nodes.forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(g0, "id", "SVGRepo_bgCarrier");
      attr(g0, "stroke-width", "0");
      attr(g1, "id", "SVGRepo_tracerCarrier");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path2, "d", "M19.1168 12.1484C19.474 12.3581 19.9336 12.2384 20.1432 11.8811C20.3528 11.5238 20.2331 11.0643 19.8758 10.8547L19.1168 12.1484ZM6.94331 4.13656L6.55624 4.77902L6.56378 4.78344L6.94331 4.13656ZM5.92408 4.1598L5.50816 3.5357L5.50816 3.5357L5.92408 4.1598ZM5.51031 5.09156L4.76841 5.20151C4.77575 5.25101 4.78802 5.29965 4.80505 5.34671L5.51031 5.09156ZM7.12405 11.7567C7.26496 12.1462 7.69495 12.3477 8.08446 12.2068C8.47397 12.0659 8.67549 11.6359 8.53458 11.2464L7.12405 11.7567ZM19.8758 12.1484C20.2331 11.9388 20.3528 11.4793 20.1432 11.122C19.9336 10.7648 19.474 10.6451 19.1168 10.8547L19.8758 12.1484ZM6.94331 18.8666L6.56375 18.2196L6.55627 18.2241L6.94331 18.8666ZM5.92408 18.8433L5.50815 19.4674H5.50815L5.92408 18.8433ZM5.51031 17.9116L4.80505 17.6564C4.78802 17.7035 4.77575 17.7521 4.76841 17.8016L5.51031 17.9116ZM8.53458 11.7567C8.67549 11.3672 8.47397 10.9372 8.08446 10.7963C7.69495 10.6554 7.26496 10.8569 7.12405 11.2464L8.53458 11.7567ZM19.4963 12.2516C19.9105 12.2516 20.2463 11.9158 20.2463 11.5016C20.2463 11.0873 19.9105 10.7516 19.4963 10.7516V12.2516ZM7.82931 10.7516C7.4151 10.7516 7.07931 11.0873 7.07931 11.5016C7.07931 11.9158 7.4151 12.2516 7.82931 12.2516V10.7516ZM19.8758 10.8547L7.32284 3.48968L6.56378 4.78344L19.1168 12.1484L19.8758 10.8547ZM7.33035 3.49414C6.76609 3.15419 6.05633 3.17038 5.50816 3.5357L6.34 4.78391C6.40506 4.74055 6.4893 4.73863 6.55627 4.77898L7.33035 3.49414ZM5.50816 3.5357C4.95998 3.90102 4.67184 4.54987 4.76841 5.20151L6.25221 4.98161C6.24075 4.90427 6.27494 4.82727 6.34 4.78391L5.50816 3.5357ZM4.80505 5.34671L7.12405 11.7567L8.53458 11.2464L6.21558 4.83641L4.80505 5.34671ZM19.1168 10.8547L6.56378 18.2197L7.32284 19.5134L19.8758 12.1484L19.1168 10.8547ZM6.55627 18.2241C6.4893 18.2645 6.40506 18.2626 6.34 18.2192L5.50815 19.4674C6.05633 19.8327 6.76609 19.8489 7.33035 19.509L6.55627 18.2241ZM6.34 18.2192C6.27494 18.1759 6.24075 18.0988 6.25221 18.0215L4.76841 17.8016C4.67184 18.4532 4.95998 19.1021 5.50815 19.4674L6.34 18.2192ZM6.21558 18.1667L8.53458 11.7567L7.12405 11.2464L4.80505 17.6564L6.21558 18.1667ZM19.4963 10.7516H7.82931V12.2516H19.4963V10.7516Z");
      attr(path2, "fill", "currentColor");
      attr(g2, "id", "SVGRepo_iconCarrier");
      attr(svg2, "viewBox", "0 0 22 24");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "fill", "none");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, g0);
      append_hydration(svg2, g1);
      append_hydration(svg2, g2);
      append_hydration(g2, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Send extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$n, safe_not_equal, {});
  }
}
function create_fragment$m(ctx) {
  let svg2;
  let rect;
  let svg_stroke_width_value;
  return {
    c() {
      svg2 = svg_element("svg");
      rect = svg_element("rect");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg2);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "3");
      attr(rect, "y", "3");
      attr(rect, "width", "18");
      attr(rect, "height", "18");
      attr(rect, "rx", "2");
      attr(rect, "ry", "2");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(
        svg2,
        "fill",
        /*fill*/
        ctx[0]
      );
      attr(svg2, "stroke", "currentColor");
      attr(svg2, "stroke-width", svg_stroke_width_value = `${/*stroke_width*/
      ctx[1]}`);
      attr(svg2, "stroke-linecap", "round");
      attr(svg2, "stroke-linejoin", "round");
      attr(svg2, "class", "feather feather-square");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*fill*/
      1) {
        attr(
          svg2,
          "fill",
          /*fill*/
          ctx2[0]
        );
      }
      if (dirty & /*stroke_width*/
      2 && svg_stroke_width_value !== (svg_stroke_width_value = `${/*stroke_width*/
      ctx2[1]}`)) {
        attr(svg2, "stroke-width", svg_stroke_width_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { fill = "currentColor" } = $$props;
  let { stroke_width = 1.5 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fill" in $$props2)
      $$invalidate(0, fill = $$props2.fill);
    if ("stroke_width" in $$props2)
      $$invalidate(1, stroke_width = $$props2.stroke_width);
  };
  return [fill, stroke_width];
}
class Square extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$k, create_fragment$m, safe_not_equal, { fill: 0, stroke_width: 1 });
  }
}
function create_fragment$l(ctx) {
  let svg2;
  let path2;
  return {
    c() {
      svg2 = svg_element("svg");
      path2 = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg2 = claim_svg_element(nodes, "svg", {
        fill: true,
        stroke: true,
        "stroke-width": true,
        viewBox: true,
        width: true,
        height: true,
        xmlns: true,
        "aria-hidden": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      var svg_nodes = children(svg2);
      path2 = claim_svg_element(svg_nodes, "path", {
        "stroke-linecap": true,
        "stroke-linejoin": true,
        d: true
      });
      children(path2).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path2, "stroke-linecap", "round");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "d", "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z");
      attr(svg2, "fill", "none");
      attr(svg2, "stroke", "currentColor");
      attr(svg2, "stroke-width", "2");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "width", "100%");
      attr(svg2, "height", "100%");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "aria-hidden", "true");
      attr(svg2, "stroke-linecap", "round");
      attr(svg2, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert_hydration(target, svg2, anchor);
      append_hydration(svg2, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg2);
      }
    }
  };
}
class Warning extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, null, create_fragment$l, safe_not_equal, {});
  }
}
const ordered_colors = [
  "red",
  "green",
  "blue",
  "yellow",
  "purple",
  "teal",
  "orange",
  "cyan",
  "lime",
  "pink"
];
const color_values = [
  { color: "red", primary: 600, secondary: 100 },
  { color: "green", primary: 600, secondary: 100 },
  { color: "blue", primary: 600, secondary: 100 },
  { color: "yellow", primary: 500, secondary: 100 },
  { color: "purple", primary: 600, secondary: 100 },
  { color: "teal", primary: 600, secondary: 100 },
  { color: "orange", primary: 600, secondary: 100 },
  { color: "cyan", primary: 600, secondary: 100 },
  { color: "lime", primary: 500, secondary: 100 },
  { color: "pink", primary: 600, secondary: 100 }
];
const tw_colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
const colors = color_values.reduce(
  (acc, { color, primary, secondary }) => ({
    ...acc,
    [color]: {
      primary: tw_colors[color][primary],
      secondary: tw_colors[color][secondary]
    }
  }),
  {}
);
class ShareError extends Error {
  constructor(message) {
    super(message);
    this.name = "ShareError";
  }
}
async function uploadToHuggingFace(data, type) {
  var _a2;
  if (window.__gradio_space__ == null) {
    throw new ShareError("Must be on Spaces to share.");
  }
  let blob;
  let contentType;
  let filename;
  {
    let url;
    if (typeof data === "object" && data.url) {
      url = data.url;
    } else if (typeof data === "string") {
      url = data;
    } else {
      throw new Error("Invalid data format for URL type");
    }
    const response = await fetch(url);
    blob = await response.blob();
    contentType = response.headers.get("content-type") || "";
    filename = response.headers.get("content-disposition") || "";
  }
  const file2 = new File([blob], filename, { type: contentType });
  const uploadResponse = await fetch("https://huggingface.co/uploads", {
    method: "POST",
    body: file2,
    headers: {
      "Content-Type": file2.type,
      "X-Requested-With": "XMLHttpRequest"
    }
  });
  if (!uploadResponse.ok) {
    if ((_a2 = uploadResponse.headers.get("content-type")) == null ? void 0 : _a2.includes("application/json")) {
      const error = await uploadResponse.json();
      throw new ShareError(`Upload failed: ${error.error}`);
    }
    throw new ShareError(`Upload failed.`);
  }
  const result = await uploadResponse.text();
  return result;
}
function copy(node) {
  node.addEventListener("click", handle_copy);
  async function handle_copy(event) {
    const path2 = event.composedPath();
    const [copy_button] = path2.filter(
      (e) => (e == null ? void 0 : e.tagName) === "BUTTON" && e.classList.contains("copy_code_button")
    );
    if (copy_button) {
      let copy_feedback = function(_copy_sucess_button) {
        _copy_sucess_button.style.opacity = "1";
        setTimeout(() => {
          _copy_sucess_button.style.opacity = "0";
        }, 2e3);
      };
      event.stopImmediatePropagation();
      const copy_text = copy_button.parentElement.innerText.trim();
      const copy_sucess_button = Array.from(
        copy_button.children
      )[1];
      const copied = await copy_to_clipboard(copy_text);
      if (copied)
        copy_feedback(copy_sucess_button);
    }
  }
  return {
    destroy() {
      node.removeEventListener("click", handle_copy);
    }
  };
}
async function copy_to_clipboard(value) {
  let copied = false;
  if ("clipboard" in navigator) {
    await navigator.clipboard.writeText(value);
    copied = true;
  } else {
    const textArea = document.createElement("textarea");
    textArea.value = value;
    textArea.style.position = "absolute";
    textArea.style.left = "-999999px";
    document.body.prepend(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
      copied = true;
    } catch (error) {
      console.error(error);
      copied = false;
    } finally {
      textArea.remove();
    }
  }
  return copied;
}
const format_time = (seconds) => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const seconds_remainder = Math.round(seconds) % 60;
  const padded_minutes = `${minutes < 10 ? "0" : ""}${minutes}`;
  const padded_seconds = `${seconds_remainder < 10 ? "0" : ""}${seconds_remainder}`;
  if (hours > 0) {
    return `${hours}:${padded_minutes}:${padded_seconds}`;
  }
  return `${minutes}:${padded_seconds}`;
};
const is_browser$1 = typeof window !== "undefined";
class Gradio {
  constructor(id2, el, theme, version, root, autoscroll, max_file_size, i18n = (x) => x, client, virtual_component_loader) {
    __privateAdd(this, _id, void 0);
    __publicField(this, "theme");
    __publicField(this, "version");
    __publicField(this, "i18n");
    __privateAdd(this, _el, void 0);
    __publicField(this, "root");
    __publicField(this, "autoscroll");
    __publicField(this, "max_file_size");
    __publicField(this, "client");
    __publicField(this, "_load_component");
    __publicField(this, "load_component", _load_component.bind(this));
    __privateSet(this, _id, id2);
    this.theme = theme;
    this.version = version;
    __privateSet(this, _el, el);
    this.max_file_size = max_file_size;
    this.i18n = i18n;
    this.root = root;
    this.autoscroll = autoscroll;
    this.client = client;
    this._load_component = virtual_component_loader;
  }
  dispatch(event_name, data) {
    if (!is_browser$1 || !__privateGet(this, _el))
      return;
    const e = new CustomEvent("gradio", {
      bubbles: true,
      detail: { data, id: __privateGet(this, _id), event: event_name }
    });
    __privateGet(this, _el).dispatchEvent(e);
  }
}
_id = new WeakMap();
_el = new WeakMap();
function _load_component(name, variant = "component") {
  var _a2;
  return this._load_component({
    name,
    api_url: (_a2 = this.client.config) == null ? void 0 : _a2.root,
    variant
  });
}
const css_units = (dimension_value) => {
  return typeof dimension_value === "number" ? dimension_value + "px" : dimension_value;
};
const get_error_slot_changes = (dirty) => ({});
const get_error_slot_context = (ctx) => ({});
const get_additional_loading_text_slot_changes = (dirty) => ({});
const get_additional_loading_text_slot_context = (ctx) => ({});
function get_each_context$7(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list2[i];
  child_ctx[42] = i;
  return child_ctx;
}
function get_each_context_1$3(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list2[i];
  return child_ctx;
}
function create_if_block_17(ctx) {
  let div;
  let iconbutton;
  let t0;
  let span;
  let t1_value = (
    /*i18n*/
    ctx[1]("common.error") + ""
  );
  let t1;
  let t2;
  let current2;
  iconbutton = new IconButton({
    props: {
      Icon: Clear2,
      label: (
        /*i18n*/
        ctx[1]("common.clear")
      ),
      disabled: false
    }
  });
  iconbutton.$on(
    "click",
    /*click_handler*/
    ctx[32]
  );
  const error_slot_template = (
    /*#slots*/
    ctx[30].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_error_slot_context
  );
  return {
    c() {
      div = element("div");
      create_component(iconbutton.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text$3(t1_value);
      t2 = space();
      if (error_slot)
        error_slot.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(iconbutton.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (error_slot)
        error_slot.l(nodes);
      this.h();
    },
    h() {
      attr(div, "class", "clear-status svelte-ls20lj");
      attr(span, "class", "error svelte-ls20lj");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(iconbutton, div, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t1);
      insert_hydration(target, t2, anchor);
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      const iconbutton_changes = {};
      if (dirty[0] & /*i18n*/
      2)
        iconbutton_changes.label = /*i18n*/
        ctx2[1]("common.clear");
      iconbutton.$set(iconbutton_changes);
      if ((!current2 || dirty[0] & /*i18n*/
      2) && t1_value !== (t1_value = /*i18n*/
      ctx2[1]("common.error") + ""))
        set_data(t1, t1_value);
      if (error_slot) {
        if (error_slot.p && (!current2 || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(iconbutton.$$.fragment, local);
      transition_in(error_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      transition_out(error_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(span);
        detach(t2);
      }
      destroy_component(iconbutton);
      if (error_slot)
        error_slot.d(detaching);
    }
  };
}
function create_if_block$g(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let current_block_type_index;
  let if_block3;
  let t3;
  let if_block4_anchor;
  let current2;
  let if_block0 = (
    /*variant*/
    ctx[8] === "default" && /*show_eta_bar*/
    ctx[18] && /*show_progress*/
    ctx[6] === "full" && create_if_block_16(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*progress*/
      ctx2[7]
    )
      return create_if_block_11;
    if (
      /*queue_position*/
      ctx2[2] !== null && /*queue_size*/
      ctx2[3] !== void 0 && /*queue_position*/
      ctx2[2] >= 0
    )
      return create_if_block_14;
    if (
      /*queue_position*/
      ctx2[2] === 0
    )
      return create_if_block_15;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  let if_block2 = (
    /*timer*/
    ctx[5] && create_if_block_10(ctx)
  );
  const if_block_creators = [create_if_block_2$b, create_if_block_9$2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*last_progress_level*/
      ctx2[15] != null
    )
      return 0;
    if (
      /*show_progress*/
      ctx2[6] === "full"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block4 = !/*timer*/
  ctx[5] && create_if_block_1$b(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      this.h();
    },
    l(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      if_block4_anchor = empty();
      this.h();
    },
    h() {
      attr(div, "class", "progress-text svelte-ls20lj");
      toggle_class(
        div,
        "meta-text-center",
        /*variant*/
        ctx[8] === "center"
      );
      toggle_class(
        div,
        "meta-text",
        /*variant*/
        ctx[8] === "default"
      );
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      insert_hydration(target, t2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration(target, if_block4_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*variant*/
        ctx2[8] === "default" && /*show_eta_bar*/
        ctx2[18] && /*show_progress*/
        ctx2[6] === "full"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_16(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, t1);
        }
      }
      if (
        /*timer*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_10(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current2 || dirty[0] & /*variant*/
      256) {
        toggle_class(
          div,
          "meta-text-center",
          /*variant*/
          ctx2[8] === "center"
        );
      }
      if (!current2 || dirty[0] & /*variant*/
      256) {
        toggle_class(
          div,
          "meta-text",
          /*variant*/
          ctx2[8] === "default"
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(t3.parentNode, t3);
        } else {
          if_block3 = null;
        }
      }
      if (!/*timer*/
      ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*timer*/
          32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$b(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block3);
      transition_in(if_block4);
      current2 = true;
    },
    o(local) {
      transition_out(if_block3);
      transition_out(if_block4);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t2);
        detach(t3);
        detach(if_block4_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1) {
        if_block1.d();
      }
      if (if_block2)
        if_block2.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (if_block4)
        if_block4.d(detaching);
    }
  };
}
function create_if_block_16(ctx) {
  let div;
  let style_transform = `translateX(${/*eta_level*/
  (ctx[17] || 0) * 100 - 100}%)`;
  return {
    c() {
      div = element("div");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "eta-bar svelte-ls20lj");
      set_style(div, "transform", style_transform);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*eta_level*/
      131072 && style_transform !== (style_transform = `translateX(${/*eta_level*/
      (ctx2[17] || 0) * 100 - 100}%)`)) {
        set_style(div, "transform", style_transform);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_15(ctx) {
  let t;
  return {
    c() {
      t = text$3("processing |");
    },
    l(nodes) {
      t = claim_text(nodes, "processing |");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_14(ctx) {
  let t0;
  let t1_value = (
    /*queue_position*/
    ctx[2] + 1 + ""
  );
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      t0 = text$3("queue: ");
      t1 = text$3(t1_value);
      t2 = text$3("/");
      t3 = text$3(
        /*queue_size*/
        ctx[3]
      );
      t4 = text$3(" |");
    },
    l(nodes) {
      t0 = claim_text(nodes, "queue: ");
      t1 = claim_text(nodes, t1_value);
      t2 = claim_text(nodes, "/");
      t3 = claim_text(
        nodes,
        /*queue_size*/
        ctx[3]
      );
      t4 = claim_text(nodes, " |");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*queue_position*/
      4 && t1_value !== (t1_value = /*queue_position*/
      ctx2[2] + 1 + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*queue_size*/
      8)
        set_data(
          t3,
          /*queue_size*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
    }
  };
}
function create_if_block_11(ctx) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like(
    /*progress*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress*/
      128) {
        each_value_1 = ensure_array_like(
          /*progress*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let t0;
  let t1_value = (
    /*p*/
    ctx[40].unit + ""
  );
  let t1;
  let t2;
  let t3_value = " ";
  let t3;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*p*/
      ctx2[40].length != null
    )
      return create_if_block_13;
    return create_else_block$6;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      t0 = space();
      t1 = text$3(t1_value);
      t2 = text$3(" | ");
      t3 = text$3(t3_value);
    },
    l(nodes) {
      if_block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      t2 = claim_text(nodes, " | ");
      t3 = claim_text(nodes, t3_value);
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      }
      if (dirty[0] & /*progress*/
      128 && t1_value !== (t1_value = /*p*/
      ctx2[40].unit + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$6(ctx) {
  let t_value = pretty_si(
    /*p*/
    ctx[40].index || 0
  ) + "";
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress*/
      128 && t_value !== (t_value = pretty_si(
        /*p*/
        ctx2[40].index || 0
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let t0_value = pretty_si(
    /*p*/
    ctx[40].index || 0
  ) + "";
  let t0;
  let t1;
  let t2_value = pretty_si(
    /*p*/
    ctx[40].length
  ) + "";
  let t2;
  return {
    c() {
      t0 = text$3(t0_value);
      t1 = text$3("/");
      t2 = text$3(t2_value);
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, "/");
      t2 = claim_text(nodes, t2_value);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress*/
      128 && t0_value !== (t0_value = pretty_si(
        /*p*/
        ctx2[40].index || 0
      ) + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*progress*/
      128 && t2_value !== (t2_value = pretty_si(
        /*p*/
        ctx2[40].length
      ) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_each_block_1$3(ctx) {
  let if_block_anchor;
  let if_block = (
    /*p*/
    ctx[40].index != null && create_if_block_12(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*p*/
        ctx2[40].index != null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let t0;
  let t1_value = (
    /*eta*/
    ctx[0] ? `/${/*formatted_eta*/
    ctx[19]}` : ""
  );
  let t1;
  let t2;
  return {
    c() {
      t0 = text$3(
        /*formatted_timer*/
        ctx[20]
      );
      t1 = text$3(t1_value);
      t2 = text$3("s");
    },
    l(nodes) {
      t0 = claim_text(
        nodes,
        /*formatted_timer*/
        ctx[20]
      );
      t1 = claim_text(nodes, t1_value);
      t2 = claim_text(nodes, "s");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*formatted_timer*/
      1048576)
        set_data(
          t0,
          /*formatted_timer*/
          ctx2[20]
        );
      if (dirty[0] & /*eta, formatted_eta*/
      524289 && t1_value !== (t1_value = /*eta*/
      ctx2[0] ? `/${/*formatted_eta*/
      ctx2[19]}` : ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_9$2(ctx) {
  let loader;
  let current2;
  loader = new Loader({
    props: { margin: (
      /*variant*/
      ctx[8] === "default"
    ) }
  });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    l(nodes) {
      claim_component(loader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const loader_changes = {};
      if (dirty[0] & /*variant*/
      256)
        loader_changes.margin = /*variant*/
        ctx2[8] === "default";
      loader.$set(loader_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(loader.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block_2$b(ctx) {
  let div3;
  let div0;
  let t;
  let div2;
  let div1;
  let style_width = `${/*last_progress_level*/
  ctx[15] * 100}%`;
  let if_block = (
    /*progress*/
    ctx[7] != null && create_if_block_3$7(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div2 = element("div");
      div1 = element("div");
      this.h();
    },
    l(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach);
      t = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      children(div1).forEach(detach);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "progress-level-inner svelte-ls20lj");
      attr(div1, "class", "progress-bar svelte-ls20lj");
      set_style(div1, "width", style_width);
      attr(div2, "class", "progress-bar-wrap svelte-ls20lj");
      attr(div3, "class", "progress-level svelte-ls20lj");
    },
    m(target, anchor) {
      insert_hydration(target, div3, anchor);
      append_hydration(div3, div0);
      if (if_block)
        if_block.m(div0, null);
      append_hydration(div3, t);
      append_hydration(div3, div2);
      append_hydration(div2, div1);
      ctx[31](div1);
    },
    p(ctx2, dirty) {
      if (
        /*progress*/
        ctx2[7] != null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$7(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*last_progress_level*/
      32768 && style_width !== (style_width = `${/*last_progress_level*/
      ctx2[15] * 100}%`)) {
        set_style(div1, "width", style_width);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      ctx[31](null);
    }
  };
}
function create_if_block_3$7(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*progress*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress_level, progress*/
      16512) {
        each_value = ensure_array_like(
          /*progress*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_4$6(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let if_block0 = (
    /*i*/
    ctx[42] !== 0 && create_if_block_8$2()
  );
  let if_block1 = (
    /*p*/
    ctx[40].desc != null && create_if_block_7$4(ctx)
  );
  let if_block2 = (
    /*p*/
    ctx[40].desc != null && /*progress_level*/
    ctx[14] && /*progress_level*/
    ctx[14][
      /*i*/
      ctx[42]
    ] != null && create_if_block_6$4()
  );
  let if_block3 = (
    /*progress_level*/
    ctx[14] != null && create_if_block_5$5(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
    },
    l(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration(target, if_block3_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*p*/
        ctx2[40].desc != null
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7$4(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*p*/
        ctx2[40].desc != null && /*progress_level*/
        ctx2[14] && /*progress_level*/
        ctx2[14][
          /*i*/
          ctx2[42]
        ] != null
      ) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block_6$4();
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*progress_level*/
        ctx2[14] != null
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_5$5(ctx2);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
    }
  };
}
function create_if_block_8$2(ctx) {
  let t;
  return {
    c() {
      t = text$3("/");
    },
    l(nodes) {
      t = claim_text(nodes, "/");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_7$4(ctx) {
  let t_value = (
    /*p*/
    ctx[40].desc + ""
  );
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress*/
      128 && t_value !== (t_value = /*p*/
      ctx2[40].desc + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_6$4(ctx) {
  let t;
  return {
    c() {
      t = text$3("-");
    },
    l(nodes) {
      t = claim_text(nodes, "-");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_5$5(ctx) {
  let t0_value = (100 * /*progress_level*/
  (ctx[14][
    /*i*/
    ctx[42]
  ] || 0)).toFixed(1) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text$3(t0_value);
      t1 = text$3("%");
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, "%");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*progress_level*/
      16384 && t0_value !== (t0_value = (100 * /*progress_level*/
      (ctx2[14][
        /*i*/
        ctx2[42]
      ] || 0)).toFixed(1) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block$7(ctx) {
  let if_block_anchor;
  let if_block = (
    /*p*/
    (ctx[40].desc != null || /*progress_level*/
    ctx[14] && /*progress_level*/
    ctx[14][
      /*i*/
      ctx[42]
    ] != null) && create_if_block_4$6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*p*/
        ctx2[40].desc != null || /*progress_level*/
        ctx2[14] && /*progress_level*/
        ctx2[14][
          /*i*/
          ctx2[42]
        ] != null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$b(ctx) {
  let p_1;
  let t0;
  let t1;
  let current2;
  const additional_loading_text_slot_template = (
    /*#slots*/
    ctx[30]["additional-loading-text"]
  );
  const additional_loading_text_slot = create_slot(
    additional_loading_text_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_additional_loading_text_slot_context
  );
  return {
    c() {
      p_1 = element("p");
      t0 = text$3(
        /*loading_text*/
        ctx[9]
      );
      t1 = space();
      if (additional_loading_text_slot)
        additional_loading_text_slot.c();
      this.h();
    },
    l(nodes) {
      p_1 = claim_element(nodes, "P", { class: true });
      var p_1_nodes = children(p_1);
      t0 = claim_text(
        p_1_nodes,
        /*loading_text*/
        ctx[9]
      );
      p_1_nodes.forEach(detach);
      t1 = claim_space(nodes);
      if (additional_loading_text_slot)
        additional_loading_text_slot.l(nodes);
      this.h();
    },
    h() {
      attr(p_1, "class", "loading svelte-ls20lj");
    },
    m(target, anchor) {
      insert_hydration(target, p_1, anchor);
      append_hydration(p_1, t0);
      insert_hydration(target, t1, anchor);
      if (additional_loading_text_slot) {
        additional_loading_text_slot.m(target, anchor);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (!current2 || dirty[0] & /*loading_text*/
      512)
        set_data(
          t0,
          /*loading_text*/
          ctx2[9]
        );
      if (additional_loading_text_slot) {
        if (additional_loading_text_slot.p && (!current2 || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            additional_loading_text_slot,
            additional_loading_text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              additional_loading_text_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_additional_loading_text_slot_changes
            ),
            get_additional_loading_text_slot_context
          );
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(additional_loading_text_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(additional_loading_text_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p_1);
        detach(t1);
      }
      if (additional_loading_text_slot)
        additional_loading_text_slot.d(detaching);
    }
  };
}
function create_fragment$k(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current2;
  const if_block_creators = [create_if_block$g, create_if_block_17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*status*/
      ctx2[4] === "pending"
    )
      return 0;
    if (
      /*status*/
      ctx2[4] === "error"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", div_class_value = "wrap " + /*variant*/
      ctx[8] + " " + /*show_progress*/
      ctx[6] + " svelte-ls20lj");
      toggle_class(div, "hide", !/*status*/
      ctx[4] || /*status*/
      ctx[4] === "complete" || /*show_progress*/
      ctx[6] === "hidden" || /*status*/
      ctx[4] == "streaming");
      toggle_class(
        div,
        "translucent",
        /*variant*/
        ctx[8] === "center" && /*status*/
        (ctx[4] === "pending" || /*status*/
        ctx[4] === "error") || /*translucent*/
        ctx[11] || /*show_progress*/
        ctx[6] === "minimal"
      );
      toggle_class(
        div,
        "generating",
        /*status*/
        ctx[4] === "generating" && /*show_progress*/
        ctx[6] === "full"
      );
      toggle_class(
        div,
        "border",
        /*border*/
        ctx[12]
      );
      set_style(
        div,
        "position",
        /*absolute*/
        ctx[10] ? "absolute" : "static"
      );
      set_style(
        div,
        "padding",
        /*absolute*/
        ctx[10] ? "0" : "var(--size-8) 0"
      );
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      ctx[33](div);
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      if (!current2 || dirty[0] & /*variant, show_progress*/
      320 && div_class_value !== (div_class_value = "wrap " + /*variant*/
      ctx2[8] + " " + /*show_progress*/
      ctx2[6] + " svelte-ls20lj")) {
        attr(div, "class", div_class_value);
      }
      if (!current2 || dirty[0] & /*variant, show_progress, status, show_progress*/
      336) {
        toggle_class(div, "hide", !/*status*/
        ctx2[4] || /*status*/
        ctx2[4] === "complete" || /*show_progress*/
        ctx2[6] === "hidden" || /*status*/
        ctx2[4] == "streaming");
      }
      if (!current2 || dirty[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
      2384) {
        toggle_class(
          div,
          "translucent",
          /*variant*/
          ctx2[8] === "center" && /*status*/
          (ctx2[4] === "pending" || /*status*/
          ctx2[4] === "error") || /*translucent*/
          ctx2[11] || /*show_progress*/
          ctx2[6] === "minimal"
        );
      }
      if (!current2 || dirty[0] & /*variant, show_progress, status, show_progress*/
      336) {
        toggle_class(
          div,
          "generating",
          /*status*/
          ctx2[4] === "generating" && /*show_progress*/
          ctx2[6] === "full"
        );
      }
      if (!current2 || dirty[0] & /*variant, show_progress, border*/
      4416) {
        toggle_class(
          div,
          "border",
          /*border*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*absolute*/
      1024) {
        set_style(
          div,
          "position",
          /*absolute*/
          ctx2[10] ? "absolute" : "static"
        );
      }
      if (dirty[0] & /*absolute*/
      1024) {
        set_style(
          div,
          "padding",
          /*absolute*/
          ctx2[10] ? "0" : "var(--size-8) 0"
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[33](null);
    }
  };
}
let items = [];
let called = false;
const is_browser = typeof window !== "undefined";
const raf = is_browser ? window.requestAnimationFrame : (cb) => {
};
async function scroll_into_view(el, enable = true) {
  if (window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && enable !== true) {
    return;
  }
  items.push(el);
  if (!called)
    called = true;
  else
    return;
  await tick();
  raf(() => {
    let min = [0, 0];
    for (let i = 0; i < items.length; i++) {
      const element2 = items[i];
      const box = element2.getBoundingClientRect();
      if (i === 0 || box.top + window.scrollY <= min[0]) {
        min[0] = box.top + window.scrollY;
        min[1] = i;
      }
    }
    window.scrollTo({ top: min[0] - 20, behavior: "smooth" });
    called = false;
    items = [];
  });
}
function instance$j($$self, $$props, $$invalidate) {
  let formatted_timer;
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { i18n } = $$props;
  let { eta = null } = $$props;
  let { queue_position } = $$props;
  let { queue_size } = $$props;
  let { status } = $$props;
  let { scroll_to_output = false } = $$props;
  let { timer = true } = $$props;
  let { show_progress = "full" } = $$props;
  let { message = null } = $$props;
  let { progress = null } = $$props;
  let { variant = "default" } = $$props;
  let { loading_text = "Loading..." } = $$props;
  let { absolute = true } = $$props;
  let { translucent = false } = $$props;
  let { border = false } = $$props;
  let { autoscroll } = $$props;
  let el;
  let _timer = false;
  let timer_start = 0;
  let timer_diff = 0;
  let old_eta = null;
  let eta_from_start = null;
  let eta_level = 0;
  let progress_level = null;
  let last_progress_level = void 0;
  let progress_bar = null;
  let show_eta_bar = true;
  const start_timer = () => {
    $$invalidate(0, eta = $$invalidate(27, old_eta = $$invalidate(19, formatted_eta = null)));
    $$invalidate(25, timer_start = performance.now());
    $$invalidate(26, timer_diff = 0);
    _timer = true;
    run();
  };
  function run() {
    raf(() => {
      $$invalidate(26, timer_diff = (performance.now() - timer_start) / 1e3);
      if (_timer)
        run();
    });
  }
  function stop_timer() {
    $$invalidate(26, timer_diff = 0);
    $$invalidate(0, eta = $$invalidate(27, old_eta = $$invalidate(19, formatted_eta = null)));
    if (!_timer)
      return;
    _timer = false;
  }
  onDestroy(() => {
    if (_timer)
      stop_timer();
  });
  let formatted_eta = null;
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      progress_bar = $$value;
      $$invalidate(16, progress_bar), $$invalidate(7, progress), $$invalidate(14, progress_level), $$invalidate(15, last_progress_level);
    });
  }
  const click_handler = () => {
    dispatch("clear_status");
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(13, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(1, i18n = $$props2.i18n);
    if ("eta" in $$props2)
      $$invalidate(0, eta = $$props2.eta);
    if ("queue_position" in $$props2)
      $$invalidate(2, queue_position = $$props2.queue_position);
    if ("queue_size" in $$props2)
      $$invalidate(3, queue_size = $$props2.queue_size);
    if ("status" in $$props2)
      $$invalidate(4, status = $$props2.status);
    if ("scroll_to_output" in $$props2)
      $$invalidate(22, scroll_to_output = $$props2.scroll_to_output);
    if ("timer" in $$props2)
      $$invalidate(5, timer = $$props2.timer);
    if ("show_progress" in $$props2)
      $$invalidate(6, show_progress = $$props2.show_progress);
    if ("message" in $$props2)
      $$invalidate(23, message = $$props2.message);
    if ("progress" in $$props2)
      $$invalidate(7, progress = $$props2.progress);
    if ("variant" in $$props2)
      $$invalidate(8, variant = $$props2.variant);
    if ("loading_text" in $$props2)
      $$invalidate(9, loading_text = $$props2.loading_text);
    if ("absolute" in $$props2)
      $$invalidate(10, absolute = $$props2.absolute);
    if ("translucent" in $$props2)
      $$invalidate(11, translucent = $$props2.translucent);
    if ("border" in $$props2)
      $$invalidate(12, border = $$props2.border);
    if ("autoscroll" in $$props2)
      $$invalidate(24, autoscroll = $$props2.autoscroll);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
    436207617) {
      {
        if (eta === null) {
          $$invalidate(0, eta = old_eta);
        }
        if (eta != null && old_eta !== eta) {
          $$invalidate(28, eta_from_start = (performance.now() - timer_start) / 1e3 + eta);
          $$invalidate(19, formatted_eta = eta_from_start.toFixed(1));
          $$invalidate(27, old_eta = eta);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*eta_from_start, timer_diff*/
    335544320) {
      $$invalidate(17, eta_level = eta_from_start === null || eta_from_start <= 0 || !timer_diff ? null : Math.min(timer_diff / eta_from_start, 1));
    }
    if ($$self.$$.dirty[0] & /*progress*/
    128) {
      if (progress != null) {
        $$invalidate(18, show_eta_bar = false);
      }
    }
    if ($$self.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
    114816) {
      {
        if (progress != null) {
          $$invalidate(14, progress_level = progress.map((p) => {
            if (p.index != null && p.length != null) {
              return p.index / p.length;
            } else if (p.progress != null) {
              return p.progress;
            }
            return void 0;
          }));
        } else {
          $$invalidate(14, progress_level = null);
        }
        if (progress_level) {
          $$invalidate(15, last_progress_level = progress_level[progress_level.length - 1]);
          if (progress_bar) {
            if (last_progress_level === 0) {
              $$invalidate(16, progress_bar.style.transition = "0", progress_bar);
            } else {
              $$invalidate(16, progress_bar.style.transition = "150ms", progress_bar);
            }
          }
        } else {
          $$invalidate(15, last_progress_level = void 0);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*status*/
    16) {
      {
        if (status === "pending") {
          start_timer();
        } else {
          stop_timer();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
    20979728) {
      el && scroll_to_output && (status === "pending" || status === "complete") && scroll_into_view(el, autoscroll);
    }
    if ($$self.$$.dirty[0] & /*status, message*/
    8388624)
      ;
    if ($$self.$$.dirty[0] & /*timer_diff*/
    67108864) {
      $$invalidate(20, formatted_timer = timer_diff.toFixed(1));
    }
  };
  return [
    eta,
    i18n,
    queue_position,
    queue_size,
    status,
    timer,
    show_progress,
    progress,
    variant,
    loading_text,
    absolute,
    translucent,
    border,
    el,
    progress_level,
    last_progress_level,
    progress_bar,
    eta_level,
    show_eta_bar,
    formatted_eta,
    formatted_timer,
    dispatch,
    scroll_to_output,
    message,
    autoscroll,
    timer_start,
    timer_diff,
    old_eta,
    eta_from_start,
    $$scope,
    slots,
    div1_binding,
    click_handler,
    div_binding
  ];
}
class Static extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(
      this,
      options2,
      instance$j,
      create_fragment$k,
      safe_not_equal,
      {
        i18n: 1,
        eta: 0,
        queue_position: 2,
        queue_size: 3,
        status: 4,
        scroll_to_output: 22,
        timer: 5,
        show_progress: 6,
        message: 23,
        progress: 7,
        variant: 8,
        loading_text: 9,
        absolute: 10,
        translucent: 11,
        border: 12,
        autoscroll: 24
      },
      null,
      [-1, -1]
    );
  }
}
/*! @license DOMPurify 3.0.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.3/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create$1
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  let l = array.length;
  while (l--) {
    let element2 = array[l];
    if (typeof element2 === "string") {
      const lcElement = transformCaseFunc(element2);
      if (lcElement !== element2) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element2 = lcElement;
      }
    }
    set2[element2] = true;
  }
  return set2;
}
function clone(object) {
  const newObject = create$1(null);
  for (const [property, value] of entries(object)) {
    newObject[property] = value;
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element2) {
    console.warn("fallback value for", element2);
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = () => typeof window === "undefined" ? null : window;
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.0.3";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  const originalDocument = window2.document;
  const currentScript = originalDocument.currentScript;
  let {
    document: document2
  } = window2;
  const {
    DocumentFragment: DocumentFragment2,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element2,
    NodeFilter: NodeFilter2,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser: DOMParser2,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [...text]);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  const ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  const ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  const _checkValidNamespace = function _checkValidNamespace2(element2) {
    let parent = getParentNode(element2);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element2.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element2.namespaceURI]) {
      return false;
    }
    if (element2.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element2.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element2.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element2.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      node.remove();
    }
  };
  const _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc;
    let leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT,
      null,
      false
    );
  };
  const _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(object) {
    return typeof Node2 === "object" ? object instanceof Node2 : object && typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  const _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR2, " ");
      content = stringReplace(content, ERB_EXPR2, " ");
      content = stringReplace(content, TMPLIT_EXPR2, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if (value) {
      return false;
    } else
      ;
    return true;
  };
  const _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    let attr2;
    let value;
    let lcName;
    let l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr2 = attributes[l];
      const {
        name,
        namespaceURI
      } = attr2;
      value = name === "value" ? attr2.value : stringTrim(attr2.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR2, " ");
        value = stringReplace(value, ERB_EXPR2, " ");
        value = stringReplace(value, TMPLIT_EXPR2, " ");
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode;
    const shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment2) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body;
    let importedNode;
    let currentNode;
    let returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment2) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR2, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag2, attr2, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag2);
    const lcName = transformCaseFunc(attr2);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
function create_if_block_2$a(ctx) {
  let error;
  let current2;
  error = new Error$1({});
  return {
    c() {
      create_component(error.$$.fragment);
    },
    l(nodes) {
      claim_component(error.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(error, target, anchor);
      current2 = true;
    },
    i(local) {
      if (current2)
        return;
      transition_in(error.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(error.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(error, detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let info;
  let current2;
  info = new Info2({});
  return {
    c() {
      create_component(info.$$.fragment);
    },
    l(nodes) {
      claim_component(info.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current2 = true;
    },
    i(local) {
      if (current2)
        return;
      transition_in(info.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block$f(ctx) {
  let warning;
  let current2;
  warning = new Warning({});
  return {
    c() {
      create_component(warning.$$.fragment);
    },
    l(nodes) {
      claim_component(warning.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(warning, target, anchor);
      current2 = true;
    },
    i(local) {
      if (current2)
        return;
      transition_in(warning.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(warning.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(warning, detaching);
    }
  };
}
function create_fragment$j(ctx) {
  let div5;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_class_value;
  let t0;
  let div3;
  let div1;
  let t1;
  let div1_class_value;
  let t2;
  let div2;
  let html_tag;
  let div2_class_value;
  let div3_class_value;
  let t3;
  let button;
  let span;
  let textContent = "";
  let button_class_value;
  let t5;
  let div4;
  let div4_class_value;
  let div4_style_value;
  let div5_class_value;
  let div5_intro;
  let div5_outro;
  let current2;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$f, create_if_block_1$a, create_if_block_2$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[2] === "warning"
    )
      return 0;
    if (
      /*type*/
      ctx2[2] === "info"
    )
      return 1;
    if (
      /*type*/
      ctx2[2] === "error"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text$3(
        /*title*/
        ctx[1]
      );
      t2 = space();
      div2 = element("div");
      html_tag = new HtmlTagHydration(false);
      t3 = space();
      button = element("button");
      span = element("span");
      span.textContent = textContent;
      t5 = space();
      div4 = element("div");
      this.h();
    },
    l(nodes) {
      div5 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "data-testid": true
      });
      var div5_nodes = children(div5);
      div0 = claim_element(div5_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(div5_nodes);
      div3 = claim_element(div5_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(
        div1_nodes,
        /*title*/
        ctx[1]
      );
      div1_nodes.forEach(detach);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      html_tag = claim_html_tag(div2_nodes, false);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      t3 = claim_space(div5_nodes);
      button = claim_element(div5_nodes, "BUTTON", {
        class: true,
        type: true,
        "aria-label": true,
        "data-testid": true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {
        "aria-hidden": true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(span) !== "svelte-zpkfw7")
        span.textContent = textContent;
      button_nodes.forEach(detach);
      t5 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true, style: true });
      children(div4).forEach(detach);
      div5_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", div0_class_value = "toast-icon " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(div1, "class", div1_class_value = "toast-title " + /*type*/
      ctx[2] + " svelte-utw7m1");
      html_tag.a = null;
      attr(div2, "class", div2_class_value = "toast-text " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(div3, "class", div3_class_value = "toast-details " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(span, "aria-hidden", "true");
      attr(button, "class", button_class_value = "toast-close " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(button, "type", "button");
      attr(button, "aria-label", "Close");
      attr(button, "data-testid", "toast-close");
      attr(div4, "class", div4_class_value = "timer " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(div4, "style", div4_style_value = `animation-duration: ${/*timer_animation_duration*/
      ctx[3]};`);
      attr(div5, "class", div5_class_value = "toast-body " + /*type*/
      ctx[2] + " svelte-utw7m1");
      attr(div5, "role", "alert");
      attr(div5, "data-testid", "toast-body");
      toggle_class(div5, "hidden", !/*display*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, div5, anchor);
      append_hydration(div5, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_hydration(div5, t0);
      append_hydration(div5, div3);
      append_hydration(div3, div1);
      append_hydration(div1, t1);
      append_hydration(div3, t2);
      append_hydration(div3, div2);
      html_tag.m(
        /*message*/
        ctx[0],
        div2
      );
      append_hydration(div5, t3);
      append_hydration(div5, button);
      append_hydration(button, span);
      append_hydration(div5, t5);
      append_hydration(div5, div4);
      current2 = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*close_message*/
            ctx[5]
          ),
          listen(div5, "click", stop_propagation(
            /*click_handler*/
            ctx[9]
          )),
          listen(div5, "keydown", stop_propagation(
            /*keydown_handler*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          }
          transition_in(if_block, 1);
          if_block.m(div0, null);
        } else {
          if_block = null;
        }
      }
      if (!current2 || dirty & /*type*/
      4 && div0_class_value !== (div0_class_value = "toast-icon " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div0, "class", div0_class_value);
      }
      if (!current2 || dirty & /*title*/
      2)
        set_data(
          t1,
          /*title*/
          ctx2[1]
        );
      if (!current2 || dirty & /*type*/
      4 && div1_class_value !== (div1_class_value = "toast-title " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current2 || dirty & /*message*/
      1)
        html_tag.p(
          /*message*/
          ctx2[0]
        );
      if (!current2 || dirty & /*type*/
      4 && div2_class_value !== (div2_class_value = "toast-text " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div2, "class", div2_class_value);
      }
      if (!current2 || dirty & /*type*/
      4 && div3_class_value !== (div3_class_value = "toast-details " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div3, "class", div3_class_value);
      }
      if (!current2 || dirty & /*type*/
      4 && button_class_value !== (button_class_value = "toast-close " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(button, "class", button_class_value);
      }
      if (!current2 || dirty & /*type*/
      4 && div4_class_value !== (div4_class_value = "timer " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div4, "class", div4_class_value);
      }
      if (!current2 || dirty & /*timer_animation_duration*/
      8 && div4_style_value !== (div4_style_value = `animation-duration: ${/*timer_animation_duration*/
      ctx2[3]};`)) {
        attr(div4, "style", div4_style_value);
      }
      if (!current2 || dirty & /*type*/
      4 && div5_class_value !== (div5_class_value = "toast-body " + /*type*/
      ctx2[2] + " svelte-utw7m1")) {
        attr(div5, "class", div5_class_value);
      }
      if (!current2 || dirty & /*type, display*/
      20) {
        toggle_class(div5, "hidden", !/*display*/
        ctx2[4]);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current2)
            return;
          if (div5_outro)
            div5_outro.end(1);
          div5_intro = create_in_transition(div5, fade, { duration: 200, delay: 100 });
          div5_intro.start();
        });
      }
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      if (div5_intro)
        div5_intro.invalidate();
      if (local) {
        div5_outro = create_out_transition(div5, fade, { duration: 200 });
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div5_outro)
        div5_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let display;
  let timer_animation_duration;
  let { title = "" } = $$props;
  let { message = "" } = $$props;
  let { type } = $$props;
  let { id: id2 } = $$props;
  let { duration = 10 } = $$props;
  let { visible = true } = $$props;
  const is_external_url2 = (link2) => {
    try {
      return !!link2 && new URL(link2, location.href).origin !== location.origin;
    } catch (e) {
      return false;
    }
  };
  purify.addHook("afterSanitizeAttributes", function(node) {
    if ("target" in node) {
      if (is_external_url2(node.getAttribute("href"))) {
        node.setAttribute("target", "_blank");
        node.setAttribute("rel", "noopener noreferrer");
      }
    }
  });
  const dispatch = createEventDispatcher();
  function close_message() {
    dispatch("close", id2);
  }
  onMount(() => {
    if (duration !== null) {
      setTimeout(
        () => {
          close_message();
        },
        duration * 1e3
      );
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
    if ("type" in $$props2)
      $$invalidate(2, type = $$props2.type);
    if ("id" in $$props2)
      $$invalidate(7, id2 = $$props2.id);
    if ("duration" in $$props2)
      $$invalidate(6, duration = $$props2.duration);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*message*/
    1) {
      $$invalidate(0, message = purify.sanitize(message));
    }
    if ($$self.$$.dirty & /*visible*/
    256) {
      $$invalidate(4, display = visible);
    }
    if ($$self.$$.dirty & /*duration*/
    64) {
      $$invalidate(6, duration = duration || null);
    }
    if ($$self.$$.dirty & /*duration*/
    64) {
      $$invalidate(3, timer_animation_duration = `${duration || 0}s`);
    }
  };
  return [
    message,
    title,
    type,
    timer_animation_duration,
    display,
    close_message,
    duration,
    id2,
    visible,
    click_handler,
    keydown_handler
  ];
}
class ToastContent extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$i, create_fragment$j, safe_not_equal, {
      title: 1,
      message: 0,
      type: 2,
      id: 7,
      duration: 6,
      visible: 8
    });
  }
}
function get_each_context$6(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list2[i].type;
  child_ctx[3] = list2[i].title;
  child_ctx[4] = list2[i].message;
  child_ctx[5] = list2[i].id;
  child_ctx[6] = list2[i].duration;
  child_ctx[7] = list2[i].visible;
  return child_ctx;
}
function create_each_block$6(key_1, ctx) {
  let div;
  let toastcontent;
  let t;
  let rect;
  let stop_animation = noop;
  let current2;
  toastcontent = new ToastContent({
    props: {
      type: (
        /*type*/
        ctx[2]
      ),
      title: (
        /*title*/
        ctx[3]
      ),
      message: (
        /*message*/
        ctx[4]
      ),
      duration: (
        /*duration*/
        ctx[6]
      ),
      visible: (
        /*visible*/
        ctx[7]
      ),
      id: (
        /*id*/
        ctx[5]
      )
    }
  });
  toastcontent.$on(
    "close",
    /*close_handler*/
    ctx[1]
  );
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(toastcontent.$$.fragment);
      t = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(toastcontent.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_style(div, "width", `100%`);
      this.first = div;
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(toastcontent, div, null);
      append_hydration(div, t);
      current2 = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const toastcontent_changes = {};
      if (dirty & /*messages*/
      1)
        toastcontent_changes.type = /*type*/
        ctx[2];
      if (dirty & /*messages*/
      1)
        toastcontent_changes.title = /*title*/
        ctx[3];
      if (dirty & /*messages*/
      1)
        toastcontent_changes.message = /*message*/
        ctx[4];
      if (dirty & /*messages*/
      1)
        toastcontent_changes.duration = /*duration*/
        ctx[6];
      if (dirty & /*messages*/
      1)
        toastcontent_changes.visible = /*visible*/
        ctx[7];
      if (dirty & /*messages*/
      1)
        toastcontent_changes.id = /*id*/
        ctx[5];
      toastcontent.$set(toastcontent_changes);
    },
    r() {
      rect = div.getBoundingClientRect();
    },
    f() {
      fix_position(div);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, { duration: 300 });
    },
    i(local) {
      if (current2)
        return;
      transition_in(toastcontent.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(toastcontent.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(toastcontent);
    }
  };
}
function create_fragment$i(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current2;
  let each_value = ensure_array_like(
    /*messages*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[5]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "toast-wrap svelte-pu0yf1");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*messages*/
      1) {
        each_value = ensure_array_like(
          /*messages*/
          ctx2[0]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current2 = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function scroll_to_top(_messages) {
  var _a2;
  if (_messages.length > 0) {
    if ("parentIFrame" in window) {
      (_a2 = window.parentIFrame) == null ? void 0 : _a2.scrollTo(0, 0);
    }
  }
}
function instance$h($$self, $$props, $$invalidate) {
  let { messages = [] } = $$props;
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("messages" in $$props2)
      $$invalidate(0, messages = $$props2.messages);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*messages*/
    1) {
      scroll_to_top(messages);
    }
  };
  return [messages, close_handler];
}
class Toast extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$h, create_fragment$i, safe_not_equal, { messages: 0 });
  }
}
function represent_value(value, type, lang = null) {
  if (type === void 0) {
    return lang === "py" ? "None" : null;
  }
  if (value === null && lang === "py") {
    return "None";
  }
  if (type === "string" || type === "str") {
    return lang === null ? value : '"' + value + '"';
  } else if (type === "number") {
    return lang === null ? parseFloat(value) : value;
  } else if (type === "boolean" || type == "bool") {
    if (lang === "py") {
      value = String(value);
      return value === "true" ? "True" : "False";
    } else if (lang === "js" || lang === "bash") {
      return value;
    }
    return value === "true";
  } else if (type === "List[str]") {
    value = JSON.stringify(value);
    return value;
  } else if (type.startsWith("Literal['")) {
    return '"' + value + '"';
  }
  if (lang === null) {
    return value === "" ? null : JSON.parse(value);
  } else if (typeof value === "string") {
    if (value === "") {
      return lang === "py" ? "None" : "null";
    }
    return value;
  }
  if (lang === "bash") {
    value = simplify_file_data(value);
  }
  if (lang === "py") {
    value = replace_file_data_with_file_function(value);
  }
  return stringify_except_file_function(value);
}
function is_potentially_nested_file_data(obj) {
  if (typeof obj === "object" && obj !== null) {
    if (obj.hasOwnProperty("url") && obj.hasOwnProperty("meta")) {
      if (typeof obj.meta === "object" && obj.meta !== null && obj.meta._type === "gradio.FileData") {
        return true;
      }
    }
  }
  if (typeof obj === "object" && obj !== null) {
    for (let key in obj) {
      if (typeof obj[key] === "object") {
        let result = is_potentially_nested_file_data(obj[key]);
        if (result) {
          return true;
        }
      }
    }
  }
  return false;
}
function simplify_file_data(obj) {
  var _a2;
  if (typeof obj === "object" && obj !== null && !Array.isArray(obj)) {
    if ("url" in obj && obj.url && "meta" in obj && ((_a2 = obj.meta) == null ? void 0 : _a2._type) === "gradio.FileData") {
      return { path: obj.url };
    }
  }
  if (Array.isArray(obj)) {
    obj.forEach((item, index) => {
      if (typeof item === "object" && item !== null) {
        obj[index] = simplify_file_data(item);
      }
    });
  } else if (typeof obj === "object" && obj !== null) {
    Object.keys(obj).forEach((key) => {
      obj[key] = simplify_file_data(obj[key]);
    });
  }
  return obj;
}
function replace_file_data_with_file_function(obj) {
  var _a2;
  if (typeof obj === "object" && obj !== null && !Array.isArray(obj)) {
    if ("url" in obj && obj.url && "meta" in obj && ((_a2 = obj.meta) == null ? void 0 : _a2._type) === "gradio.FileData") {
      return `handle_file('${obj.url}')`;
    }
  }
  if (Array.isArray(obj)) {
    obj.forEach((item, index) => {
      if (typeof item === "object" && item !== null) {
        obj[index] = replace_file_data_with_file_function(item);
      }
    });
  } else if (typeof obj === "object" && obj !== null) {
    Object.keys(obj).forEach((key) => {
      obj[key] = replace_file_data_with_file_function(obj[key]);
    });
  }
  return obj;
}
function stringify_except_file_function(obj) {
  let jsonString = JSON.stringify(obj, (key, value) => {
    if (value === null) {
      return "UNQUOTEDNone";
    }
    if (typeof value === "string" && value.startsWith("handle_file(") && value.endsWith(")")) {
      return `UNQUOTED${value}`;
    }
    return value;
  });
  const regex2 = /"UNQUOTEDhandle_file\(([^)]*)\)"/g;
  jsonString = jsonString.replace(regex2, (match, p1) => `handle_file(${p1})`);
  const regexNone = /"UNQUOTEDNone"/g;
  return jsonString.replace(regexNone, "None");
}
function get_each_context$5(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i].label;
  child_ctx[5] = list2[i].python_type;
  child_ctx[6] = list2[i].component;
  child_ctx[7] = list2[i].parameter_name;
  child_ctx[8] = list2[i].parameter_has_default;
  child_ctx[9] = list2[i].parameter_default;
  child_ctx[11] = i;
  return child_ctx;
}
function create_if_block_4$5(ctx) {
  let t;
  return {
    c() {
      t = text$3("s");
    },
    l(nodes) {
      t = claim_text(nodes, "s");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_else_block_1$4(ctx) {
  let t_value = (
    /*js_returns*/
    (ctx[2][
      /*i*/
      ctx[11]
    ].type || "any") + ""
  );
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*js_returns*/
      4 && t_value !== (t_value = /*js_returns*/
      (ctx2[2][
        /*i*/
        ctx2[11]
      ].type || "any") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_2$9(ctx) {
  let t_value = (
    /*python_type*/
    ctx[5].type + ""
  );
  let t;
  let if_block_anchor;
  let if_block = (
    /*parameter_has_default*/
    ctx[8] && /*parameter_default*/
    ctx[9] === null && create_if_block_3$6()
  );
  return {
    c() {
      t = text$3(t_value);
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*endpoint_returns*/
      2 && t_value !== (t_value = /*python_type*/
      ctx2[5].type + ""))
        set_data(t, t_value);
      if (
        /*parameter_has_default*/
        ctx2[8] && /*parameter_default*/
        ctx2[9] === null
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_3$6();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let t;
  return {
    c() {
      t = text$3("|\n							None");
    },
    l(nodes) {
      t = claim_text(nodes, "|\n							None");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_else_block$5(ctx) {
  let span0;
  let textContent = "Default: ";
  let span1;
  let t1_value = represent_value(
    /*parameter_default*/
    ctx[9],
    /*python_type*/
    ctx[5].type,
    "py"
  ) + "";
  let t1;
  return {
    c() {
      span0 = element("span");
      span0.textContent = textContent;
      span1 = element("span");
      t1 = text$3(t1_value);
      this.h();
    },
    l(nodes) {
      span0 = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-y3zgxh")
        span0.textContent = textContent;
      span1 = claim_element(nodes, "SPAN", { class: true, style: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span1, "class", "code svelte-1yt946s");
      set_style(span1, "font-size", "var(--text-sm)");
    },
    m(target, anchor) {
      insert_hydration(target, span0, anchor);
      insert_hydration(target, span1, anchor);
      append_hydration(span1, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*endpoint_returns*/
      2 && t1_value !== (t1_value = represent_value(
        /*parameter_default*/
        ctx2[9],
        /*python_type*/
        ctx2[5].type,
        "py"
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(span1);
      }
    }
  };
}
function create_if_block_1$9(ctx) {
  let span;
  let textContent = "Required";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { style: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1y2sdp")
        span.textContent = textContent;
      this.h();
    },
    h() {
      set_style(span, "font-weight", "bold");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block$5(ctx) {
  let hr2;
  let t0;
  let div;
  let p0;
  let span0;
  let t1_value = (
    /*current_language*/
    (ctx[3] !== "bash" && /*parameter_name*/
    ctx[7] ? (
      /*parameter_name*/
      ctx[7]
    ) : "[" + /*i*/
    ctx[11] + "]") + ""
  );
  let t1;
  let t2;
  let span1;
  let t3;
  let t4;
  let p1;
  let t5;
  let t6_value = (
    /*label*/
    ctx[4] + ""
  );
  let t6;
  let t7;
  let t8_value = (
    /*component*/
    ctx[6] + ""
  );
  let t8;
  let t9;
  let t10_value = (
    /*python_type*/
    ctx[5].description + ""
  );
  let t10;
  let t11;
  function select_block_type(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[3] === "python"
    )
      return create_if_block_2$9;
    return create_else_block_1$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (!/*parameter_has_default*/
    ctx2[8] || /*current_language*/
    ctx2[3] == "bash")
      return create_if_block_1$9;
    return create_else_block$5;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      hr2 = element("hr");
      t0 = space();
      div = element("div");
      p0 = element("p");
      span0 = element("span");
      t1 = text$3(t1_value);
      t2 = space();
      span1 = element("span");
      if_block0.c();
      t3 = space();
      if_block1.c();
      t4 = space();
      p1 = element("p");
      t5 = text$3('The input value that is provided in the "');
      t6 = text$3(t6_value);
      t7 = text$3('" ');
      t8 = text$3(t8_value);
      t9 = text$3("\n				component. ");
      t10 = text$3(t10_value);
      t11 = space();
      this.h();
    },
    l(nodes) {
      hr2 = claim_element(nodes, "HR", { class: true });
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      p0 = claim_element(div_nodes, "P", { style: true });
      var p0_nodes = children(p0);
      span0 = claim_element(p0_nodes, "SPAN", { class: true, style: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach);
      t2 = claim_space(p0_nodes);
      span1 = claim_element(p0_nodes, "SPAN", { class: true, style: true });
      var span1_nodes = children(span1);
      if_block0.l(span1_nodes);
      span1_nodes.forEach(detach);
      t3 = claim_space(p0_nodes);
      if_block1.l(p0_nodes);
      p0_nodes.forEach(detach);
      t4 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      t5 = claim_text(p1_nodes, 'The input value that is provided in the "');
      t6 = claim_text(p1_nodes, t6_value);
      t7 = claim_text(p1_nodes, '" ');
      t8 = claim_text(p1_nodes, t8_value);
      t9 = claim_text(p1_nodes, "\n				component. ");
      t10 = claim_text(p1_nodes, t10_value);
      p1_nodes.forEach(detach);
      t11 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(hr2, "class", "hr svelte-1yt946s");
      attr(span0, "class", "code svelte-1yt946s");
      set_style(span0, "margin-right", "10px");
      attr(span1, "class", "code highlight svelte-1yt946s");
      set_style(span1, "margin-right", "10px");
      set_style(p0, "white-space", "nowrap");
      set_style(p0, "overflow-x", "auto");
      attr(p1, "class", "desc svelte-1yt946s");
      set_style(div, "margin", "10px");
    },
    m(target, anchor) {
      insert_hydration(target, hr2, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div, anchor);
      append_hydration(div, p0);
      append_hydration(p0, span0);
      append_hydration(span0, t1);
      append_hydration(p0, t2);
      append_hydration(p0, span1);
      if_block0.m(span1, null);
      append_hydration(p0, t3);
      if_block1.m(p0, null);
      append_hydration(div, t4);
      append_hydration(div, p1);
      append_hydration(p1, t5);
      append_hydration(p1, t6);
      append_hydration(p1, t7);
      append_hydration(p1, t8);
      append_hydration(p1, t9);
      append_hydration(p1, t10);
      append_hydration(div, t11);
    },
    p(ctx2, dirty) {
      if (dirty & /*current_language, endpoint_returns*/
      10 && t1_value !== (t1_value = /*current_language*/
      (ctx2[3] !== "bash" && /*parameter_name*/
      ctx2[7] ? (
        /*parameter_name*/
        ctx2[7]
      ) : "[" + /*i*/
      ctx2[11] + "]") + ""))
        set_data(t1, t1_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(span1, null);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(p0, null);
        }
      }
      if (dirty & /*endpoint_returns*/
      2 && t6_value !== (t6_value = /*label*/
      ctx2[4] + ""))
        set_data(t6, t6_value);
      if (dirty & /*endpoint_returns*/
      2 && t8_value !== (t8_value = /*component*/
      ctx2[6] + ""))
        set_data(t8, t8_value);
      if (dirty & /*endpoint_returns*/
      2 && t10_value !== (t10_value = /*python_type*/
      ctx2[5].description + ""))
        set_data(t10, t10_value);
    },
    d(detaching) {
      if (detaching) {
        detach(hr2);
        detach(t0);
        detach(div);
      }
      if_block0.d();
      if_block1.d();
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  let loader;
  let current2;
  loader = new Loader({ props: { margin: false } });
  return {
    c() {
      div = element("div");
      create_component(loader.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(loader.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "load-wrap");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(loader, div, null);
      current2 = true;
    },
    i(local) {
      if (current2)
        return;
      transition_in(loader.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(loader);
    }
  };
}
function create_fragment$h(ctx) {
  let h4;
  let div1;
  let textContent = `<div class="toggle-dot svelte-1yt946s"></div>`;
  let t0;
  let t1_value = (
    /*endpoint_returns*/
    ctx[1].length + ""
  );
  let t1;
  let t2;
  let t3;
  let t4;
  let div2;
  let t5;
  let if_block1_anchor;
  let current2;
  let if_block0 = (
    /*endpoint_returns*/
    ctx[1].length != 1 && create_if_block_4$5()
  );
  let each_value = ensure_array_like(
    /*endpoint_returns*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  let if_block1 = (
    /*is_running*/
    ctx[0] && create_if_block$e()
  );
  return {
    c() {
      h4 = element("h4");
      div1 = element("div");
      div1.innerHTML = textContent;
      t0 = text$3("\n	Accepts ");
      t1 = text$3(t1_value);
      t2 = text$3(" parameter");
      if (if_block0)
        if_block0.c();
      t3 = text$3(":");
      t4 = space();
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      div1 = claim_element(h4_nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div1) !== "svelte-1pmwe5h")
        div1.innerHTML = textContent;
      t0 = claim_text(h4_nodes, "\n	Accepts ");
      t1 = claim_text(h4_nodes, t1_value);
      t2 = claim_text(h4_nodes, " parameter");
      if (if_block0)
        if_block0.l(h4_nodes);
      t3 = claim_text(h4_nodes, ":");
      h4_nodes.forEach(detach);
      t4 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div2_nodes);
      }
      div2_nodes.forEach(detach);
      t5 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div1, "class", "toggle-icon svelte-1yt946s");
      attr(h4, "class", "svelte-1yt946s");
      toggle_class(
        div2,
        "hide",
        /*is_running*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, h4, anchor);
      append_hydration(h4, div1);
      append_hydration(h4, t0);
      append_hydration(h4, t1);
      append_hydration(h4, t2);
      if (if_block0)
        if_block0.m(h4, null);
      append_hydration(h4, t3);
      insert_hydration(target, t4, anchor);
      insert_hydration(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      insert_hydration(target, t5, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if ((!current2 || dirty & /*endpoint_returns*/
      2) && t1_value !== (t1_value = /*endpoint_returns*/
      ctx2[1].length + ""))
        set_data(t1, t1_value);
      if (
        /*endpoint_returns*/
        ctx2[1].length != 1
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_4$5();
          if_block0.c();
          if_block0.m(h4, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*endpoint_returns, current_language, js_returns*/
      14) {
        each_value = ensure_array_like(
          /*endpoint_returns*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current2 || dirty & /*is_running*/
      1) {
        toggle_class(
          div2,
          "hide",
          /*is_running*/
          ctx2[0]
        );
      }
      if (
        /*is_running*/
        ctx2[0]
      ) {
        if (if_block1) {
          if (dirty & /*is_running*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$e();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block1);
      current2 = true;
    },
    o(local) {
      transition_out(if_block1);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
        detach(t4);
        detach(div2);
        detach(t5);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { is_running: is_running2 } = $$props;
  let { endpoint_returns } = $$props;
  let { js_returns } = $$props;
  let { current_language } = $$props;
  $$self.$$set = ($$props2) => {
    if ("is_running" in $$props2)
      $$invalidate(0, is_running2 = $$props2.is_running);
    if ("endpoint_returns" in $$props2)
      $$invalidate(1, endpoint_returns = $$props2.endpoint_returns);
    if ("js_returns" in $$props2)
      $$invalidate(2, js_returns = $$props2.js_returns);
    if ("current_language" in $$props2)
      $$invalidate(3, current_language = $$props2.current_language);
  };
  return [is_running2, endpoint_returns, js_returns, current_language];
}
class ParametersSnippet extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$g, create_fragment$h, safe_not_equal, {
      is_running: 0,
      endpoint_returns: 1,
      js_returns: 2,
      current_language: 3
    });
  }
}
function create_default_slot$a(ctx) {
  let t;
  return {
    c() {
      t = text$3(
        /*copy_text*/
        ctx[0]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*copy_text*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*copy_text*/
      1)
        set_data(
          t,
          /*copy_text*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_fragment$g(ctx) {
  let basebutton;
  let current2;
  basebutton = new Button({
    props: {
      size: "sm",
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  basebutton.$on(
    "click",
    /*copy*/
    ctx[1]
  );
  return {
    c() {
      create_component(basebutton.$$.fragment);
    },
    l(nodes) {
      claim_component(basebutton.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(basebutton, target, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const basebutton_changes = {};
      if (dirty & /*$$scope, copy_text*/
      9) {
        basebutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      basebutton.$set(basebutton_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(basebutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(basebutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(basebutton, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { code: code2 } = $$props;
  let copy_text = "copy";
  function copy2() {
    navigator.clipboard.writeText(code2);
    $$invalidate(0, copy_text = "copied!");
    setTimeout(
      () => {
        $$invalidate(0, copy_text = "copy");
      },
      1500
    );
  }
  $$self.$$set = ($$props2) => {
    if ("code" in $$props2)
      $$invalidate(2, code2 = $$props2.code);
  };
  return [copy_text, copy2, code2];
}
class CopyButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$f, create_fragment$g, safe_not_equal, { code: 2 });
  }
}
function create_if_block_2$8(ctx) {
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let t2;
  let current2;
  copybutton = new CopyButton({ props: { code: bash_install } });
  return {
    c() {
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3("$ ");
      t2 = text$3(bash_install);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, "$ ");
      t2 = claim_text(pre_nodes, bash_install);
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-hq8ezf");
      attr(pre, "class", "svelte-hq8ezf");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(copybutton, div0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div1, anchor);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      append_hydration(pre, t2);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_component(copybutton);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let t2;
  let current2;
  copybutton = new CopyButton({ props: { code: js_install } });
  return {
    c() {
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3("$ ");
      t2 = text$3(js_install);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, "$ ");
      t2 = claim_text(pre_nodes, js_install);
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-hq8ezf");
      attr(pre, "class", "svelte-hq8ezf");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(copybutton, div0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div1, anchor);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      append_hydration(pre, t2);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_component(copybutton);
    }
  };
}
function create_if_block$d(ctx) {
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let t2;
  let current2;
  copybutton = new CopyButton({ props: { code: py_install } });
  return {
    c() {
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3("$ ");
      t2 = text$3(py_install);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, "$ ");
      t2 = claim_text(pre_nodes, py_install);
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-hq8ezf");
      attr(pre, "class", "svelte-hq8ezf");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(copybutton, div0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div1, anchor);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      append_hydration(pre, t2);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_component(copybutton);
    }
  };
}
function create_default_slot$9(ctx) {
  let code2;
  let current_block_type_index;
  let if_block;
  let current2;
  const if_block_creators = [create_if_block$d, create_if_block_1$8, create_if_block_2$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[0] === "python"
    )
      return 0;
    if (
      /*current_language*/
      ctx2[0] === "javascript"
    )
      return 1;
    if (
      /*current_language*/
      ctx2[0] === "bash"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      code2 = element("code");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      if (if_block)
        if_block.l(code_nodes);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(code2, "class", "svelte-hq8ezf");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(code2, null);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(code2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_fragment$f(ctx) {
  let block2;
  let current2;
  block2 = new Block({
    props: {
      border_mode: "contrast",
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block2.$$.fragment);
    },
    l(nodes) {
      claim_component(block2.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block2, target, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const block_changes = {};
      if (dirty & /*$$scope, current_language*/
      3) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block2.$set(block_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(block2, detaching);
    }
  };
}
let py_install = "pip install gradio_client";
let js_install = "npm i -D @gradio/client";
let bash_install = "curl --version";
function instance$e($$self, $$props, $$invalidate) {
  let { current_language } = $$props;
  $$self.$$set = ($$props2) => {
    if ("current_language" in $$props2)
      $$invalidate(0, current_language = $$props2.current_language);
  };
  return [current_language];
}
class InstallSnippet extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$e, create_fragment$f, safe_not_equal, { current_language: 0 });
  }
}
function create_else_block$4(ctx) {
  let h3;
  let t0;
  let span;
  let t1;
  return {
    c() {
      h3 = element("h3");
      t0 = text$3("fn_index:\n		");
      span = element("span");
      t1 = text$3(
        /*fn_index*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h3 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t0 = claim_text(h3_nodes, "fn_index:\n		");
      span = claim_element(h3_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*fn_index*/
        ctx[1]
      );
      span_nodes.forEach(detach);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "post svelte-41kcm6");
      attr(h3, "class", "svelte-41kcm6");
    },
    m(target, anchor) {
      insert_hydration(target, h3, anchor);
      append_hydration(h3, t0);
      append_hydration(h3, span);
      append_hydration(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*fn_index*/
      2)
        set_data(
          t1,
          /*fn_index*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_if_block$c(ctx) {
  let h3;
  let t0;
  let span;
  let t1_value = "/" + /*api_name*/
  ctx[0];
  let t1;
  return {
    c() {
      h3 = element("h3");
      t0 = text$3("api_name:\n		");
      span = element("span");
      t1 = text$3(t1_value);
      this.h();
    },
    l(nodes) {
      h3 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t0 = claim_text(h3_nodes, "api_name:\n		");
      span = claim_element(h3_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "post svelte-41kcm6");
      attr(h3, "class", "svelte-41kcm6");
    },
    m(target, anchor) {
      insert_hydration(target, h3, anchor);
      append_hydration(h3, t0);
      append_hydration(h3, span);
      append_hydration(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*api_name*/
      1 && t1_value !== (t1_value = "/" + /*api_name*/
      ctx2[0]))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_fragment$e(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*named*/
      ctx2[2]
    )
      return create_if_block$c;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { api_name = null } = $$props;
  let { fn_index = null } = $$props;
  let { named } = $$props;
  $$self.$$set = ($$props2) => {
    if ("api_name" in $$props2)
      $$invalidate(0, api_name = $$props2.api_name);
    if ("fn_index" in $$props2)
      $$invalidate(1, fn_index = $$props2.fn_index);
    if ("named" in $$props2)
      $$invalidate(2, named = $$props2.named);
  };
  return [api_name, fn_index, named];
}
class EndpointDetail extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$d, create_fragment$e, safe_not_equal, { api_name: 0, fn_index: 1, named: 2 });
  }
}
function get_each_context_3(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list2[i].label;
  child_ctx[23] = list2[i].parameter_name;
  child_ctx[29] = list2[i].type;
  child_ctx[21] = list2[i].python_type;
  child_ctx[30] = list2[i].component;
  child_ctx[22] = list2[i].example_input;
  child_ctx[31] = list2[i].serializer;
  child_ctx[27] = i;
  return child_ctx;
}
function get_each_context_1$2(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list2[i].label;
  child_ctx[23] = list2[i].parameter_name;
  child_ctx[29] = list2[i].type;
  child_ctx[21] = list2[i].python_type;
  child_ctx[30] = list2[i].component;
  child_ctx[22] = list2[i].example_input;
  child_ctx[31] = list2[i].serializer;
  child_ctx[27] = i;
  return child_ctx;
}
function get_each_context_2$1(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list2[i].component;
  child_ctx[22] = list2[i].example_input;
  child_ctx[27] = i;
  return child_ctx;
}
function get_each_context$4(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list2[i].python_type;
  child_ctx[22] = list2[i].example_input;
  child_ctx[23] = list2[i].parameter_name;
  child_ctx[24] = list2[i].parameter_has_default;
  child_ctx[25] = list2[i].parameter_default;
  child_ctx[27] = i;
  return child_ctx;
}
function create_else_block_2$2(ctx) {
  let endpointdetail;
  let current2;
  endpointdetail = new EndpointDetail({
    props: {
      named: (
        /*named*/
        ctx[5]
      ),
      fn_index: (
        /*dependency_index*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(endpointdetail.$$.fragment);
    },
    l(nodes) {
      claim_component(endpointdetail.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(endpointdetail, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const endpointdetail_changes = {};
      if (dirty[0] & /*named*/
      32)
        endpointdetail_changes.named = /*named*/
        ctx2[5];
      if (dirty[0] & /*dependency_index*/
      2)
        endpointdetail_changes.fn_index = /*dependency_index*/
        ctx2[1];
      endpointdetail.$set(endpointdetail_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(endpointdetail.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(endpointdetail.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(endpointdetail, detaching);
    }
  };
}
function create_if_block_9$1(ctx) {
  let endpointdetail;
  let current2;
  endpointdetail = new EndpointDetail({
    props: {
      named: (
        /*named*/
        ctx[5]
      ),
      api_name: (
        /*dependency*/
        ctx[0].api_name
      )
    }
  });
  return {
    c() {
      create_component(endpointdetail.$$.fragment);
    },
    l(nodes) {
      claim_component(endpointdetail.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(endpointdetail, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const endpointdetail_changes = {};
      if (dirty[0] & /*named*/
      32)
        endpointdetail_changes.named = /*named*/
        ctx2[5];
      if (dirty[0] & /*dependency*/
      1)
        endpointdetail_changes.api_name = /*dependency*/
        ctx2[0].api_name;
      endpointdetail.$set(endpointdetail_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(endpointdetail.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(endpointdetail.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(endpointdetail, detaching);
    }
  };
}
function create_if_block_7$3(ctx) {
  let block2;
  let current2;
  block2 = new Block({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block2.$$.fragment);
    },
    l(nodes) {
      claim_component(block2.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block2, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const block_changes = {};
      if (dirty[0] & /*bash_post_code, dependency, normalised_api_prefix, normalised_root, endpoint_parameters*/
      7185 | dirty[1] & /*$$scope*/
      16) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block2.$set(block_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(block2, detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let block2;
  let current2;
  block2 = new Block({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block2.$$.fragment);
    },
    l(nodes) {
      claim_component(block2.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block2, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const block_changes = {};
      if (dirty[0] & /*js_code, endpoint_parameters, dependency, named, dependency_index, username, space_id, root*/
      639 | dirty[1] & /*$$scope*/
      16) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block2.$set(block_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(block2, detaching);
    }
  };
}
function create_if_block$b(ctx) {
  let block2;
  let current2;
  block2 = new Block({
    props: {
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block2.$$.fragment);
    },
    l(nodes) {
      claim_component(block2.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block2, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const block_changes = {};
      if (dirty[0] & /*python_code, dependency, endpoint_parameters, username, space_id, root*/
      349 | dirty[1] & /*$$scope*/
      16) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block2.$set(block_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(block2, detaching);
    }
  };
}
function create_if_block_8$1(ctx) {
  let t;
  return {
    c() {
      t = text$3(",");
    },
    l(nodes) {
      t = claim_text(nodes, ",");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block_3(ctx) {
  let t0;
  let t1_value = represent_value(
    /*example_input*/
    ctx[22],
    /*python_type*/
    ctx[21].type,
    "bash"
  ) + "";
  let t1;
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[27] < /*endpoint_parameters*/
    ctx[4].length - 1 && create_if_block_8$1()
  );
  return {
    c() {
      t0 = text$3("\n							");
      t1 = text$3(t1_value);
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      t0 = claim_text(nodes, "\n							");
      t1 = claim_text(nodes, t1_value);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*endpoint_parameters*/
      16 && t1_value !== (t1_value = represent_value(
        /*example_input*/
        ctx2[22],
        /*python_type*/
        ctx2[21].type,
        "bash"
      ) + ""))
        set_data(t1, t1_value);
      if (
        /*i*/
        ctx2[27] < /*endpoint_parameters*/
        ctx2[4].length - 1
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_8$1();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  var _a2;
  let code2;
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5_value = (
    /*dependency*/
    ctx[0].api_name + ""
  );
  let t5;
  let t6;
  let t7_value = "{";
  let t7;
  let t8;
  let t9;
  let t10_value = "}";
  let t10;
  let t11;
  let t12_value = "{";
  let t12;
  let t13;
  let t14_value = "}";
  let t14;
  let t15;
  let t16;
  let t17;
  let t18;
  let t19_value = (
    /*dependency*/
    ctx[0].api_name + ""
  );
  let t19;
  let t20;
  let current2;
  copybutton = new CopyButton({
    props: {
      code: (
        /*bash_post_code*/
        (_a2 = ctx[10]) == null ? void 0 : _a2.innerText
      )
    }
  });
  let each_value_3 = ensure_array_like(
    /*endpoint_parameters*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3("curl -X POST ");
      t2 = text$3(
        /*normalised_root*/
        ctx[11]
      );
      t3 = text$3(
        /*normalised_api_prefix*/
        ctx[12]
      );
      t4 = text$3("/call/");
      t5 = text$3(t5_value);
      t6 = text$3(` -s -H "Content-Type: application/json" -d '`);
      t7 = text$3(t7_value);
      t8 = text$3('\n  "data": [');
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t9 = text$3("\n]");
      t10 = text$3(t10_value);
      t11 = text$3(`' \\
  | awk -F'"' '`);
      t12 = text$3(t12_value);
      t13 = text$3(" print $4");
      t14 = text$3(t14_value);
      t15 = text$3("'  \\\n  | read EVENT_ID; curl -N ");
      t16 = text$3(
        /*normalised_root*/
        ctx[11]
      );
      t17 = text$3(
        /*normalised_api_prefix*/
        ctx[12]
      );
      t18 = text$3("/call/");
      t19 = text$3(t19_value);
      t20 = text$3("/$EVENT_ID");
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, "curl -X POST ");
      t2 = claim_text(
        pre_nodes,
        /*normalised_root*/
        ctx[11]
      );
      t3 = claim_text(
        pre_nodes,
        /*normalised_api_prefix*/
        ctx[12]
      );
      t4 = claim_text(pre_nodes, "/call/");
      t5 = claim_text(pre_nodes, t5_value);
      t6 = claim_text(pre_nodes, ` -s -H "Content-Type: application/json" -d '`);
      t7 = claim_text(pre_nodes, t7_value);
      t8 = claim_text(pre_nodes, '\n  "data": [');
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(pre_nodes);
      }
      t9 = claim_text(pre_nodes, "\n]");
      t10 = claim_text(pre_nodes, t10_value);
      t11 = claim_text(pre_nodes, `' \\
  | awk -F'"' '`);
      t12 = claim_text(pre_nodes, t12_value);
      t13 = claim_text(pre_nodes, " print $4");
      t14 = claim_text(pre_nodes, t14_value);
      t15 = claim_text(pre_nodes, "'  \\\n  | read EVENT_ID; curl -N ");
      t16 = claim_text(
        pre_nodes,
        /*normalised_root*/
        ctx[11]
      );
      t17 = claim_text(
        pre_nodes,
        /*normalised_api_prefix*/
        ctx[12]
      );
      t18 = claim_text(pre_nodes, "/call/");
      t19 = claim_text(pre_nodes, t19_value);
      t20 = claim_text(pre_nodes, "/$EVENT_ID");
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-114qcyq");
      attr(pre, "class", "svelte-114qcyq");
      attr(code2, "class", "svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t0);
      append_hydration(code2, div1);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      append_hydration(pre, t2);
      append_hydration(pre, t3);
      append_hydration(pre, t4);
      append_hydration(pre, t5);
      append_hydration(pre, t6);
      append_hydration(pre, t7);
      append_hydration(pre, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(pre, null);
        }
      }
      append_hydration(pre, t9);
      append_hydration(pre, t10);
      append_hydration(pre, t11);
      append_hydration(pre, t12);
      append_hydration(pre, t13);
      append_hydration(pre, t14);
      append_hydration(pre, t15);
      append_hydration(pre, t16);
      append_hydration(pre, t17);
      append_hydration(pre, t18);
      append_hydration(pre, t19);
      append_hydration(pre, t20);
      ctx[19](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const copybutton_changes = {};
      if (dirty[0] & /*bash_post_code*/
      1024)
        copybutton_changes.code = /*bash_post_code*/
        (_a3 = ctx2[10]) == null ? void 0 : _a3.innerText;
      copybutton.$set(copybutton_changes);
      if (!current2 || dirty[0] & /*normalised_root*/
      2048)
        set_data(
          t2,
          /*normalised_root*/
          ctx2[11]
        );
      if (!current2 || dirty[0] & /*normalised_api_prefix*/
      4096)
        set_data(
          t3,
          /*normalised_api_prefix*/
          ctx2[12]
        );
      if ((!current2 || dirty[0] & /*dependency*/
      1) && t5_value !== (t5_value = /*dependency*/
      ctx2[0].api_name + ""))
        set_data(t5, t5_value);
      if (dirty[0] & /*endpoint_parameters*/
      16) {
        each_value_3 = ensure_array_like(
          /*endpoint_parameters*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(pre, t9);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (!current2 || dirty[0] & /*normalised_root*/
      2048)
        set_data(
          t16,
          /*normalised_root*/
          ctx2[11]
        );
      if (!current2 || dirty[0] & /*normalised_api_prefix*/
      4096)
        set_data(
          t17,
          /*normalised_api_prefix*/
          ctx2[12]
        );
      if ((!current2 || dirty[0] & /*dependency*/
      1) && t19_value !== (t19_value = /*dependency*/
      ctx2[0].api_name + ""))
        set_data(t19, t19_value);
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      destroy_each(each_blocks, detaching);
      ctx[19](null);
    }
  };
}
function create_each_block_2$1(ctx) {
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*example_input*/
    ctx[22].url + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*component*/
    ctx[30] + ""
  );
  let t5;
  let t6;
  let t7;
  let t8;
  return {
    c() {
      t0 = text$3("\nconst response_");
      t1 = text$3(
        /*i*/
        ctx[27]
      );
      t2 = text$3(' = await fetch("');
      t3 = text$3(t3_value);
      t4 = text$3('");\nconst example');
      t5 = text$3(t5_value);
      t6 = text$3(" = await response_");
      t7 = text$3(
        /*i*/
        ctx[27]
      );
      t8 = text$3(".blob();\n						");
    },
    l(nodes) {
      t0 = claim_text(nodes, "\nconst response_");
      t1 = claim_text(
        nodes,
        /*i*/
        ctx[27]
      );
      t2 = claim_text(nodes, ' = await fetch("');
      t3 = claim_text(nodes, t3_value);
      t4 = claim_text(nodes, '");\nconst example');
      t5 = claim_text(nodes, t5_value);
      t6 = claim_text(nodes, " = await response_");
      t7 = claim_text(
        nodes,
        /*i*/
        ctx[27]
      );
      t8 = claim_text(nodes, ".blob();\n						");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, t4, anchor);
      insert_hydration(target, t5, anchor);
      insert_hydration(target, t6, anchor);
      insert_hydration(target, t7, anchor);
      insert_hydration(target, t8, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
      }
    }
  };
}
function create_if_block_6$3(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text$3(', {auth: ["');
      t1 = text$3(
        /*username*/
        ctx[6]
      );
      t2 = text$3('", **password**]}');
    },
    l(nodes) {
      t0 = claim_text(nodes, ', {auth: ["');
      t1 = claim_text(
        nodes,
        /*username*/
        ctx[6]
      );
      t2 = claim_text(nodes, '", **password**]}');
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*username*/
      64)
        set_data(
          t1,
          /*username*/
          ctx2[6]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_else_block_1$3(ctx) {
  let t;
  return {
    c() {
      t = text$3(
        /*dependency_index*/
        ctx[1]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*dependency_index*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*dependency_index*/
      2)
        set_data(
          t,
          /*dependency_index*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_5$4(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*dependency*/
    ctx[0].api_name + ""
  );
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text$3('"/');
      t1 = text$3(t1_value);
      t2 = text$3('"');
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, '"/');
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, '"');
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "api-name svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t0);
      append_hydration(span, t1);
      append_hydration(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*dependency*/
      1 && t1_value !== (t1_value = /*dependency*/
      ctx2[0].api_name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$3(ctx) {
  let t0;
  let span;
  let t1_value = (
    /*parameter_name*/
    ctx[23] + ""
  );
  let t1;
  let t2;
  let t3_value = represent_value(
    /*example_input*/
    ctx[22],
    /*python_type*/
    ctx[21].type,
    "js"
  ) + "";
  let t3;
  let t4;
  return {
    c() {
      t0 = text$3("		\n		");
      span = element("span");
      t1 = text$3(t1_value);
      t2 = text$3(": ");
      t3 = text$3(t3_value);
      t4 = text$3(", ");
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "		\n		");
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, ": ");
      t3 = claim_text(span_nodes, t3_value);
      span_nodes.forEach(detach);
      t4 = claim_text(nodes, ", ");
      this.h();
    },
    h() {
      attr(span, "class", "example-inputs");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t1);
      append_hydration(span, t2);
      append_hydration(span, t3);
      insert_hydration(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*endpoint_parameters*/
      16 && t1_value !== (t1_value = /*parameter_name*/
      ctx2[23] + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*endpoint_parameters*/
      16 && t3_value !== (t3_value = represent_value(
        /*example_input*/
        ctx2[22],
        /*python_type*/
        ctx2[21].type,
        "js"
      ) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
        detach(t4);
      }
    }
  };
}
function create_if_block_4$4(ctx) {
  let t0;
  let span0;
  let t1_value = (
    /*parameter_name*/
    ctx[23] + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*component*/
    ctx[30] + ""
  );
  let t3;
  let t4;
  let span1;
  let textContent = ``;
  return {
    c() {
      t0 = text$3("\n				");
      span0 = element("span");
      t1 = text$3(t1_value);
      t2 = text$3(": example");
      t3 = text$3(t3_value);
      t4 = text$3(", ");
      span1 = element("span");
      span1.innerHTML = textContent;
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "\n				");
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      t2 = claim_text(span0_nodes, ": example");
      t3 = claim_text(span0_nodes, t3_value);
      span0_nodes.forEach(detach);
      t4 = claim_text(nodes, ", ");
      span1 = claim_element(nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-1hu8bzt")
        span1.innerHTML = textContent;
      this.h();
    },
    h() {
      attr(span0, "class", "example-inputs");
      attr(span1, "class", "desc svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span0, anchor);
      append_hydration(span0, t1);
      append_hydration(span0, t2);
      append_hydration(span0, t3);
      insert_hydration(target, t4, anchor);
      insert_hydration(target, span1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*endpoint_parameters*/
      16 && t1_value !== (t1_value = /*parameter_name*/
      ctx2[23] + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*endpoint_parameters*/
      16 && t3_value !== (t3_value = /*component*/
      ctx2[30] + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span0);
        detach(t4);
        detach(span1);
      }
    }
  };
}
function create_each_block_1$2(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (dirty[0] & /*endpoint_parameters*/
    16)
      show_if = null;
    if (show_if == null)
      show_if = !!/*blob_components*/
      ctx2[14].includes(
        /*component*/
        ctx2[30]
      );
    if (show_if)
      return create_if_block_4$4;
    return create_else_block$3;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  var _a2;
  let code2;
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let t2;
  let span;
  let t3;
  let t4_value = (
    /*space_id*/
    (ctx[3] || /*root*/
    ctx[2]) + ""
  );
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let current2;
  copybutton = new CopyButton({
    props: { code: (
      /*js_code*/
      (_a2 = ctx[9]) == null ? void 0 : _a2.innerText
    ) }
  });
  let each_value_2 = ensure_array_like(
    /*blob_examples*/
    ctx[15]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
  }
  let if_block0 = (
    /*username*/
    ctx[6] !== null && create_if_block_6$3(ctx)
  );
  function select_block_type_2(ctx2, dirty) {
    if (
      /*named*/
      ctx2[5]
    )
      return create_if_block_5$4;
    return create_else_block_1$3;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block1 = current_block_type(ctx);
  let each_value_1 = ensure_array_like(
    /*endpoint_parameters*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3('import { Client } from "@gradio/client";\n');
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = text$3("\nconst client = await Client.connect(");
      span = element("span");
      t3 = text$3('"');
      t4 = text$3(t4_value);
      t5 = text$3('"');
      if (if_block0)
        if_block0.c();
      t6 = text$3(");\nconst result = await client.predict(");
      if_block1.c();
      t7 = text$3(", { ");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t8 = text$3("\n});\n\nconsole.log(result.data);\n");
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, 'import { Client } from "@gradio/client";\n');
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(pre_nodes);
      }
      t2 = claim_text(pre_nodes, "\nconst client = await Client.connect(");
      span = claim_element(pre_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t3 = claim_text(span_nodes, '"');
      t4 = claim_text(span_nodes, t4_value);
      t5 = claim_text(span_nodes, '"');
      span_nodes.forEach(detach);
      if (if_block0)
        if_block0.l(pre_nodes);
      t6 = claim_text(pre_nodes, ");\nconst result = await client.predict(");
      if_block1.l(pre_nodes);
      t7 = claim_text(pre_nodes, ", { ");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(pre_nodes);
      }
      t8 = claim_text(pre_nodes, "\n});\n\nconsole.log(result.data);\n");
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-114qcyq");
      attr(span, "class", "token string svelte-114qcyq");
      attr(pre, "class", "svelte-114qcyq");
      attr(code2, "class", "svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t0);
      append_hydration(code2, div1);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(pre, null);
        }
      }
      append_hydration(pre, t2);
      append_hydration(pre, span);
      append_hydration(span, t3);
      append_hydration(span, t4);
      append_hydration(span, t5);
      if (if_block0)
        if_block0.m(pre, null);
      append_hydration(pre, t6);
      if_block1.m(pre, null);
      append_hydration(pre, t7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(pre, null);
        }
      }
      append_hydration(pre, t8);
      ctx[18](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const copybutton_changes = {};
      if (dirty[0] & /*js_code*/
      512)
        copybutton_changes.code = /*js_code*/
        (_a3 = ctx2[9]) == null ? void 0 : _a3.innerText;
      copybutton.$set(copybutton_changes);
      if (dirty[0] & /*blob_examples*/
      32768) {
        each_value_2 = ensure_array_like(
          /*blob_examples*/
          ctx2[15]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2$1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(pre, t2);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if ((!current2 || dirty[0] & /*space_id, root*/
      12) && t4_value !== (t4_value = /*space_id*/
      (ctx2[3] || /*root*/
      ctx2[2]) + ""))
        set_data(t4, t4_value);
      if (
        /*username*/
        ctx2[6] !== null
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$3(ctx2);
          if_block0.c();
          if_block0.m(pre, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(pre, t7);
        }
      }
      if (dirty[0] & /*endpoint_parameters, blob_components*/
      16400) {
        each_value_1 = ensure_array_like(
          /*endpoint_parameters*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(pre, t8);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      destroy_each(each_blocks_1, detaching);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      destroy_each(each_blocks, detaching);
      ctx[18](null);
    }
  };
}
function create_if_block_2$7(ctx) {
  let t;
  return {
    c() {
      t = text$3(", handle_file");
    },
    l(nodes) {
      t = claim_text(nodes, ", handle_file");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1$7(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text$3(', auth=("');
      t1 = text$3(
        /*username*/
        ctx[6]
      );
      t2 = text$3('", **password**)');
    },
    l(nodes) {
      t0 = claim_text(nodes, ', auth=("');
      t1 = claim_text(
        nodes,
        /*username*/
        ctx[6]
      );
      t2 = claim_text(nodes, '", **password**)');
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*username*/
      64)
        set_data(
          t1,
          /*username*/
          ctx2[6]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_each_block$4(ctx) {
  let t0;
  let t1_value = (
    /*parameter_name*/
    ctx[23] ? (
      /*parameter_name*/
      ctx[23] + "="
    ) : ""
  );
  let t1;
  let span;
  let t2_value = represent_value(
    /*parameter_has_default*/
    ctx[24] ? (
      /*parameter_default*/
      ctx[25]
    ) : (
      /*example_input*/
      ctx[22]
    ),
    /*python_type*/
    ctx[21].type,
    "py"
  ) + "";
  let t2;
  let t3;
  return {
    c() {
      t0 = text$3("\n		");
      t1 = text$3(t1_value);
      span = element("span");
      t2 = text$3(t2_value);
      t3 = text$3(",");
    },
    l(nodes) {
      t0 = claim_text(nodes, "\n		");
      t1 = claim_text(nodes, t1_value);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, t2_value);
      span_nodes.forEach(detach);
      t3 = claim_text(nodes, ",");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t2);
      insert_hydration(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*endpoint_parameters*/
      16 && t1_value !== (t1_value = /*parameter_name*/
      ctx2[23] ? (
        /*parameter_name*/
        ctx2[23] + "="
      ) : ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*endpoint_parameters*/
      16 && t2_value !== (t2_value = represent_value(
        /*parameter_has_default*/
        ctx2[24] ? (
          /*parameter_default*/
          ctx2[25]
        ) : (
          /*example_input*/
          ctx2[22]
        ),
        /*python_type*/
        ctx2[21].type,
        "py"
      ) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(span);
        detach(t3);
      }
    }
  };
}
function create_default_slot$8(ctx) {
  var _a2;
  let code2;
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let span0;
  let textContent = "from";
  let t2;
  let span1;
  let textContent_1 = "import";
  let t4;
  let t5;
  let span2;
  let t6;
  let t7_value = (
    /*space_id*/
    (ctx[3] || /*root*/
    ctx[2]) + ""
  );
  let t7;
  let t8;
  let t9;
  let span3;
  let textContent_2 = "predict";
  let t11;
  let t12;
  let span4;
  let t13;
  let t14_value = (
    /*dependency*/
    ctx[0].api_name + ""
  );
  let t14;
  let t15;
  let t16;
  let span5;
  let textContent_3 = "print";
  let t18;
  let current2;
  copybutton = new CopyButton({
    props: { code: (
      /*python_code*/
      (_a2 = ctx[8]) == null ? void 0 : _a2.innerText
    ) }
  });
  let if_block0 = (
    /*has_file_path*/
    ctx[13] && create_if_block_2$7()
  );
  let if_block1 = (
    /*username*/
    ctx[6] !== null && create_if_block_1$7(ctx)
  );
  let each_value = ensure_array_like(
    /*endpoint_parameters*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      span0 = element("span");
      span0.textContent = textContent;
      t2 = text$3(" gradio_client ");
      span1 = element("span");
      span1.textContent = textContent_1;
      t4 = text$3(" Client");
      if (if_block0)
        if_block0.c();
      t5 = text$3("\n\nclient = Client(");
      span2 = element("span");
      t6 = text$3('"');
      t7 = text$3(t7_value);
      t8 = text$3('"');
      if (if_block1)
        if_block1.c();
      t9 = text$3(")\nresult = client.");
      span3 = element("span");
      span3.textContent = textContent_2;
      t11 = text$3("(");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = text$3("\n		api_name=");
      span4 = element("span");
      t13 = text$3('"/');
      t14 = text$3(t14_value);
      t15 = text$3('"');
      t16 = text$3("\n)\n");
      span5 = element("span");
      span5.textContent = textContent_3;
      t18 = text$3("(result)");
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      span0 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-18n0cfl")
        span0.textContent = textContent;
      t2 = claim_text(pre_nodes, " gradio_client ");
      span1 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-18nlj6v")
        span1.textContent = textContent_1;
      t4 = claim_text(pre_nodes, " Client");
      if (if_block0)
        if_block0.l(pre_nodes);
      t5 = claim_text(pre_nodes, "\n\nclient = Client(");
      span2 = claim_element(pre_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t6 = claim_text(span2_nodes, '"');
      t7 = claim_text(span2_nodes, t7_value);
      t8 = claim_text(span2_nodes, '"');
      span2_nodes.forEach(detach);
      if (if_block1)
        if_block1.l(pre_nodes);
      t9 = claim_text(pre_nodes, ")\nresult = client.");
      span3 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span3) !== "svelte-1qlwf3g")
        span3.textContent = textContent_2;
      t11 = claim_text(pre_nodes, "(");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(pre_nodes);
      }
      t12 = claim_text(pre_nodes, "\n		api_name=");
      span4 = claim_element(pre_nodes, "SPAN", { class: true });
      var span4_nodes = children(span4);
      t13 = claim_text(span4_nodes, '"/');
      t14 = claim_text(span4_nodes, t14_value);
      t15 = claim_text(span4_nodes, '"');
      span4_nodes.forEach(detach);
      t16 = claim_text(pre_nodes, "\n)\n");
      span5 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span5) !== "svelte-g689qk")
        span5.textContent = textContent_3;
      t18 = claim_text(pre_nodes, "(result)");
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-114qcyq");
      attr(span0, "class", "highlight");
      attr(span1, "class", "highlight");
      attr(span2, "class", "token string svelte-114qcyq");
      attr(span3, "class", "highlight");
      attr(span4, "class", "api-name svelte-114qcyq");
      attr(span5, "class", "highlight");
      attr(pre, "class", "svelte-114qcyq");
      attr(code2, "class", "svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t0);
      append_hydration(code2, div1);
      append_hydration(div1, pre);
      append_hydration(pre, span0);
      append_hydration(pre, t2);
      append_hydration(pre, span1);
      append_hydration(pre, t4);
      if (if_block0)
        if_block0.m(pre, null);
      append_hydration(pre, t5);
      append_hydration(pre, span2);
      append_hydration(span2, t6);
      append_hydration(span2, t7);
      append_hydration(span2, t8);
      if (if_block1)
        if_block1.m(pre, null);
      append_hydration(pre, t9);
      append_hydration(pre, span3);
      append_hydration(pre, t11);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(pre, null);
        }
      }
      append_hydration(pre, t12);
      append_hydration(pre, span4);
      append_hydration(span4, t13);
      append_hydration(span4, t14);
      append_hydration(span4, t15);
      append_hydration(pre, t16);
      append_hydration(pre, span5);
      append_hydration(pre, t18);
      ctx[17](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const copybutton_changes = {};
      if (dirty[0] & /*python_code*/
      256)
        copybutton_changes.code = /*python_code*/
        (_a3 = ctx2[8]) == null ? void 0 : _a3.innerText;
      copybutton.$set(copybutton_changes);
      if ((!current2 || dirty[0] & /*space_id, root*/
      12) && t7_value !== (t7_value = /*space_id*/
      (ctx2[3] || /*root*/
      ctx2[2]) + ""))
        set_data(t7, t7_value);
      if (
        /*username*/
        ctx2[6] !== null
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$7(ctx2);
          if_block1.c();
          if_block1.m(pre, t9);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*endpoint_parameters*/
      16) {
        each_value = ensure_array_like(
          /*endpoint_parameters*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(pre, t12);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if ((!current2 || dirty[0] & /*dependency*/
      1) && t14_value !== (t14_value = /*dependency*/
      ctx2[0].api_name + ""))
        set_data(t14, t14_value);
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      ctx[17](null);
    }
  };
}
function create_fragment$d(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current_block_type_index_1;
  let if_block1;
  let current2;
  const if_block_creators = [create_if_block_9$1, create_else_block_2$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*named*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block$b, create_if_block_3$5, create_if_block_7$3];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[7] === "python"
    )
      return 0;
    if (
      /*current_language*/
      ctx2[7] === "javascript"
    )
      return 1;
    if (
      /*current_language*/
      ctx2[7] === "bash"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
    if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  }
  return {
    c() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "container svelte-114qcyq");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration(div, t);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].m(div, null);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if (~current_block_type_index_1) {
          if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
            if_blocks_1[previous_block_index_1] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_1) {
          if_block1 = if_blocks_1[current_block_type_index_1];
          if (!if_block1) {
            if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current2 = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].d();
      }
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let normalised_api_prefix;
  let normalised_root;
  let { dependency } = $$props;
  let { dependency_index } = $$props;
  let { root } = $$props;
  let { api_prefix } = $$props;
  let { space_id } = $$props;
  let { endpoint_parameters } = $$props;
  let { named } = $$props;
  let { username } = $$props;
  let { current_language } = $$props;
  let python_code;
  let js_code;
  let bash_post_code;
  let has_file_path = endpoint_parameters.some((param) => is_potentially_nested_file_data(param.example_input));
  let blob_components = ["Audio", "File", "Image", "Video"];
  let blob_examples = endpoint_parameters.filter((param) => blob_components.includes(param.component));
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      python_code = $$value;
      $$invalidate(8, python_code);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      js_code = $$value;
      $$invalidate(9, js_code);
    });
  }
  function div1_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bash_post_code = $$value;
      $$invalidate(10, bash_post_code);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dependency" in $$props2)
      $$invalidate(0, dependency = $$props2.dependency);
    if ("dependency_index" in $$props2)
      $$invalidate(1, dependency_index = $$props2.dependency_index);
    if ("root" in $$props2)
      $$invalidate(2, root = $$props2.root);
    if ("api_prefix" in $$props2)
      $$invalidate(16, api_prefix = $$props2.api_prefix);
    if ("space_id" in $$props2)
      $$invalidate(3, space_id = $$props2.space_id);
    if ("endpoint_parameters" in $$props2)
      $$invalidate(4, endpoint_parameters = $$props2.endpoint_parameters);
    if ("named" in $$props2)
      $$invalidate(5, named = $$props2.named);
    if ("username" in $$props2)
      $$invalidate(6, username = $$props2.username);
    if ("current_language" in $$props2)
      $$invalidate(7, current_language = $$props2.current_language);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*api_prefix*/
    65536) {
      $$invalidate(12, normalised_api_prefix = api_prefix ? api_prefix : "/");
    }
    if ($$self.$$.dirty[0] & /*root*/
    4) {
      $$invalidate(11, normalised_root = root.replace(/\/$/, ""));
    }
  };
  return [
    dependency,
    dependency_index,
    root,
    space_id,
    endpoint_parameters,
    named,
    username,
    current_language,
    python_code,
    js_code,
    bash_post_code,
    normalised_root,
    normalised_api_prefix,
    has_file_path,
    blob_components,
    blob_examples,
    api_prefix,
    div1_binding,
    div1_binding_1,
    div1_binding_2
  ];
}
class CodeSnippet extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(
      this,
      options2,
      instance$c,
      create_fragment$d,
      safe_not_equal,
      {
        dependency: 0,
        dependency_index: 1,
        root: 2,
        api_prefix: 16,
        space_id: 3,
        endpoint_parameters: 4,
        named: 5,
        username: 6,
        current_language: 7
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context_2(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list2[i].call;
  child_ctx[21] = list2[i].api_name;
  return child_ctx;
}
function get_each_context_1$1(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list2[i].call;
  child_ctx[21] = list2[i].api_name;
  return child_ctx;
}
function get_each_context$3(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list2[i].call;
  child_ctx[21] = list2[i].api_name;
  return child_ctx;
}
function create_if_block_5$3(ctx) {
  var _a2;
  let code2;
  let div0;
  let copybutton;
  let t;
  let div1;
  let current2;
  copybutton = new CopyButton({
    props: { code: (
      /*bash_code*/
      (_a2 = ctx[6]) == null ? void 0 : _a2.innerText
    ) }
  });
  let each_value_2 = ensure_array_like(
    /*bash_zipped*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-j71ub0");
      attr(code2, "class", "svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t);
      append_hydration(code2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      ctx[16](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const copybutton_changes = {};
      if (dirty & /*bash_code*/
      64)
        copybutton_changes.code = /*bash_code*/
        (_a3 = ctx2[6]) == null ? void 0 : _a3.innerText;
      copybutton.$set(copybutton_changes);
      if (dirty & /*bash_zipped, short_root*/
      513) {
        each_value_2 = ensure_array_like(
          /*bash_zipped*/
          ctx2[9]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      destroy_each(each_blocks, detaching);
      ctx[16](null);
    }
  };
}
function create_if_block_2$6(ctx) {
  var _a2;
  let code2;
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let t1;
  let span;
  let t2;
  let t3;
  let t4;
  let t5;
  let current2;
  copybutton = new CopyButton({
    props: { code: (
      /*js_code*/
      (_a2 = ctx[5]) == null ? void 0 : _a2.innerText
    ) }
  });
  let if_block = (
    /*username*/
    ctx[2] !== null && create_if_block_4$3(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*js_zipped*/
    ctx[8]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      t1 = text$3('import { Client } from "@gradio/client";\n\nconst app = await Client.connect(');
      span = element("span");
      t2 = text$3('"');
      t3 = text$3(
        /*short_root*/
        ctx[0]
      );
      t4 = text$3('"');
      if (if_block)
        if_block.c();
      t5 = text$3(");\n					");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t1 = claim_text(pre_nodes, 'import { Client } from "@gradio/client";\n\nconst app = await Client.connect(');
      span = claim_element(pre_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, '"');
      t3 = claim_text(
        span_nodes,
        /*short_root*/
        ctx[0]
      );
      t4 = claim_text(span_nodes, '"');
      span_nodes.forEach(detach);
      if (if_block)
        if_block.l(pre_nodes);
      t5 = claim_text(pre_nodes, ");\n					");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(pre_nodes);
      }
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-j71ub0");
      attr(span, "class", "token string svelte-j71ub0");
      attr(pre, "class", "svelte-j71ub0");
      attr(code2, "class", "svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t0);
      append_hydration(code2, div1);
      append_hydration(div1, pre);
      append_hydration(pre, t1);
      append_hydration(pre, span);
      append_hydration(span, t2);
      append_hydration(span, t3);
      append_hydration(span, t4);
      if (if_block)
        if_block.m(pre, null);
      append_hydration(pre, t5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(pre, null);
        }
      }
      ctx[15](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3;
      const copybutton_changes = {};
      if (dirty & /*js_code*/
      32)
        copybutton_changes.code = /*js_code*/
        (_a3 = ctx2[5]) == null ? void 0 : _a3.innerText;
      copybutton.$set(copybutton_changes);
      if (!current2 || dirty & /*short_root*/
      1)
        set_data(
          t3,
          /*short_root*/
          ctx2[0]
        );
      if (
        /*username*/
        ctx2[2] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$3(ctx2);
          if_block.c();
          if_block.m(pre, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*js_zipped*/
      256) {
        each_value_1 = ensure_array_like(
          /*js_zipped*/
          ctx2[8]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(pre, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      ctx[15](null);
    }
  };
}
function create_if_block$a(ctx) {
  let code2;
  let div0;
  let copybutton;
  let t0;
  let div1;
  let pre;
  let span0;
  let textContent = "from";
  let t2;
  let span1;
  let textContent_1 = "import";
  let t4;
  let span2;
  let t5;
  let t6;
  let t7;
  let t8;
  let current2;
  copybutton = new CopyButton({
    props: { code: (
      /*python_code_text*/
      ctx[4]
    ) }
  });
  let if_block = (
    /*username*/
    ctx[2] !== null && create_if_block_1$6(ctx)
  );
  let each_value = ensure_array_like(
    /*py_zipped*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  return {
    c() {
      code2 = element("code");
      div0 = element("div");
      create_component(copybutton.$$.fragment);
      t0 = space();
      div1 = element("div");
      pre = element("pre");
      span0 = element("span");
      span0.textContent = textContent;
      t2 = text$3(" gradio_client ");
      span1 = element("span");
      span1.textContent = textContent_1;
      t4 = text$3(" Client, file\n\nclient = Client(");
      span2 = element("span");
      t5 = text$3('"');
      t6 = text$3(
        /*short_root*/
        ctx[0]
      );
      t7 = text$3('"');
      if (if_block)
        if_block.c();
      t8 = text$3(")\n");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      code2 = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code2);
      div0 = claim_element(code_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(copybutton.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(code_nodes);
      div1 = claim_element(code_nodes, "DIV", {});
      var div1_nodes = children(div1);
      pre = claim_element(div1_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      span0 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-18n0cfl")
        span0.textContent = textContent;
      t2 = claim_text(pre_nodes, " gradio_client ");
      span1 = claim_element(pre_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-18nlj6v")
        span1.textContent = textContent_1;
      t4 = claim_text(pre_nodes, " Client, file\n\nclient = Client(");
      span2 = claim_element(pre_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t5 = claim_text(span2_nodes, '"');
      t6 = claim_text(
        span2_nodes,
        /*short_root*/
        ctx[0]
      );
      t7 = claim_text(span2_nodes, '"');
      span2_nodes.forEach(detach);
      if (if_block)
        if_block.l(pre_nodes);
      t8 = claim_text(pre_nodes, ")\n");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(pre_nodes);
      }
      pre_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      code_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "copy svelte-j71ub0");
      attr(span0, "class", "highlight");
      attr(span1, "class", "highlight");
      attr(span2, "class", "token string svelte-j71ub0");
      attr(pre, "class", "svelte-j71ub0");
      attr(code2, "class", "svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, code2, anchor);
      append_hydration(code2, div0);
      mount_component(copybutton, div0, null);
      append_hydration(code2, t0);
      append_hydration(code2, div1);
      append_hydration(div1, pre);
      append_hydration(pre, span0);
      append_hydration(pre, t2);
      append_hydration(pre, span1);
      append_hydration(pre, t4);
      append_hydration(pre, span2);
      append_hydration(span2, t5);
      append_hydration(span2, t6);
      append_hydration(span2, t7);
      if (if_block)
        if_block.m(pre, null);
      append_hydration(pre, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(pre, null);
        }
      }
      ctx[14](div1);
      current2 = true;
    },
    p(ctx2, dirty) {
      const copybutton_changes = {};
      if (dirty & /*python_code_text*/
      16)
        copybutton_changes.code = /*python_code_text*/
        ctx2[4];
      copybutton.$set(copybutton_changes);
      if (!current2 || dirty & /*short_root*/
      1)
        set_data(
          t6,
          /*short_root*/
          ctx2[0]
        );
      if (
        /*username*/
        ctx2[2] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          if_block.m(pre, t8);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*py_zipped*/
      128) {
        each_value = ensure_array_like(
          /*py_zipped*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(pre, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(copybutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copybutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(code2);
      }
      destroy_component(copybutton);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      ctx[14](null);
    }
  };
}
function create_each_block_2(ctx) {
  let pre;
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*api_name*/
    ctx[21] + ""
  );
  let t3;
  let t4;
  let t5_value = "{";
  let t5;
  let t6;
  let t7_value = (
    /*call*/
    ctx[20] + ""
  );
  let t7;
  let t8;
  let t9_value = "}";
  let t9;
  let t10;
  let t11_value = "{";
  let t11;
  let t12;
  let t13_value = "}";
  let t13;
  let t14;
  let t15;
  let t16;
  let t17_value = (
    /*api_name*/
    ctx[21] + ""
  );
  let t17;
  let t18;
  let t19;
  let br2;
  return {
    c() {
      pre = element("pre");
      t0 = text$3("curl -X POST ");
      t1 = text$3(
        /*short_root*/
        ctx[0]
      );
      t2 = text$3("call/");
      t3 = text$3(t3_value);
      t4 = text$3(` -s -H "Content-Type: application/json" -d '`);
      t5 = text$3(t5_value);
      t6 = text$3(' \n	"data": [');
      t7 = text$3(t7_value);
      t8 = text$3("]");
      t9 = text$3(t9_value);
      t10 = text$3(`' \\
  | awk -F'"' '`);
      t11 = text$3(t11_value);
      t12 = text$3(" print $4");
      t13 = text$3(t13_value);
      t14 = text$3("' \\\n  | read EVENT_ID; curl -N ");
      t15 = text$3(
        /*short_root*/
        ctx[0]
      );
      t16 = text$3("call/");
      t17 = text$3(t17_value);
      t18 = text$3("/$EVENT_ID");
      t19 = space();
      br2 = element("br");
      this.h();
    },
    l(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "curl -X POST ");
      t1 = claim_text(
        pre_nodes,
        /*short_root*/
        ctx[0]
      );
      t2 = claim_text(pre_nodes, "call/");
      t3 = claim_text(pre_nodes, t3_value);
      t4 = claim_text(pre_nodes, ` -s -H "Content-Type: application/json" -d '`);
      t5 = claim_text(pre_nodes, t5_value);
      t6 = claim_text(pre_nodes, ' \n	"data": [');
      t7 = claim_text(pre_nodes, t7_value);
      t8 = claim_text(pre_nodes, "]");
      t9 = claim_text(pre_nodes, t9_value);
      t10 = claim_text(pre_nodes, `' \\
  | awk -F'"' '`);
      t11 = claim_text(pre_nodes, t11_value);
      t12 = claim_text(pre_nodes, " print $4");
      t13 = claim_text(pre_nodes, t13_value);
      t14 = claim_text(pre_nodes, "' \\\n  | read EVENT_ID; curl -N ");
      t15 = claim_text(
        pre_nodes,
        /*short_root*/
        ctx[0]
      );
      t16 = claim_text(pre_nodes, "call/");
      t17 = claim_text(pre_nodes, t17_value);
      t18 = claim_text(pre_nodes, "/$EVENT_ID");
      pre_nodes.forEach(detach);
      t19 = claim_space(nodes);
      br2 = claim_element(nodes, "BR", {});
      this.h();
    },
    h() {
      attr(pre, "class", "svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, pre, anchor);
      append_hydration(pre, t0);
      append_hydration(pre, t1);
      append_hydration(pre, t2);
      append_hydration(pre, t3);
      append_hydration(pre, t4);
      append_hydration(pre, t5);
      append_hydration(pre, t6);
      append_hydration(pre, t7);
      append_hydration(pre, t8);
      append_hydration(pre, t9);
      append_hydration(pre, t10);
      append_hydration(pre, t11);
      append_hydration(pre, t12);
      append_hydration(pre, t13);
      append_hydration(pre, t14);
      append_hydration(pre, t15);
      append_hydration(pre, t16);
      append_hydration(pre, t17);
      append_hydration(pre, t18);
      insert_hydration(target, t19, anchor);
      insert_hydration(target, br2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*short_root*/
      1)
        set_data(
          t1,
          /*short_root*/
          ctx2[0]
        );
      if (dirty & /*bash_zipped*/
      512 && t3_value !== (t3_value = /*api_name*/
      ctx2[21] + ""))
        set_data(t3, t3_value);
      if (dirty & /*bash_zipped*/
      512 && t7_value !== (t7_value = /*call*/
      ctx2[20] + ""))
        set_data(t7, t7_value);
      if (dirty & /*short_root*/
      1)
        set_data(
          t15,
          /*short_root*/
          ctx2[0]
        );
      if (dirty & /*bash_zipped*/
      512 && t17_value !== (t17_value = /*api_name*/
      ctx2[21] + ""))
        set_data(t17, t17_value);
    },
    d(detaching) {
      if (detaching) {
        detach(pre);
        detach(t19);
        detach(br2);
      }
    }
  };
}
function create_if_block_4$3(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text$3(', {auth: ["');
      t1 = text$3(
        /*username*/
        ctx[2]
      );
      t2 = text$3('", **password**]}');
    },
    l(nodes) {
      t0 = claim_text(nodes, ', {auth: ["');
      t1 = claim_text(
        nodes,
        /*username*/
        ctx[2]
      );
      t2 = claim_text(nodes, '", **password**]}');
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*username*/
      4)
        set_data(
          t1,
          /*username*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_3$4(ctx) {
  let t0;
  let t1_value = (
    /*call*/
    ctx[20] + ""
  );
  let t1;
  return {
    c() {
      t0 = text$3(", ");
      t1 = text$3(t1_value);
    },
    l(nodes) {
      t0 = claim_text(nodes, ", ");
      t1 = claim_text(nodes, t1_value);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*js_zipped*/
      256 && t1_value !== (t1_value = /*call*/
      ctx2[20] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_1$1(ctx) {
  let t0;
  let span;
  let t1;
  let t2_value = (
    /*api_name*/
    ctx[21] + ""
  );
  let t2;
  let t3;
  let t4;
  let if_block = (
    /*call*/
    ctx[20] && create_if_block_3$4(ctx)
  );
  return {
    c() {
      t0 = text$3("\nawait client.predict(");
      span = element("span");
      t1 = text$3('\n  "/');
      t2 = text$3(t2_value);
      t3 = text$3('"');
      if (if_block)
        if_block.c();
      t4 = text$3(");\n						");
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "\nawait client.predict(");
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, '\n  "/');
      t2 = claim_text(span_nodes, t2_value);
      t3 = claim_text(span_nodes, '"');
      span_nodes.forEach(detach);
      if (if_block)
        if_block.l(nodes);
      t4 = claim_text(nodes, ");\n						");
      this.h();
    },
    h() {
      attr(span, "class", "api-name svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t1);
      append_hydration(span, t2);
      append_hydration(span, t3);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*js_zipped*/
      256 && t2_value !== (t2_value = /*api_name*/
      ctx2[21] + ""))
        set_data(t2, t2_value);
      if (
        /*call*/
        ctx2[20]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$4(ctx2);
          if_block.c();
          if_block.m(t4.parentNode, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
        detach(t4);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$6(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text$3(', auth=("');
      t1 = text$3(
        /*username*/
        ctx[2]
      );
      t2 = text$3('", **password**)');
    },
    l(nodes) {
      t0 = claim_text(nodes, ', auth=("');
      t1 = claim_text(
        nodes,
        /*username*/
        ctx[2]
      );
      t2 = claim_text(nodes, '", **password**)');
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*username*/
      4)
        set_data(
          t1,
          /*username*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_each_block$3(ctx) {
  let t0;
  let span1;
  let t1;
  let t2_value = (
    /*call*/
    ctx[20] + ""
  );
  let t2;
  let t3;
  let span0;
  let t4;
  let t5_value = (
    /*api_name*/
    ctx[21] + ""
  );
  let t5;
  let t6;
  let t7;
  return {
    c() {
      t0 = text$3("\nclient.");
      span1 = element("span");
      t1 = text$3("predict(\n");
      t2 = text$3(t2_value);
      t3 = text$3("  api_name=");
      span0 = element("span");
      t4 = text$3('"/');
      t5 = text$3(t5_value);
      t6 = text$3('"');
      t7 = text$3("\n)\n");
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "\nclient.");
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, "predict(\n");
      t2 = claim_text(span1_nodes, t2_value);
      t3 = claim_text(span1_nodes, "  api_name=");
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t4 = claim_text(span0_nodes, '"/');
      t5 = claim_text(span0_nodes, t5_value);
      t6 = claim_text(span0_nodes, '"');
      span0_nodes.forEach(detach);
      t7 = claim_text(span1_nodes, "\n)\n");
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "api-name svelte-j71ub0");
      attr(span1, "class", "highlight");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span1, anchor);
      append_hydration(span1, t1);
      append_hydration(span1, t2);
      append_hydration(span1, t3);
      append_hydration(span1, span0);
      append_hydration(span0, t4);
      append_hydration(span0, t5);
      append_hydration(span0, t6);
      append_hydration(span1, t7);
    },
    p(ctx2, dirty) {
      if (dirty & /*py_zipped*/
      128 && t2_value !== (t2_value = /*call*/
      ctx2[20] + ""))
        set_data(t2, t2_value);
      if (dirty & /*py_zipped*/
      128 && t5_value !== (t5_value = /*api_name*/
      ctx2[21] + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span1);
      }
    }
  };
}
function create_default_slot$7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block$a, create_if_block_2$6, create_if_block_5$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[1] === "python"
    )
      return 0;
    if (
      /*current_language*/
      ctx2[1] === "javascript"
    )
      return 1;
    if (
      /*current_language*/
      ctx2[1] === "bash"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment$c(ctx) {
  let div;
  let block2;
  let current2;
  block2 = new Block({
    props: {
      border_mode: "focus",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(block2.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(block2.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "container svelte-j71ub0");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(block2, div, null);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const block_changes = {};
      if (dirty & /*$$scope, python_code, py_zipped, username, short_root, python_code_text, current_language, js_code, js_zipped, bash_code, bash_zipped*/
      268436479) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block2.$set(block_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(block2);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { dependencies } = $$props;
  let { short_root } = $$props;
  let { root } = $$props;
  let { api_prefix = "" } = $$props;
  let { current_language } = $$props;
  let { username } = $$props;
  let python_code;
  let python_code_text;
  let js_code;
  let bash_code;
  let { api_calls = [] } = $$props;
  async function get_info() {
    let response = await fetch(root.replace(/\/$/, "") + api_prefix + "/info/?all_endpoints=true");
    let data = await response.json();
    return data;
  }
  let endpoints_info;
  let py_zipped = [];
  let js_zipped = [];
  let bash_zipped = [];
  function format_api_call(call, lang) {
    const api_name = `/${dependencies[call.fn_index].api_name}`;
    let call_data_excluding_state = call.data.filter((d) => typeof d !== "undefined");
    const params = call_data_excluding_state.map((param, index) => {
      if (endpoints_info[api_name]) {
        const param_info = endpoints_info[api_name].parameters[index];
        if (!param_info) {
          return void 0;
        }
        const param_name = param_info.parameter_name;
        const python_type = param_info.python_type.type;
        if (lang === "py") {
          return `  ${param_name}=${represent_value(param, python_type, "py")}`;
        } else if (lang === "js") {
          return `    ${param_name}: ${represent_value(param, python_type, "js")}`;
        } else if (lang === "bash") {
          return `    ${represent_value(param, python_type, "bash")}`;
        }
      }
      return `  ${represent_value(param, void 0, lang)}`;
    }).filter((d) => typeof d !== "undefined").join(",\n");
    if (params) {
      if (lang === "py") {
        return `${params},
`;
      } else if (lang === "js") {
        return `{
${params},
}`;
      } else if (lang === "bash") {
        return `
${params}
`;
      }
    }
    if (lang === "py") {
      return "";
    }
    return "\n";
  }
  onMount(async () => {
    const data = await get_info();
    endpoints_info = data["named_endpoints"];
    let py_api_calls = api_calls.map((call) => format_api_call(call, "py"));
    let js_api_calls = api_calls.map((call) => format_api_call(call, "js"));
    let bash_api_calls = api_calls.map((call) => format_api_call(call, "bash"));
    let api_names = api_calls.map((call) => dependencies[call.fn_index].api_name || "");
    $$invalidate(7, py_zipped = py_api_calls.map((call, index) => ({ call, api_name: api_names[index] })));
    $$invalidate(8, js_zipped = js_api_calls.map((call, index) => ({ call, api_name: api_names[index] })));
    $$invalidate(9, bash_zipped = bash_api_calls.map((call, index) => ({ call, api_name: api_names[index] })));
    await tick();
    $$invalidate(4, python_code_text = python_code.innerText);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      python_code = $$value;
      $$invalidate(3, python_code);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      js_code = $$value;
      $$invalidate(5, js_code);
    });
  }
  function div1_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bash_code = $$value;
      $$invalidate(6, bash_code);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dependencies" in $$props2)
      $$invalidate(10, dependencies = $$props2.dependencies);
    if ("short_root" in $$props2)
      $$invalidate(0, short_root = $$props2.short_root);
    if ("root" in $$props2)
      $$invalidate(11, root = $$props2.root);
    if ("api_prefix" in $$props2)
      $$invalidate(12, api_prefix = $$props2.api_prefix);
    if ("current_language" in $$props2)
      $$invalidate(1, current_language = $$props2.current_language);
    if ("username" in $$props2)
      $$invalidate(2, username = $$props2.username);
    if ("api_calls" in $$props2)
      $$invalidate(13, api_calls = $$props2.api_calls);
  };
  return [
    short_root,
    current_language,
    username,
    python_code,
    python_code_text,
    js_code,
    bash_code,
    py_zipped,
    js_zipped,
    bash_zipped,
    dependencies,
    root,
    api_prefix,
    api_calls,
    div1_binding,
    div1_binding_1,
    div1_binding_2
  ];
}
class RecordingSnippet extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$b, create_fragment$c, safe_not_equal, {
      dependencies: 10,
      short_root: 0,
      root: 11,
      api_prefix: 12,
      current_language: 1,
      username: 2,
      api_calls: 13
    });
  }
}
const python = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20aria-hidden='true'%20focusable='false'%20role='img'%20width='1em'%20height='1em'%20preserveAspectRatio='xMidYMid%20meet'%20viewBox='0%200%2032%2032'%20%3e%3cpath%20d='M15.84.5a16.4,16.4,0,0,0-3.57.32C9.1,1.39,8.53,2.53,8.53,4.64V7.48H16v1H5.77a4.73,4.73,0,0,0-4.7,3.74,14.82,14.82,0,0,0,0,7.54c.57,2.28,1.86,3.82,4,3.82h2.6V20.14a4.73,4.73,0,0,1,4.63-4.63h7.38a3.72,3.72,0,0,0,3.73-3.73V4.64A4.16,4.16,0,0,0,19.65.82,20.49,20.49,0,0,0,15.84.5ZM11.78,2.77a1.39,1.39,0,0,1,1.38,1.46,1.37,1.37,0,0,1-1.38,1.38A1.42,1.42,0,0,1,10.4,4.23,1.44,1.44,0,0,1,11.78,2.77Z'%20fill='%235a9fd4'%20%3e%3c/path%3e%3cpath%20d='M16.16,31.5a16.4,16.4,0,0,0,3.57-.32c3.17-.57,3.74-1.71,3.74-3.82V24.52H16v-1H26.23a4.73,4.73,0,0,0,4.7-3.74,14.82,14.82,0,0,0,0-7.54c-.57-2.28-1.86-3.82-4-3.82h-2.6v3.41a4.73,4.73,0,0,1-4.63,4.63H12.35a3.72,3.72,0,0,0-3.73,3.73v7.14a4.16,4.16,0,0,0,3.73,3.82A20.49,20.49,0,0,0,16.16,31.5Zm4.06-2.27a1.39,1.39,0,0,1-1.38-1.46,1.37,1.37,0,0,1,1.38-1.38,1.42,1.42,0,0,1,1.38,1.38A1.44,1.44,0,0,1,20.22,29.23Z'%20fill='%23ffd43b'%20%3e%3c/path%3e%3c/svg%3e";
const javascript = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20aria-hidden='true'%20focusable='false'%20role='img'%20width='1em'%20height='1em'%20preserveAspectRatio='xMidYMid%20meet'%20viewBox='0%200%2032%2032'%20%3e%3crect%20width='32'%20height='32'%20fill='%23f7df1e'%3e%3c/rect%3e%3cpath%20d='M21.5,25a3.27,3.27,0,0,0,3,1.83c1.25,0,2-.63,2-1.49,0-1-.81-1.39-2.19-2L23.56,23C21.39,22.1,20,20.94,20,18.49c0-2.25,1.72-4,4.41-4a4.44,4.44,0,0,1,4.27,2.41l-2.34,1.5a2,2,0,0,0-1.93-1.29,1.31,1.31,0,0,0-1.44,1.29c0,.9.56,1.27,1.85,1.83l.75.32c2.55,1.1,4,2.21,4,4.72,0,2.71-2.12,4.19-5,4.19a5.78,5.78,0,0,1-5.48-3.07Zm-10.63.26c.48.84.91,1.55,1.94,1.55s1.61-.39,1.61-1.89V14.69h3V25c0,3.11-1.83,4.53-4.49,4.53a4.66,4.66,0,0,1-4.51-2.75Z'%20%3e%3c/path%3e%3c/svg%3e";
const bash = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20version='1.1'%20id='Layer_1'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;%20background-color:%20%2372a824;'%20xml:space='preserve'%3e%3cscript%20xmlns=''/%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%23FFFFFF;}%20%3c/style%3e%3cg%3e%3cpath%20class='st0'%20d='M118.9,40.3L81.7,18.2c-2.2-1.3-4.7-2-7.2-2s-5,0.7-7.2,2L30.1,40.3c-4.4,2.6-7.2,7.5-7.2,12.8v44.2%20c0,5.3,2.7,10.1,7.2,12.8l37.2,22.1c2.2,1.3,4.7,2,7.2,2c2.5,0,5-0.7,7.2-2l37.2-22.1c4.4-2.6,7.2-7.5,7.2-12.8V53%20C126.1,47.8,123.4,42.9,118.9,40.3z%20M90.1,109.3l0.1,3.2c0,0.4-0.2,0.8-0.5,1l-1.9,1.1c-0.3,0.2-0.5,0-0.6-0.4l0-3.1%20c-1.6,0.7-3.2,0.8-4.3,0.4c-0.2-0.1-0.3-0.4-0.2-0.7l0.7-2.9c0.1-0.2,0.2-0.5,0.3-0.6c0.1-0.1,0.1-0.1,0.2-0.1%20c0.1-0.1,0.2-0.1,0.3,0c1.1,0.4,2.6,0.2,3.9-0.5c1.8-0.9,2.9-2.7,2.9-4.5c0-1.6-0.9-2.3-3-2.3c-2.7,0-5.2-0.5-5.3-4.5%20c0-3.3,1.7-6.7,4.4-8.8l0-3.2c0-0.4,0.2-0.8,0.5-1l1.8-1.2c0.3-0.2,0.5,0,0.6,0.4l0,3.2c1.3-0.5,2.5-0.7,3.6-0.4%20c0.2,0.1,0.3,0.4,0.2,0.7l-0.7,2.8c-0.1,0.2-0.2,0.4-0.3,0.6c-0.1,0.1-0.1,0.1-0.2,0.1c-0.1,0-0.2,0.1-0.3,0%20c-0.5-0.1-1.6-0.4-3.4,0.6c-1.9,1-2.6,2.6-2.5,3.8c0,1.5,0.8,1.9,3.3,1.9c3.4,0.1,4.9,1.6,5,5C94.7,103.4,92.9,107,90.1,109.3z%20M109.6,103.9c0,0.3,0,0.6-0.3,0.7l-9.4,5.7c-0.2,0.1-0.4,0-0.4-0.3v-2.4c0-0.3,0.2-0.5,0.4-0.6l9.3-5.5c0.2-0.1,0.4,0,0.4,0.3%20V103.9z%20M116.1,49.6L80.9,71.3c-4.4,2.6-7.6,5.4-7.6,10.7v43.4c0,3.2,1.3,5.2,3.2,5.8c-0.6,0.1-1.3,0.2-2,0.2%20c-2.1,0-4.1-0.6-5.9-1.6l-37.2-22.1c-3.6-2.2-5.9-6.2-5.9-10.5V53c0-4.3,2.3-8.4,5.9-10.5l37.2-22.1c1.8-1.1,3.8-1.6,5.9-1.6%20s4.1,0.6,5.9,1.6l37.2,22.1c3.1,1.8,5.1,5,5.7,8.5C122.1,48.4,119.3,47.7,116.1,49.6z'/%3e%3c/g%3e%3c/svg%3e";
function get_each_context$2(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list2[i].label;
  child_ctx[5] = list2[i].type;
  child_ctx[6] = list2[i].python_type;
  child_ctx[7] = list2[i].component;
  child_ctx[8] = list2[i].serializer;
  child_ctx[10] = i;
  return child_ctx;
}
function create_else_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text$3("1 element");
    },
    l(nodes) {
      t = claim_text(nodes, "1 element");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_3$3(ctx) {
  let t0_value = (
    /*current_language*/
    ctx[3] == "python" ? "tuple" : "list"
  );
  let t0;
  let t1;
  let t2_value = (
    /*endpoint_returns*/
    ctx[1].length + ""
  );
  let t2;
  let t3;
  return {
    c() {
      t0 = text$3(t0_value);
      t1 = text$3(" of ");
      t2 = text$3(t2_value);
      t3 = text$3("\n		elements");
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, " of ");
      t2 = claim_text(nodes, t2_value);
      t3 = claim_text(nodes, "\n		elements");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*current_language*/
      8 && t0_value !== (t0_value = /*current_language*/
      ctx2[3] == "python" ? "tuple" : "list"))
        set_data(t0, t0_value);
      if (dirty & /*endpoint_returns*/
      2 && t2_value !== (t2_value = /*endpoint_returns*/
      ctx2[1].length + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text$3("[");
      t1 = text$3(
        /*i*/
        ctx[10]
      );
      t2 = text$3("]");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "[");
      t1 = claim_text(
        span_nodes,
        /*i*/
        ctx[10]
      );
      t2 = claim_text(span_nodes, "]");
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "code svelte-16h224k");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t0);
      append_hydration(span, t1);
      append_hydration(span, t2);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$2(ctx) {
  let t_value = (
    /*js_returns*/
    ctx[2][
      /*i*/
      ctx[10]
    ].type + ""
  );
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*js_returns*/
      4 && t_value !== (t_value = /*js_returns*/
      ctx2[2][
        /*i*/
        ctx2[10]
      ].type + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1$5(ctx) {
  let t_value = (
    /*python_type*/
    ctx[6].type + ""
  );
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*endpoint_returns*/
      2 && t_value !== (t_value = /*python_type*/
      ctx2[6].type + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block$2(ctx) {
  let hr2;
  let t0;
  let div;
  let p0;
  let t1;
  let span;
  let t2;
  let p1;
  let t3;
  let t4_value = (
    /*label*/
    ctx[4] + ""
  );
  let t4;
  let t5;
  let t6_value = (
    /*component*/
    ctx[7] + ""
  );
  let t6;
  let t7;
  let t8;
  let if_block0 = (
    /*endpoint_returns*/
    ctx[1].length > 1 && create_if_block_2$5(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[3] === "python"
    )
      return create_if_block_1$5;
    return create_else_block$2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      hr2 = element("hr");
      t0 = space();
      div = element("div");
      p0 = element("p");
      if (if_block0)
        if_block0.c();
      t1 = space();
      span = element("span");
      if_block1.c();
      t2 = space();
      p1 = element("p");
      t3 = text$3('The output value that appears in the "');
      t4 = text$3(t4_value);
      t5 = text$3('" ');
      t6 = text$3(t6_value);
      t7 = text$3("\n				component.");
      t8 = space();
      this.h();
    },
    l(nodes) {
      hr2 = claim_element(nodes, "HR", { class: true });
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      p0 = claim_element(div_nodes, "P", {});
      var p0_nodes = children(p0);
      if (if_block0)
        if_block0.l(p0_nodes);
      t1 = claim_space(p0_nodes);
      span = claim_element(p0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      p0_nodes.forEach(detach);
      t2 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      t3 = claim_text(p1_nodes, 'The output value that appears in the "');
      t4 = claim_text(p1_nodes, t4_value);
      t5 = claim_text(p1_nodes, '" ');
      t6 = claim_text(p1_nodes, t6_value);
      t7 = claim_text(p1_nodes, "\n				component.");
      p1_nodes.forEach(detach);
      t8 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(hr2, "class", "hr svelte-16h224k");
      attr(span, "class", "code highlight svelte-16h224k");
      attr(p1, "class", "desc svelte-16h224k");
      set_style(div, "margin", "10px");
    },
    m(target, anchor) {
      insert_hydration(target, hr2, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div, anchor);
      append_hydration(div, p0);
      if (if_block0)
        if_block0.m(p0, null);
      append_hydration(p0, t1);
      append_hydration(p0, span);
      if_block1.m(span, null);
      append_hydration(div, t2);
      append_hydration(div, p1);
      append_hydration(p1, t3);
      append_hydration(p1, t4);
      append_hydration(p1, t5);
      append_hydration(p1, t6);
      append_hydration(p1, t7);
      append_hydration(div, t8);
    },
    p(ctx2, dirty) {
      if (
        /*endpoint_returns*/
        ctx2[1].length > 1
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_2$5(ctx2);
          if_block0.c();
          if_block0.m(p0, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (dirty & /*endpoint_returns*/
      2 && t4_value !== (t4_value = /*label*/
      ctx2[4] + ""))
        set_data(t4, t4_value);
      if (dirty & /*endpoint_returns*/
      2 && t6_value !== (t6_value = /*component*/
      ctx2[7] + ""))
        set_data(t6, t6_value);
    },
    d(detaching) {
      if (detaching) {
        detach(hr2);
        detach(t0);
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function create_if_block$9(ctx) {
  let div;
  let loader;
  let current2;
  loader = new Loader({ props: { margin: false } });
  return {
    c() {
      div = element("div");
      create_component(loader.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(loader.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "load-wrap");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(loader, div, null);
      current2 = true;
    },
    i(local) {
      if (current2)
        return;
      transition_in(loader.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(loader);
    }
  };
}
function create_fragment$b(ctx) {
  let h4;
  let div1;
  let textContent = `<div class="toggle-dot toggle-right svelte-16h224k"></div>`;
  let t0;
  let t1;
  let div2;
  let t2;
  let if_block1_anchor;
  let current2;
  function select_block_type(ctx2, dirty) {
    if (
      /*endpoint_returns*/
      ctx2[1].length > 1
    )
      return create_if_block_3$3;
    return create_else_block_1$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let each_value = ensure_array_like(
    /*endpoint_returns*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  let if_block1 = (
    /*is_running*/
    ctx[0] && create_if_block$9()
  );
  return {
    c() {
      h4 = element("h4");
      div1 = element("div");
      div1.innerHTML = textContent;
      t0 = text$3("\n	Returns ");
      if_block0.c();
      t1 = space();
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      div1 = claim_element(h4_nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div1) !== "svelte-1q6qbuq")
        div1.innerHTML = textContent;
      t0 = claim_text(h4_nodes, "\n	Returns ");
      if_block0.l(h4_nodes);
      h4_nodes.forEach(detach);
      t1 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div2_nodes);
      }
      div2_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div1, "class", "toggle-icon svelte-16h224k");
      attr(h4, "class", "svelte-16h224k");
      toggle_class(
        div2,
        "hide",
        /*is_running*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, h4, anchor);
      append_hydration(h4, div1);
      append_hydration(h4, t0);
      if_block0.m(h4, null);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      insert_hydration(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(h4, null);
        }
      }
      if (dirty & /*endpoint_returns, current_language, js_returns*/
      14) {
        each_value = ensure_array_like(
          /*endpoint_returns*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current2 || dirty & /*is_running*/
      1) {
        toggle_class(
          div2,
          "hide",
          /*is_running*/
          ctx2[0]
        );
      }
      if (
        /*is_running*/
        ctx2[0]
      ) {
        if (if_block1) {
          if (dirty & /*is_running*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$9();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block1);
      current2 = true;
    },
    o(local) {
      transition_out(if_block1);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
        detach(t1);
        detach(div2);
        detach(t2);
        detach(if_block1_anchor);
      }
      if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { is_running: is_running2 } = $$props;
  let { endpoint_returns } = $$props;
  let { js_returns } = $$props;
  let { current_language } = $$props;
  $$self.$$set = ($$props2) => {
    if ("is_running" in $$props2)
      $$invalidate(0, is_running2 = $$props2.is_running);
    if ("endpoint_returns" in $$props2)
      $$invalidate(1, endpoint_returns = $$props2.endpoint_returns);
    if ("js_returns" in $$props2)
      $$invalidate(2, js_returns = $$props2.js_returns);
    if ("current_language" in $$props2)
      $$invalidate(3, current_language = $$props2.current_language);
  };
  return [is_running2, endpoint_returns, js_returns, current_language];
}
class ResponseSnippet extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$a, create_fragment$b, safe_not_equal, {
      is_running: 0,
      endpoint_returns: 1,
      js_returns: 2,
      current_language: 3
    });
  }
}
function get_each_context$1(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list2[i];
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list2[i][0];
  child_ctx[23] = list2[i][1];
  return child_ctx;
}
function create_if_block$8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block_1$4, create_else_block_2$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*api_count*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_2$1(ctx) {
  let noapi;
  let current2;
  noapi = new NoApi({ props: { root: (
    /*root*/
    ctx[0]
  ) } });
  noapi.$on(
    "close",
    /*close_handler_1*/
    ctx[16]
  );
  return {
    c() {
      create_component(noapi.$$.fragment);
    },
    l(nodes) {
      claim_component(noapi.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(noapi, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const noapi_changes = {};
      if (dirty & /*root*/
      1)
        noapi_changes.root = /*root*/
        ctx2[0];
      noapi.$set(noapi_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(noapi.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(noapi.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(noapi, detaching);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div0;
  let apibanner;
  let t0;
  let div4;
  let div1;
  let textContent = `<p style="font-size: var(--text-lg);">Choose a language to see the code snippets for interacting with the
					API.</p>`;
  let t2;
  let div3;
  let div2;
  let t3;
  let current_block_type_index;
  let if_block;
  let t4;
  let current2;
  apibanner = new ApiBanner({
    props: {
      root: (
        /*space_id*/
        ctx[3] || /*root*/
        ctx[0]
      ),
      api_count: (
        /*api_count*/
        ctx[9]
      )
    }
  });
  apibanner.$on(
    "close",
    /*close_handler*/
    ctx[13]
  );
  let each_value_1 = ensure_array_like(
    /*langs*/
    ctx[10]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const if_block_creators = [create_if_block_3$2, create_else_block$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*api_calls*/
      ctx2[5].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value = ensure_array_like(
    /*dependencies*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div0 = element("div");
      create_component(apibanner.$$.fragment);
      t0 = space();
      div4 = element("div");
      div1 = element("div");
      div1.innerHTML = textContent;
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t3 = space();
      if_block.c();
      t4 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(apibanner.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div1 = claim_element(div4_nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div1) !== "svelte-64mi5k")
        div1.innerHTML = textContent;
      t2 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div2_nodes);
      }
      div2_nodes.forEach(detach);
      t3 = claim_space(div3_nodes);
      if_block.l(div3_nodes);
      t4 = claim_space(div3_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div3_nodes);
      }
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "banner-wrap svelte-v3jjme");
      attr(div1, "class", "client-doc svelte-v3jjme");
      attr(div2, "class", "snippets svelte-v3jjme");
      attr(div3, "class", "endpoint svelte-v3jjme");
      attr(div4, "class", "docs-wrap svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(apibanner, div0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div4, anchor);
      append_hydration(div4, div1);
      append_hydration(div4, t2);
      append_hydration(div4, div3);
      append_hydration(div3, div2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div2, null);
        }
      }
      append_hydration(div3, t3);
      if_blocks[current_block_type_index].m(div3, null);
      append_hydration(div3, t4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      const apibanner_changes = {};
      if (dirty & /*space_id, root*/
      9)
        apibanner_changes.root = /*space_id*/
        ctx2[3] || /*root*/
        ctx2[0];
      apibanner.$set(apibanner_changes);
      if (dirty & /*current_language, langs*/
      1088) {
        each_value_1 = ensure_array_like(
          /*langs*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div2, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div3, t4);
      }
      if (dirty & /*info, dependencies, js_info, is_running, current_language, root, space_id, username, app*/
      479) {
        each_value = ensure_array_like(
          /*dependencies*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div3, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(apibanner.$$.fragment, local);
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current2 = true;
    },
    o(local) {
      transition_out(apibanner.$$.fragment, local);
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div4);
      }
      destroy_component(apibanner);
      destroy_each(each_blocks_1, detaching);
      if_blocks[current_block_type_index].d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let li;
  let img_1;
  let img_1_src_value;
  let t0;
  let t1_value = (
    /*language*/
    ctx[22] + ""
  );
  let t1;
  let t2;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[14](
        /*language*/
        ctx[22]
      )
    );
  }
  return {
    c() {
      li = element("li");
      img_1 = element("img");
      t0 = space();
      t1 = text$3(t1_value);
      t2 = space();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      img_1 = claim_element(li_nodes, "IMG", { src: true, alt: true, class: true });
      t0 = claim_space(li_nodes);
      t1 = claim_text(li_nodes, t1_value);
      t2 = claim_space(li_nodes);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[23]))
        attr(img_1, "src", img_1_src_value);
      attr(img_1, "alt", "");
      attr(img_1, "class", "svelte-v3jjme");
      attr(li, "class", li_class_value = "snippet " + /*current_language*/
      (ctx[6] === /*language*/
      ctx[22] ? "current-lang" : "inactive-lang") + " svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, img_1);
      append_hydration(li, t0);
      append_hydration(li, t1);
      append_hydration(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*current_language*/
      64 && li_class_value !== (li_class_value = "snippet " + /*current_language*/
      (ctx[6] === /*language*/
      ctx[22] ? "current-lang" : "inactive-lang") + " svelte-v3jjme")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$1(ctx) {
  let p0;
  let t0;
  let installsnippet;
  let t1;
  let p1;
  let t2;
  let t3;
  let button;
  let t4;
  let current2;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*current_language*/
      ctx2[6] == "python" || /*current_language*/
      ctx2[6] == "javascript"
    )
      return create_if_block_7$2;
    return create_else_block_1$1;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block0 = current_block_type(ctx);
  installsnippet = new InstallSnippet({
    props: {
      current_language: (
        /*current_language*/
        ctx[6]
      )
    }
  });
  let if_block1 = (
    /*space_id*/
    ctx[3] && create_if_block_6$2(ctx)
  );
  button = new Button({
    props: {
      size: "sm",
      variant: "secondary",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler_1*/
    ctx[15]
  );
  let if_block2 = (
    /*current_language*/
    ctx[6] == "bash" && create_if_block_4$2(ctx)
  );
  return {
    c() {
      p0 = element("p");
      if_block0.c();
      t0 = space();
      create_component(installsnippet.$$.fragment);
      t1 = space();
      p1 = element("p");
      t2 = text$3("2. Find the API endpoint below corresponding to your desired\n						function in the app. Copy the code snippet, replacing the\n						placeholder values with your own input data.\n						");
      if (if_block1)
        if_block1.c();
      t3 = text$3("\n\n						Or use the\n						");
      create_component(button.$$.fragment);
      t4 = text$3("\n						to automatically generate your API requests.\n						");
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      p0 = claim_element(nodes, "P", { class: true });
      var p0_nodes = children(p0);
      if_block0.l(p0_nodes);
      p0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      claim_component(installsnippet.$$.fragment, nodes);
      t1 = claim_space(nodes);
      p1 = claim_element(nodes, "P", { class: true });
      var p1_nodes = children(p1);
      t2 = claim_text(p1_nodes, "2. Find the API endpoint below corresponding to your desired\n						function in the app. Copy the code snippet, replacing the\n						placeholder values with your own input data.\n						");
      if (if_block1)
        if_block1.l(p1_nodes);
      t3 = claim_text(p1_nodes, "\n\n						Or use the\n						");
      claim_component(button.$$.fragment, p1_nodes);
      t4 = claim_text(p1_nodes, "\n						to automatically generate your API requests.\n						");
      if (if_block2)
        if_block2.l(p1_nodes);
      p1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p0, "class", "padded svelte-v3jjme");
      attr(p1, "class", "padded svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, p0, anchor);
      if_block0.m(p0, null);
      insert_hydration(target, t0, anchor);
      mount_component(installsnippet, target, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, p1, anchor);
      append_hydration(p1, t2);
      if (if_block1)
        if_block1.m(p1, null);
      append_hydration(p1, t3);
      mount_component(button, p1, null);
      append_hydration(p1, t4);
      if (if_block2)
        if_block2.m(p1, null);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(p0, null);
        }
      }
      const installsnippet_changes = {};
      if (dirty & /*current_language*/
      64)
        installsnippet_changes.current_language = /*current_language*/
        ctx2[6];
      installsnippet.$set(installsnippet_changes);
      if (
        /*space_id*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6$2(ctx2);
          if_block1.c();
          if_block1.m(p1, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const button_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (
        /*current_language*/
        ctx2[6] == "bash"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$2(ctx2);
          if_block2.c();
          if_block2.m(p1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(installsnippet.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(installsnippet.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t0);
        detach(t1);
        detach(p1);
      }
      if_block0.d();
      destroy_component(installsnippet, detaching);
      if (if_block1)
        if_block1.d();
      destroy_component(button);
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  let p0;
  let t0;
  let span;
  let t1;
  let t2_value = (
    /*api_calls*/
    ctx[5].length + ""
  );
  let t2;
  let t3;
  let t4;
  let p1;
  let t5;
  let t6;
  let t7;
  let t8;
  let recordingsnippet;
  let t9;
  let p2;
  let textContent = "Note: Some API calls only affect the UI, so when using the\n							clients, the desired result may be achieved with only a subset of\n							the recorded calls.";
  let t11;
  let p3;
  let textContent_1 = "API Documentation";
  let current2;
  recordingsnippet = new RecordingSnippet({
    props: {
      current_language: (
        /*current_language*/
        ctx[6]
      ),
      api_calls: (
        /*api_calls*/
        ctx[5]
      ),
      dependencies: (
        /*dependencies*/
        ctx[1]
      ),
      root: (
        /*root*/
        ctx[0]
      ),
      api_prefix: (
        /*app*/
        ctx[2].api_prefix
      ),
      short_root: (
        /*space_id*/
        ctx[3] || /*root*/
        ctx[0]
      ),
      username: (
        /*username*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      div = element("div");
      p0 = element("p");
      t0 = text$3(" Recorded API Calls ");
      span = element("span");
      t1 = text$3("[");
      t2 = text$3(t2_value);
      t3 = text$3("]");
      t4 = space();
      p1 = element("p");
      t5 = text$3("Here is the code snippet to replay the most recently recorded API\n							calls using the ");
      t6 = text$3(
        /*current_language*/
        ctx[6]
      );
      t7 = text$3("\n							client.");
      t8 = space();
      create_component(recordingsnippet.$$.fragment);
      t9 = space();
      p2 = element("p");
      p2.textContent = textContent;
      t11 = space();
      p3 = element("p");
      p3.textContent = textContent_1;
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      p0 = claim_element(div_nodes, "P", { id: true, style: true });
      var p0_nodes = children(p0);
      t0 = claim_text(p0_nodes, " Recorded API Calls ");
      span = claim_element(p0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, "[");
      t2 = claim_text(span_nodes, t2_value);
      t3 = claim_text(span_nodes, "]");
      span_nodes.forEach(detach);
      p0_nodes.forEach(detach);
      t4 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", {});
      var p1_nodes = children(p1);
      t5 = claim_text(p1_nodes, "Here is the code snippet to replay the most recently recorded API\n							calls using the ");
      t6 = claim_text(
        p1_nodes,
        /*current_language*/
        ctx[6]
      );
      t7 = claim_text(p1_nodes, "\n							client.");
      p1_nodes.forEach(detach);
      t8 = claim_space(div_nodes);
      claim_component(recordingsnippet.$$.fragment, div_nodes);
      t9 = claim_space(div_nodes);
      p2 = claim_element(div_nodes, "P", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(p2) !== "svelte-1nzar32")
        p2.textContent = textContent;
      div_nodes.forEach(detach);
      t11 = claim_space(nodes);
      p3 = claim_element(nodes, "P", { style: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p3) !== "svelte-oqhm8o")
        p3.textContent = textContent_1;
      this.h();
    },
    h() {
      attr(span, "class", "api-count svelte-v3jjme");
      attr(p0, "id", "num-recorded-api-calls");
      set_style(p0, "font-size", "var(--text-lg)");
      set_style(p0, "font-weight", "bold");
      set_style(p0, "margin", "10px 0px");
      set_style(p3, "font-size", "var(--text-lg)");
      set_style(p3, "font-weight", "bold");
      set_style(p3, "margin", "30px 0px 10px");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, p0);
      append_hydration(p0, t0);
      append_hydration(p0, span);
      append_hydration(span, t1);
      append_hydration(span, t2);
      append_hydration(span, t3);
      append_hydration(div, t4);
      append_hydration(div, p1);
      append_hydration(p1, t5);
      append_hydration(p1, t6);
      append_hydration(p1, t7);
      append_hydration(div, t8);
      mount_component(recordingsnippet, div, null);
      append_hydration(div, t9);
      append_hydration(div, p2);
      insert_hydration(target, t11, anchor);
      insert_hydration(target, p3, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if ((!current2 || dirty & /*api_calls*/
      32) && t2_value !== (t2_value = /*api_calls*/
      ctx2[5].length + ""))
        set_data(t2, t2_value);
      if (!current2 || dirty & /*current_language*/
      64)
        set_data(
          t6,
          /*current_language*/
          ctx2[6]
        );
      const recordingsnippet_changes = {};
      if (dirty & /*current_language*/
      64)
        recordingsnippet_changes.current_language = /*current_language*/
        ctx2[6];
      if (dirty & /*api_calls*/
      32)
        recordingsnippet_changes.api_calls = /*api_calls*/
        ctx2[5];
      if (dirty & /*dependencies*/
      2)
        recordingsnippet_changes.dependencies = /*dependencies*/
        ctx2[1];
      if (dirty & /*root*/
      1)
        recordingsnippet_changes.root = /*root*/
        ctx2[0];
      if (dirty & /*app*/
      4)
        recordingsnippet_changes.api_prefix = /*app*/
        ctx2[2].api_prefix;
      if (dirty & /*space_id, root*/
      9)
        recordingsnippet_changes.short_root = /*space_id*/
        ctx2[3] || /*root*/
        ctx2[0];
      if (dirty & /*username*/
      16)
        recordingsnippet_changes.username = /*username*/
        ctx2[4];
      recordingsnippet.$set(recordingsnippet_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(recordingsnippet.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(recordingsnippet.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t11);
        detach(p3);
      }
      destroy_component(recordingsnippet);
    }
  };
}
function create_else_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text$3("1. Confirm that you have cURL installed on your system.");
    },
    l(nodes) {
      t = claim_text(nodes, "1. Confirm that you have cURL installed on your system.");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_7$2(ctx) {
  let t0;
  let span;
  let t1;
  let t2;
  let a;
  let t3;
  let a_href_value;
  let t4;
  return {
    c() {
      t0 = text$3("1. Install the\n							");
      span = element("span");
      t1 = text$3(
        /*current_language*/
        ctx[6]
      );
      t2 = text$3("\n							client (");
      a = element("a");
      t3 = text$3("docs");
      t4 = text$3(") if you don't already have it installed.");
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "1. Install the\n							");
      span = claim_element(nodes, "SPAN", { style: true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*current_language*/
        ctx[6]
      );
      span_nodes.forEach(detach);
      t2 = claim_text(nodes, "\n							client (");
      a = claim_element(nodes, "A", { href: true, target: true, class: true });
      var a_nodes = children(a);
      t3 = claim_text(a_nodes, "docs");
      a_nodes.forEach(detach);
      t4 = claim_text(nodes, ") if you don't already have it installed.");
      this.h();
    },
    h() {
      set_style(span, "text-transform", "capitalize");
      attr(a, "href", a_href_value = /*current_language*/
      ctx[6] == "python" ? py_docs : js_docs);
      attr(a, "target", "_blank");
      attr(a, "class", "svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t1);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, a, anchor);
      append_hydration(a, t3);
      insert_hydration(target, t4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*current_language*/
      64)
        set_data(
          t1,
          /*current_language*/
          ctx2[6]
        );
      if (dirty & /*current_language*/
      64 && a_href_value !== (a_href_value = /*current_language*/
      ctx2[6] == "python" ? py_docs : js_docs)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
        detach(t2);
        detach(a);
        detach(t4);
      }
    }
  };
}
function create_if_block_6$2(ctx) {
  let t0;
  let a;
  let t1;
  let a_href_value;
  let t2;
  return {
    c() {
      t0 = text$3("If this is a private Space, you may need to pass your\n							Hugging Face token as well (");
      a = element("a");
      t1 = text$3("read more");
      t2 = text$3(").");
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, "If this is a private Space, you may need to pass your\n							Hugging Face token as well (");
      a = claim_element(nodes, "A", { href: true, class: true, target: true });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, "read more");
      a_nodes.forEach(detach);
      t2 = claim_text(nodes, ").");
      this.h();
    },
    h() {
      attr(a, "href", a_href_value = /*current_language*/
      ctx[6] == "python" ? py_docs + spaces_docs_suffix : (
        /*current_language*/
        ctx[6] == "javascript" ? js_docs + spaces_docs_suffix : bash_docs
      ));
      attr(a, "class", "underline svelte-v3jjme");
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, a, anchor);
      append_hydration(a, t1);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*current_language*/
      64 && a_href_value !== (a_href_value = /*current_language*/
      ctx2[6] == "python" ? py_docs + spaces_docs_suffix : (
        /*current_language*/
        ctx2[6] == "javascript" ? js_docs + spaces_docs_suffix : bash_docs
      ))) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(a);
        detach(t2);
      }
    }
  };
}
function create_default_slot$6(ctx) {
  let div;
  let t0;
  let p;
  let textContent = "API Recorder";
  return {
    c() {
      div = element("div");
      t0 = space();
      p = element("p");
      p.textContent = textContent;
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach);
      t0 = claim_space(nodes);
      p = claim_element(nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p) !== "svelte-1ycmyh9")
        p.textContent = textContent;
      this.h();
    },
    h() {
      attr(div, "class", "loading-dot svelte-v3jjme");
      attr(p, "class", "self-baseline svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p);
      }
    }
  };
}
function create_if_block_4$2(ctx) {
  let br0;
  let t0;
  let br1;
  let t1;
  let strong;
  let textContent = "2 requests";
  let t3;
  let code0;
  let textContent_1 = "POST";
  let t5;
  let code1;
  let textContent_2 = "GET";
  let t7;
  let code2;
  let textContent_3 = "POST";
  let t9;
  let code3;
  let textContent_4 = "EVENT_ID";
  let t11;
  let code4;
  let textContent_5 = "GET";
  let t13;
  let code5;
  let textContent_6 = "awk";
  let t15;
  let code6;
  let textContent_7 = "read";
  let t17;
  let t18;
  let a;
  let t19;
  let t20;
  let if_block = (
    /*username*/
    ctx[4] !== null && create_if_block_5$2()
  );
  return {
    c() {
      br0 = element("br");
      t0 = text$3("");
      br1 = element("br");
      t1 = text$3("Making a\n							prediction and getting a result requires\n							");
      strong = element("strong");
      strong.textContent = textContent;
      t3 = text$3(": a\n							");
      code0 = element("code");
      code0.textContent = textContent_1;
      t5 = text$3("\n							and a ");
      code1 = element("code");
      code1.textContent = textContent_2;
      t7 = text$3(" request. The ");
      code2 = element("code");
      code2.textContent = textContent_3;
      t9 = text$3(" request\n							returns an ");
      code3 = element("code");
      code3.textContent = textContent_4;
      t11 = text$3(", which is used in the second\n							");
      code4 = element("code");
      code4.textContent = textContent_5;
      t13 = text$3(" request to fetch the results. In these snippets,\n							we've used ");
      code5 = element("code");
      code5.textContent = textContent_6;
      t15 = text$3(" and ");
      code6 = element("code");
      code6.textContent = textContent_7;
      t17 = text$3(" to parse the\n							results, combining these two requests into one command for ease of\n							use. ");
      if (if_block)
        if_block.c();
      t18 = text$3(" See\n							");
      a = element("a");
      t19 = text$3("curl docs");
      t20 = text$3(".");
      this.h();
    },
    l(nodes) {
      br0 = claim_element(nodes, "BR", {});
      t0 = claim_text(nodes, "");
      br1 = claim_element(nodes, "BR", {});
      t1 = claim_text(nodes, "Making a\n							prediction and getting a result requires\n							");
      strong = claim_element(nodes, "STRONG", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(strong) !== "svelte-3tg330")
        strong.textContent = textContent;
      t3 = claim_text(nodes, ": a\n							");
      code0 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code0) !== "svelte-12krxoq")
        code0.textContent = textContent_1;
      t5 = claim_text(nodes, "\n							and a ");
      code1 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code1) !== "svelte-1r51gq6")
        code1.textContent = textContent_2;
      t7 = claim_text(nodes, " request. The ");
      code2 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code2) !== "svelte-12krxoq")
        code2.textContent = textContent_3;
      t9 = claim_text(nodes, " request\n							returns an ");
      code3 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code3) !== "svelte-wz35l4")
        code3.textContent = textContent_4;
      t11 = claim_text(nodes, ", which is used in the second\n							");
      code4 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code4) !== "svelte-1r51gq6")
        code4.textContent = textContent_5;
      t13 = claim_text(nodes, " request to fetch the results. In these snippets,\n							we've used ");
      code5 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code5) !== "svelte-qg98el")
        code5.textContent = textContent_6;
      t15 = claim_text(nodes, " and ");
      code6 = claim_element(nodes, "CODE", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(code6) !== "svelte-wk48ls")
        code6.textContent = textContent_7;
      t17 = claim_text(nodes, " to parse the\n							results, combining these two requests into one command for ease of\n							use. ");
      if (if_block)
        if_block.l(nodes);
      t18 = claim_text(nodes, " See\n							");
      a = claim_element(nodes, "A", { href: true, target: true, class: true });
      var a_nodes = children(a);
      t19 = claim_text(a_nodes, "curl docs");
      a_nodes.forEach(detach);
      t20 = claim_text(nodes, ".");
      this.h();
    },
    h() {
      attr(code0, "class", "svelte-v3jjme");
      attr(code1, "class", "svelte-v3jjme");
      attr(code2, "class", "svelte-v3jjme");
      attr(code3, "class", "svelte-v3jjme");
      attr(code4, "class", "svelte-v3jjme");
      attr(code5, "class", "svelte-v3jjme");
      attr(code6, "class", "svelte-v3jjme");
      attr(a, "href", bash_docs);
      attr(a, "target", "_blank");
      attr(a, "class", "svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, br0, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, br1, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, strong, anchor);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, code0, anchor);
      insert_hydration(target, t5, anchor);
      insert_hydration(target, code1, anchor);
      insert_hydration(target, t7, anchor);
      insert_hydration(target, code2, anchor);
      insert_hydration(target, t9, anchor);
      insert_hydration(target, code3, anchor);
      insert_hydration(target, t11, anchor);
      insert_hydration(target, code4, anchor);
      insert_hydration(target, t13, anchor);
      insert_hydration(target, code5, anchor);
      insert_hydration(target, t15, anchor);
      insert_hydration(target, code6, anchor);
      insert_hydration(target, t17, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t18, anchor);
      insert_hydration(target, a, anchor);
      append_hydration(a, t19);
      insert_hydration(target, t20, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*username*/
        ctx2[4] !== null
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_5$2();
          if_block.c();
          if_block.m(t18.parentNode, t18);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(br0);
        detach(t0);
        detach(br1);
        detach(t1);
        detach(strong);
        detach(t3);
        detach(code0);
        detach(t5);
        detach(code1);
        detach(t7);
        detach(code2);
        detach(t9);
        detach(code3);
        detach(t11);
        detach(code4);
        detach(t13);
        detach(code5);
        detach(t15);
        detach(code6);
        detach(t17);
        detach(t18);
        detach(a);
        detach(t20);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_5$2(ctx) {
  let t;
  return {
    c() {
      t = text$3("Note: connecting to an authenticated app requires an additional\n								request.");
    },
    l(nodes) {
      t = claim_text(nodes, "Note: connecting to an authenticated app requires an additional\n								request.");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let div;
  let codesnippet;
  let t0;
  let parameterssnippet;
  let t1;
  let responsesnippet;
  let t2;
  let current2;
  codesnippet = new CodeSnippet({
    props: {
      named: true,
      endpoint_parameters: (
        /*info*/
        ctx[7].named_endpoints["/" + /*dependency*/
        ctx[19].api_name].parameters
      ),
      dependency: (
        /*dependency*/
        ctx[19]
      ),
      dependency_index: (
        /*dependency_index*/
        ctx[21]
      ),
      current_language: (
        /*current_language*/
        ctx[6]
      ),
      root: (
        /*root*/
        ctx[0]
      ),
      space_id: (
        /*space_id*/
        ctx[3]
      ),
      username: (
        /*username*/
        ctx[4]
      ),
      api_prefix: (
        /*app*/
        ctx[2].api_prefix
      )
    }
  });
  parameterssnippet = new ParametersSnippet({
    props: {
      endpoint_returns: (
        /*info*/
        ctx[7].named_endpoints["/" + /*dependency*/
        ctx[19].api_name].parameters
      ),
      js_returns: (
        /*js_info*/
        ctx[8].named_endpoints["/" + /*dependency*/
        ctx[19].api_name].parameters
      ),
      is_running,
      current_language: (
        /*current_language*/
        ctx[6]
      )
    }
  });
  responsesnippet = new ResponseSnippet({
    props: {
      endpoint_returns: (
        /*info*/
        ctx[7].named_endpoints["/" + /*dependency*/
        ctx[19].api_name].returns
      ),
      js_returns: (
        /*js_info*/
        ctx[8].named_endpoints["/" + /*dependency*/
        ctx[19].api_name].returns
      ),
      is_running,
      current_language: (
        /*current_language*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(codesnippet.$$.fragment);
      t0 = space();
      create_component(parameterssnippet.$$.fragment);
      t1 = space();
      create_component(responsesnippet.$$.fragment);
      t2 = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(codesnippet.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(parameterssnippet.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      claim_component(responsesnippet.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "endpoint-container svelte-v3jjme");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(codesnippet, div, null);
      append_hydration(div, t0);
      mount_component(parameterssnippet, div, null);
      append_hydration(div, t1);
      mount_component(responsesnippet, div, null);
      append_hydration(div, t2);
      current2 = true;
    },
    p(ctx2, dirty) {
      const codesnippet_changes = {};
      if (dirty & /*info, dependencies*/
      130)
        codesnippet_changes.endpoint_parameters = /*info*/
        ctx2[7].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name].parameters;
      if (dirty & /*dependencies*/
      2)
        codesnippet_changes.dependency = /*dependency*/
        ctx2[19];
      if (dirty & /*current_language*/
      64)
        codesnippet_changes.current_language = /*current_language*/
        ctx2[6];
      if (dirty & /*root*/
      1)
        codesnippet_changes.root = /*root*/
        ctx2[0];
      if (dirty & /*space_id*/
      8)
        codesnippet_changes.space_id = /*space_id*/
        ctx2[3];
      if (dirty & /*username*/
      16)
        codesnippet_changes.username = /*username*/
        ctx2[4];
      if (dirty & /*app*/
      4)
        codesnippet_changes.api_prefix = /*app*/
        ctx2[2].api_prefix;
      codesnippet.$set(codesnippet_changes);
      const parameterssnippet_changes = {};
      if (dirty & /*info, dependencies*/
      130)
        parameterssnippet_changes.endpoint_returns = /*info*/
        ctx2[7].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name].parameters;
      if (dirty & /*js_info, dependencies*/
      258)
        parameterssnippet_changes.js_returns = /*js_info*/
        ctx2[8].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name].parameters;
      if (dirty & /*current_language*/
      64)
        parameterssnippet_changes.current_language = /*current_language*/
        ctx2[6];
      parameterssnippet.$set(parameterssnippet_changes);
      const responsesnippet_changes = {};
      if (dirty & /*info, dependencies*/
      130)
        responsesnippet_changes.endpoint_returns = /*info*/
        ctx2[7].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name].returns;
      if (dirty & /*js_info, dependencies*/
      258)
        responsesnippet_changes.js_returns = /*js_info*/
        ctx2[8].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name].returns;
      if (dirty & /*current_language*/
      64)
        responsesnippet_changes.current_language = /*current_language*/
        ctx2[6];
      responsesnippet.$set(responsesnippet_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(codesnippet.$$.fragment, local);
      transition_in(parameterssnippet.$$.fragment, local);
      transition_in(responsesnippet.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(codesnippet.$$.fragment, local);
      transition_out(parameterssnippet.$$.fragment, local);
      transition_out(responsesnippet.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(codesnippet);
      destroy_component(parameterssnippet);
      destroy_component(responsesnippet);
    }
  };
}
function create_each_block$1(ctx) {
  let if_block_anchor;
  let current2;
  let if_block = (
    /*dependency*/
    ctx[19].show_api && /*info*/
    ctx[7].named_endpoints["/" + /*dependency*/
    ctx[19].api_name] && create_if_block_2$4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*dependency*/
        ctx2[19].show_api && /*info*/
        ctx2[7].named_endpoints["/" + /*dependency*/
        ctx2[19].api_name]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*dependencies, info*/
          130) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$a(ctx) {
  let if_block_anchor;
  let current2;
  let if_block = (
    /*info*/
    ctx[7] && create_if_block$8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*info*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*info*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
const js_docs = "https://www.gradio.app/guides/getting-started-with-the-js-client";
const py_docs = "https://www.gradio.app/guides/getting-started-with-the-python-client";
const bash_docs = "https://www.gradio.app/guides/querying-gradio-apps-with-curl";
const spaces_docs_suffix = "#connecting-to-a-hugging-face-space";
let is_running = false;
function instance$9($$self, $$props, $$invalidate) {
  let { dependencies } = $$props;
  let { root } = $$props;
  let { app } = $$props;
  let { space_id } = $$props;
  let { root_node } = $$props;
  let { username } = $$props;
  let api_count = dependencies.filter((dependency) => dependency.show_api).length;
  if (root === "") {
    root = location.protocol + "//" + location.host + location.pathname;
  }
  if (!root.endsWith("/")) {
    root += "/";
  }
  let { api_calls = [] } = $$props;
  let current_language = "python";
  const langs2 = [["python", python], ["javascript", javascript], ["bash", bash]];
  async function get_info() {
    let response = await fetch(root.replace(/\/$/, "") + app.api_prefix + "/info");
    let data = await response.json();
    return data;
  }
  async function get_js_info() {
    let js_api_info = await app.view_api();
    return js_api_info;
  }
  let info;
  let js_info;
  get_info().then((data) => {
    $$invalidate(7, info = data);
  });
  get_js_info().then((js_api_info) => {
    $$invalidate(8, js_info = js_api_info);
  });
  const dispatch = createEventDispatcher();
  onMount(() => {
    var _a2;
    document.body.style.overflow = "hidden";
    if ("parentIFrame" in window) {
      (_a2 = window.parentIFrame) == null ? void 0 : _a2.scrollTo(0, 0);
    }
    return () => {
      document.body.style.overflow = "auto";
    };
  });
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = (language) => $$invalidate(6, current_language = language);
  const click_handler_1 = () => dispatch("close", { api_recorder_visible: true });
  function close_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dependencies" in $$props2)
      $$invalidate(1, dependencies = $$props2.dependencies);
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("app" in $$props2)
      $$invalidate(2, app = $$props2.app);
    if ("space_id" in $$props2)
      $$invalidate(3, space_id = $$props2.space_id);
    if ("root_node" in $$props2)
      $$invalidate(12, root_node = $$props2.root_node);
    if ("username" in $$props2)
      $$invalidate(4, username = $$props2.username);
    if ("api_calls" in $$props2)
      $$invalidate(5, api_calls = $$props2.api_calls);
  };
  return [
    root,
    dependencies,
    app,
    space_id,
    username,
    api_calls,
    current_language,
    info,
    js_info,
    api_count,
    langs2,
    dispatch,
    root_node,
    close_handler,
    click_handler,
    click_handler_1,
    close_handler_1
  ];
}
class ApiDocs extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$9, create_fragment$a, safe_not_equal, {
      dependencies: 1,
      root: 0,
      app: 2,
      space_id: 3,
      root_node: 12,
      username: 4,
      api_calls: 5
    });
  }
}
function create_if_block$7(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*dependencies*/
    ctx[1][
      /*api_calls*/
      ctx[0][
        /*api_calls*/
        ctx[0].length - 1
      ].fn_index
    ].api_name + ""
  );
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text$3("/");
      t1 = text$3(t1_value);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "/");
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "api-name svelte-sy28j6");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t0);
      append_hydration(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*dependencies, api_calls*/
      3 && t1_value !== (t1_value = /*dependencies*/
      ctx2[1][
        /*api_calls*/
        ctx2[0][
          /*api_calls*/
          ctx2[0].length - 1
        ].fn_index
      ].api_name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$5(ctx) {
  let div;
  let t0;
  let p0;
  let textContent = "Recording API Calls:";
  let t2;
  let p1;
  let span;
  let t3;
  let t4_value = (
    /*api_calls*/
    ctx[0].length + ""
  );
  let t4;
  let t5;
  let t6;
  let if_block = (
    /*api_calls*/
    ctx[0].length > 0 && create_if_block$7(ctx)
  );
  return {
    c() {
      div = element("div");
      t0 = space();
      p0 = element("p");
      p0.textContent = textContent;
      t2 = space();
      p1 = element("p");
      span = element("span");
      t3 = text$3("[");
      t4 = text$3(t4_value);
      t5 = text$3("]");
      t6 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach);
      t0 = claim_space(nodes);
      p0 = claim_element(nodes, "P", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(p0) !== "svelte-1fgk0o3")
        p0.textContent = textContent;
      t2 = claim_space(nodes);
      p1 = claim_element(nodes, "P", { class: true });
      var p1_nodes = children(p1);
      span = claim_element(p1_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t3 = claim_text(span_nodes, "[");
      t4 = claim_text(span_nodes, t4_value);
      t5 = claim_text(span_nodes, "]");
      span_nodes.forEach(detach);
      t6 = claim_space(p1_nodes);
      if (if_block)
        if_block.l(p1_nodes);
      p1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "loading-dot self-baseline svelte-sy28j6");
      attr(p0, "class", "self-baseline svelte-sy28j6");
      attr(span, "class", "api-count svelte-sy28j6");
      attr(p1, "class", "self-baseline api-section svelte-sy28j6");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, p0, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, p1, anchor);
      append_hydration(p1, span);
      append_hydration(span, t3);
      append_hydration(span, t4);
      append_hydration(span, t5);
      append_hydration(p1, t6);
      if (if_block)
        if_block.m(p1, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*api_calls*/
      1 && t4_value !== (t4_value = /*api_calls*/
      ctx2[0].length + ""))
        set_data(t4, t4_value);
      if (
        /*api_calls*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(p1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p0);
        detach(t2);
        detach(p1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment$9(ctx) {
  let div;
  let button;
  let current2;
  button = new Button({
    props: {
      size: "sm",
      variant: "secondary",
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      claim_component(button.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "id", "api-recorder");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(button, div, null);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, dependencies, api_calls*/
      7) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(button.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { api_calls = [] } = $$props;
  let { dependencies } = $$props;
  $$self.$$set = ($$props2) => {
    if ("api_calls" in $$props2)
      $$invalidate(0, api_calls = $$props2.api_calls);
    if ("dependencies" in $$props2)
      $$invalidate(1, dependencies = $$props2.dependencies);
  };
  return [api_calls, dependencies];
}
class ApiRecorder extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$8, create_fragment$9, safe_not_equal, { api_calls: 0, dependencies: 1 });
  }
}
const formatter = get($format);
function create_default_slot$4(ctx) {
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$8(ctx) {
  let switch_instance;
  let updating_value;
  let switch_instance_anchor;
  let current2;
  const switch_instance_spread_levels = [
    { elem_id: (
      /*elem_id*/
      ctx[5]
    ) },
    { elem_classes: (
      /*elem_classes*/
      ctx[6]
    ) },
    { target: (
      /*target*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[8],
    { theme_mode: (
      /*theme_mode*/
      ctx[4]
    ) },
    { root: (
      /*root*/
      ctx[2]
    ) }
  ];
  function switch_instance_value_binding(value) {
    ctx[13](value);
  }
  var switch_value = (
    /*_component*/
    ctx[7]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*elem_id, elem_classes, target, $$restProps, theme_mode, root*/
    380) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*elem_id*/
        32 && { elem_id: (
          /*elem_id*/
          ctx2[5]
        ) },
        dirty & /*elem_classes*/
        64 && { elem_classes: (
          /*elem_classes*/
          ctx2[6]
        ) },
        dirty & /*target*/
        8 && { target: (
          /*target*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx2[8]
        ),
        dirty & /*theme_mode*/
        16 && { theme_mode: (
          /*theme_mode*/
          ctx2[4]
        ) },
        dirty & /*root*/
        4 && { root: (
          /*root*/
          ctx2[2]
        ) }
      ]));
    }
    if (
      /*value*/
      ctx2[1] !== void 0
    ) {
      switch_instance_props.value = /*value*/
      ctx2[1];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    ctx[12](switch_instance);
    binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
    switch_instance.$on(
      "prop_change",
      /*prop_change_handler*/
      ctx[14]
    );
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = /*_component*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          ctx2[12](switch_instance);
          binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
          switch_instance.$on(
            "prop_change",
            /*prop_change_handler*/
            ctx2[14]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*elem_id, elem_classes, target, $$restProps, theme_mode, root*/
        380 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*elem_id*/
          32 && { elem_id: (
            /*elem_id*/
            ctx2[5]
          ) },
          dirty & /*elem_classes*/
          64 && { elem_classes: (
            /*elem_classes*/
            ctx2[6]
          ) },
          dirty & /*target*/
          8 && { target: (
            /*target*/
            ctx2[3]
          ) },
          dirty & /*$$restProps*/
          256 && get_spread_object(
            /*$$restProps*/
            ctx2[8]
          ),
          dirty & /*theme_mode*/
          16 && { theme_mode: (
            /*theme_mode*/
            ctx2[4]
          ) },
          dirty & /*root*/
          4 && { root: (
            /*root*/
            ctx2[2]
          ) }
        ]) : {};
        if (dirty & /*$$scope*/
        32768) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        if (!updating_value && dirty & /*value*/
        2) {
          updating_value = true;
          switch_instance_changes.value = /*value*/
          ctx2[1];
          add_flush_callback(() => updating_value = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current2)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      ctx[12](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "root",
    "component",
    "target",
    "theme_mode",
    "instance",
    "value",
    "elem_id",
    "elem_classes",
    "_id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { root } = $$props;
  let { component } = $$props;
  let { target } = $$props;
  let { theme_mode } = $$props;
  let { instance: instance2 } = $$props;
  let { value } = $$props;
  let { elem_id } = $$props;
  let { elem_classes } = $$props;
  let { _id: _id2 } = $$props;
  const s = (id2, p, v) => new CustomEvent("prop_change", { detail: { id: id2, prop: p, value: v } });
  function wrap(component2) {
    const ProxiedMyClass = new Proxy(
      component2,
      {
        construct(_target, args) {
          const instance22 = new _target(...args);
          const props = Object.keys(instance22.$$.props);
          function report(props2) {
            return function(propargs) {
              if (!target)
                return;
              const ev = s(_id2, props2, propargs);
              target.dispatchEvent(ev);
            };
          }
          props.forEach((v) => {
            binding_callbacks.push(() => bind(instance22, v, report(v)));
          });
          return instance22;
        }
      }
    );
    return ProxiedMyClass;
  }
  const _component = wrap(component);
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(0, instance2);
    });
  }
  function switch_instance_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function prop_change_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("root" in $$new_props)
      $$invalidate(2, root = $$new_props.root);
    if ("component" in $$new_props)
      $$invalidate(9, component = $$new_props.component);
    if ("target" in $$new_props)
      $$invalidate(3, target = $$new_props.target);
    if ("theme_mode" in $$new_props)
      $$invalidate(4, theme_mode = $$new_props.theme_mode);
    if ("instance" in $$new_props)
      $$invalidate(0, instance2 = $$new_props.instance);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("elem_id" in $$new_props)
      $$invalidate(5, elem_id = $$new_props.elem_id);
    if ("elem_classes" in $$new_props)
      $$invalidate(6, elem_classes = $$new_props.elem_classes);
    if ("_id" in $$new_props)
      $$invalidate(10, _id2 = $$new_props._id);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  return [
    instance2,
    value,
    root,
    target,
    theme_mode,
    elem_id,
    elem_classes,
    _component,
    $$restProps,
    component,
    _id2,
    slots,
    switch_instance_binding,
    switch_instance_value_binding,
    prop_change_handler,
    $$scope
  ];
}
class RenderComponent extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance_1, create_fragment$8, not_equal, {
      root: 2,
      component: 9,
      target: 3,
      theme_mode: 4,
      instance: 0,
      value: 1,
      elem_id: 5,
      elem_classes: 6,
      _id: 10
    });
  }
}
function get_each_context(ctx, list2, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list2[i];
  return child_ctx;
}
function create_if_block$6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current2;
  let each_value = ensure_array_like(
    /*node*/
    ctx[0].children
  );
  const get_key = (ctx2) => (
    /*_node*/
    ctx2[15].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*node, target, root, theme_mode, max_file_size, client*/
      63) {
        each_value = ensure_array_like(
          /*node*/
          ctx2[0].children
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current2 = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let render3;
  let current2;
  render3 = new Render({
    props: {
      node: (
        /*_node*/
        ctx[15]
      ),
      component: (
        /*_node*/
        ctx[15].component
      ),
      target: (
        /*target*/
        ctx[2]
      ),
      id: (
        /*_node*/
        ctx[15].id
      ),
      root: (
        /*root*/
        ctx[1]
      ),
      theme_mode: (
        /*theme_mode*/
        ctx[3]
      ),
      max_file_size: (
        /*max_file_size*/
        ctx[4]
      ),
      client: (
        /*client*/
        ctx[5]
      )
    }
  });
  render3.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  render3.$on(
    "mount",
    /*mount_handler*/
    ctx[10]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(render3.$$.fragment);
      this.h();
    },
    l(nodes) {
      first = empty();
      claim_component(render3.$$.fragment, nodes);
      this.h();
    },
    h() {
      this.first = first;
    },
    m(target, anchor) {
      insert_hydration(target, first, anchor);
      mount_component(render3, target, anchor);
      current2 = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const render_changes = {};
      if (dirty & /*node*/
      1)
        render_changes.node = /*_node*/
        ctx[15];
      if (dirty & /*node*/
      1)
        render_changes.component = /*_node*/
        ctx[15].component;
      if (dirty & /*target*/
      4)
        render_changes.target = /*target*/
        ctx[2];
      if (dirty & /*node*/
      1)
        render_changes.id = /*_node*/
        ctx[15].id;
      if (dirty & /*root*/
      2)
        render_changes.root = /*root*/
        ctx[1];
      if (dirty & /*theme_mode*/
      8)
        render_changes.theme_mode = /*theme_mode*/
        ctx[3];
      if (dirty & /*max_file_size*/
      16)
        render_changes.max_file_size = /*max_file_size*/
        ctx[4];
      if (dirty & /*client*/
      32)
        render_changes.client = /*client*/
        ctx[5];
      render3.$set(render_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(render3.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(render3.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(render3, detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let if_block_anchor;
  let current2;
  let if_block = (
    /*node*/
    ctx[0].children && /*node*/
    ctx[0].children.length && create_if_block$6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*node*/
        ctx2[0].children && /*node*/
        ctx2[0].children.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*node*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$7(ctx) {
  var _a2;
  let rendercomponent;
  let updating_instance;
  let updating_value;
  let current2;
  const rendercomponent_spread_levels = [
    { _id: (
      /*node*/
      (_a2 = ctx[0]) == null ? void 0 : _a2.id
    ) },
    { component: (
      /*node*/
      ctx[0].component
    ) },
    {
      elem_id: "elem_id" in /*node*/
      ctx[0].props && /*node*/
      ctx[0].props.elem_id || `component-${/*node*/
      ctx[0].id}`
    },
    {
      elem_classes: "elem_classes" in /*node*/
      ctx[0].props && /*node*/
      ctx[0].props.elem_classes || []
    },
    { target: (
      /*target*/
      ctx[2]
    ) },
    /*node*/
    ctx[0].props,
    { theme_mode: (
      /*theme_mode*/
      ctx[3]
    ) },
    { root: (
      /*root*/
      ctx[1]
    ) }
  ];
  function rendercomponent_instance_binding(value) {
    ctx[11](value);
  }
  function rendercomponent_value_binding(value) {
    ctx[12](value);
  }
  let rendercomponent_props = {
    $$slots: { default: [create_default_slot$3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < rendercomponent_spread_levels.length; i += 1) {
    rendercomponent_props = assign(rendercomponent_props, rendercomponent_spread_levels[i]);
  }
  if (
    /*node*/
    ctx[0].instance !== void 0
  ) {
    rendercomponent_props.instance = /*node*/
    ctx[0].instance;
  }
  if (
    /*node*/
    ctx[0].props.value !== void 0
  ) {
    rendercomponent_props.value = /*node*/
    ctx[0].props.value;
  }
  rendercomponent = new RenderComponent({ props: rendercomponent_props });
  binding_callbacks.push(() => bind(rendercomponent, "instance", rendercomponent_instance_binding));
  binding_callbacks.push(() => bind(rendercomponent, "value", rendercomponent_value_binding));
  return {
    c() {
      create_component(rendercomponent.$$.fragment);
    },
    l(nodes) {
      claim_component(rendercomponent.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(rendercomponent, target, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      var _a3;
      const rendercomponent_changes = dirty & /*node, target, theme_mode, root*/
      15 ? get_spread_update(rendercomponent_spread_levels, [
        dirty & /*node*/
        1 && { _id: (
          /*node*/
          (_a3 = ctx2[0]) == null ? void 0 : _a3.id
        ) },
        dirty & /*node*/
        1 && { component: (
          /*node*/
          ctx2[0].component
        ) },
        dirty & /*node*/
        1 && {
          elem_id: "elem_id" in /*node*/
          ctx2[0].props && /*node*/
          ctx2[0].props.elem_id || `component-${/*node*/
          ctx2[0].id}`
        },
        dirty & /*node*/
        1 && {
          elem_classes: "elem_classes" in /*node*/
          ctx2[0].props && /*node*/
          ctx2[0].props.elem_classes || []
        },
        dirty & /*target*/
        4 && { target: (
          /*target*/
          ctx2[2]
        ) },
        dirty & /*node*/
        1 && get_spread_object(
          /*node*/
          ctx2[0].props
        ),
        dirty & /*theme_mode*/
        8 && { theme_mode: (
          /*theme_mode*/
          ctx2[3]
        ) },
        dirty & /*root*/
        2 && { root: (
          /*root*/
          ctx2[1]
        ) }
      ]) : {};
      if (dirty & /*$$scope, node, target, root, theme_mode, max_file_size, client*/
      262207) {
        rendercomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_instance && dirty & /*node*/
      1) {
        updating_instance = true;
        rendercomponent_changes.instance = /*node*/
        ctx2[0].instance;
        add_flush_callback(() => updating_instance = false);
      }
      if (!updating_value && dirty & /*node*/
      1) {
        updating_value = true;
        rendercomponent_changes.value = /*node*/
        ctx2[0].props.value;
        add_flush_callback(() => updating_value = false);
      }
      rendercomponent.$set(rendercomponent_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(rendercomponent.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(rendercomponent.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(rendercomponent, detaching);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { root } = $$props;
  let { node } = $$props;
  let { parent = null } = $$props;
  let { target } = $$props;
  let { theme_mode } = $$props;
  let { version } = $$props;
  let { autoscroll } = $$props;
  let { max_file_size } = $$props;
  let { client } = $$props;
  const dispatch = createEventDispatcher();
  let filtered_children = [];
  onMount(() => {
    dispatch("mount", node.id);
    for (const child of filtered_children) {
      dispatch("mount", child.id);
    }
    return () => {
      dispatch("destroy", node.id);
      for (const child of filtered_children) {
        dispatch("mount", child.id);
      }
    };
  });
  setContext("BLOCK_KEY", parent);
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mount_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rendercomponent_instance_binding(value) {
    if ($$self.$$.not_equal(node.instance, value)) {
      node.instance = value;
      $$invalidate(0, node), $$invalidate(14, filtered_children), $$invalidate(2, target), $$invalidate(3, theme_mode), $$invalidate(7, version), $$invalidate(1, root), $$invalidate(8, autoscroll), $$invalidate(4, max_file_size), $$invalidate(5, client);
    }
  }
  function rendercomponent_value_binding(value) {
    if ($$self.$$.not_equal(node.props.value, value)) {
      node.props.value = value;
      $$invalidate(0, node), $$invalidate(14, filtered_children), $$invalidate(2, target), $$invalidate(3, theme_mode), $$invalidate(7, version), $$invalidate(1, root), $$invalidate(8, autoscroll), $$invalidate(4, max_file_size), $$invalidate(5, client);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(1, root = $$props2.root);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("parent" in $$props2)
      $$invalidate(6, parent = $$props2.parent);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("theme_mode" in $$props2)
      $$invalidate(3, theme_mode = $$props2.theme_mode);
    if ("version" in $$props2)
      $$invalidate(7, version = $$props2.version);
    if ("autoscroll" in $$props2)
      $$invalidate(8, autoscroll = $$props2.autoscroll);
    if ("max_file_size" in $$props2)
      $$invalidate(4, max_file_size = $$props2.max_file_size);
    if ("client" in $$props2)
      $$invalidate(5, client = $$props2.client);
  };
  $$self.$$.update = () => {
    var _a2;
    if ($$self.$$.dirty & /*node*/
    1) {
      {
        if (node) {
          $$invalidate(
            0,
            node.children = node.children && node.children.filter((v) => {
              const valid_node = node.type !== "statustracker";
              if (!valid_node) {
                filtered_children.push(v);
              }
              return valid_node;
            }),
            node
          );
        }
      }
    }
    if ($$self.$$.dirty & /*node*/
    1) {
      {
        if (node && node.type === "form") {
          if ((_a2 = node.children) == null ? void 0 : _a2.every((c) => !c.props.visible)) {
            $$invalidate(0, node.props.visible = false, node);
          } else {
            $$invalidate(0, node.props.visible = true, node);
          }
        }
      }
    }
    if ($$self.$$.dirty & /*node, target, theme_mode, version, root, autoscroll, max_file_size, client*/
    447) {
      $$invalidate(0, node.props.gradio = new Gradio(node.id, target, theme_mode, version, root, autoscroll, max_file_size, formatter, client, load_component), node);
    }
  };
  return [
    node,
    root,
    target,
    theme_mode,
    max_file_size,
    client,
    parent,
    version,
    autoscroll,
    destroy_handler,
    mount_handler,
    rendercomponent_instance_binding,
    rendercomponent_value_binding
  ];
}
class Render extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$7, create_fragment$7, safe_not_equal, {
      root: 1,
      node: 0,
      parent: 6,
      target: 2,
      theme_mode: 3,
      version: 7,
      autoscroll: 8,
      max_file_size: 4,
      client: 5
    });
  }
}
function create_if_block$5(ctx) {
  let render3;
  let current2;
  render3 = new Render({
    props: {
      node: (
        /*rootNode*/
        ctx[0]
      ),
      root: (
        /*root*/
        ctx[1]
      ),
      target: (
        /*target*/
        ctx[2]
      ),
      theme_mode: (
        /*theme_mode*/
        ctx[3]
      ),
      version: (
        /*version*/
        ctx[4]
      ),
      autoscroll: (
        /*autoscroll*/
        ctx[5]
      ),
      max_file_size: (
        /*max_file_size*/
        ctx[6]
      ),
      client: (
        /*client*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(render3.$$.fragment);
    },
    l(nodes) {
      claim_component(render3.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(render3, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const render_changes = {};
      if (dirty & /*rootNode*/
      1)
        render_changes.node = /*rootNode*/
        ctx2[0];
      if (dirty & /*root*/
      2)
        render_changes.root = /*root*/
        ctx2[1];
      if (dirty & /*target*/
      4)
        render_changes.target = /*target*/
        ctx2[2];
      if (dirty & /*theme_mode*/
      8)
        render_changes.theme_mode = /*theme_mode*/
        ctx2[3];
      if (dirty & /*version*/
      16)
        render_changes.version = /*version*/
        ctx2[4];
      if (dirty & /*autoscroll*/
      32)
        render_changes.autoscroll = /*autoscroll*/
        ctx2[5];
      if (dirty & /*max_file_size*/
      64)
        render_changes.max_file_size = /*max_file_size*/
        ctx2[6];
      if (dirty & /*client*/
      128)
        render_changes.client = /*client*/
        ctx2[7];
      render3.$set(render_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(render3.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(render3.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(render3, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let if_block_anchor;
  let current2;
  let if_block = (
    /*rootNode*/
    ctx[0] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*rootNode*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*rootNode*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { rootNode } = $$props;
  let { root } = $$props;
  let { target } = $$props;
  let { theme_mode } = $$props;
  let { version } = $$props;
  let { autoscroll } = $$props;
  let { max_file_size = null } = $$props;
  let { client } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    dispatch("mount");
  });
  $$self.$$set = ($$props2) => {
    if ("rootNode" in $$props2)
      $$invalidate(0, rootNode = $$props2.rootNode);
    if ("root" in $$props2)
      $$invalidate(1, root = $$props2.root);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("theme_mode" in $$props2)
      $$invalidate(3, theme_mode = $$props2.theme_mode);
    if ("version" in $$props2)
      $$invalidate(4, version = $$props2.version);
    if ("autoscroll" in $$props2)
      $$invalidate(5, autoscroll = $$props2.autoscroll);
    if ("max_file_size" in $$props2)
      $$invalidate(6, max_file_size = $$props2.max_file_size);
    if ("client" in $$props2)
      $$invalidate(7, client = $$props2.client);
  };
  return [rootNode, root, target, theme_mode, version, autoscroll, max_file_size, client];
}
class MountComponents extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$6, create_fragment$6, safe_not_equal, {
      rootNode: 0,
      root: 1,
      target: 2,
      theme_mode: 3,
      version: 4,
      autoscroll: 5,
      max_file_size: 6,
      client: 7
    });
  }
}
const logo = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='576'%20height='576'%20viewBox='0%200%20576%20576'%20fill='none'%3e%3cpath%20d='M287.5%20229L86%20344.5L287.5%20460L489%20344.5L287.5%20229Z'%20stroke='url(%23paint0_linear_102_7)'%20stroke-width='59'%20stroke-linejoin='round'/%3e%3cpath%20d='M287.5%20116L86%20231.5L287.5%20347L489%20231.5L287.5%20116Z'%20stroke='url(%23paint1_linear_102_7)'%20stroke-width='59'%20stroke-linejoin='round'/%3e%3cpath%20d='M86%20344L288%20229'%20stroke='url(%23paint2_linear_102_7)'%20stroke-width='59'%20stroke-linejoin='bevel'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_102_7'%20x1='60'%20y1='341'%20x2='429.5'%20y2='344'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23F9D100'/%3e%3cstop%20offset='1'%20stop-color='%23F97700'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_102_7'%20x1='513.5'%20y1='231'%20x2='143.5'%20y2='231'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23F9D100'/%3e%3cstop%20offset='1'%20stop-color='%23F97700'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint2_linear_102_7'%20x1='60'%20y1='344'%20x2='428.987'%20y2='341.811'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23F9D100'/%3e%3cstop%20offset='1'%20stop-color='%23F97700'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e";
const { document: document_1$1 } = globals;
function create_if_block_7$1(ctx) {
  document_1$1.title = /*title*/
  ctx[2];
  return { c: noop, l: noop, m: noop, d: noop };
}
function create_if_block_6$1(ctx) {
  let html_tag;
  let raw_value = `<style>${prefix_css(
    /*css*/
    ctx[15],
    /*version*/
    ctx[12]
  )}</style>`;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*css, version*/
      36864 && raw_value !== (raw_value = `<style>${prefix_css(
        /*css*/
        ctx2[15],
        /*version*/
        ctx2[12]
      )}</style>`))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_5$1(ctx) {
  let mountcomponents;
  let current2;
  mountcomponents = new MountComponents({
    props: {
      rootNode: (
        /*$_layout*/
        ctx[16]
      ),
      root: (
        /*root*/
        ctx[0]
      ),
      target: (
        /*target*/
        ctx[3]
      ),
      theme_mode: (
        /*theme_mode*/
        ctx[9]
      ),
      version: (
        /*version*/
        ctx[12]
      ),
      autoscroll: (
        /*autoscroll*/
        ctx[4]
      ),
      max_file_size: (
        /*max_file_size*/
        ctx[14]
      ),
      client: (
        /*app*/
        ctx[10]
      )
    }
  });
  mountcomponents.$on(
    "mount",
    /*handle_mount*/
    ctx[28]
  );
  return {
    c() {
      create_component(mountcomponents.$$.fragment);
    },
    l(nodes) {
      claim_component(mountcomponents.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(mountcomponents, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const mountcomponents_changes = {};
      if (dirty[0] & /*$_layout*/
      65536)
        mountcomponents_changes.rootNode = /*$_layout*/
        ctx2[16];
      if (dirty[0] & /*root*/
      1)
        mountcomponents_changes.root = /*root*/
        ctx2[0];
      if (dirty[0] & /*target*/
      8)
        mountcomponents_changes.target = /*target*/
        ctx2[3];
      if (dirty[0] & /*theme_mode*/
      512)
        mountcomponents_changes.theme_mode = /*theme_mode*/
        ctx2[9];
      if (dirty[0] & /*version*/
      4096)
        mountcomponents_changes.version = /*version*/
        ctx2[12];
      if (dirty[0] & /*autoscroll*/
      16)
        mountcomponents_changes.autoscroll = /*autoscroll*/
        ctx2[4];
      if (dirty[0] & /*max_file_size*/
      16384)
        mountcomponents_changes.max_file_size = /*max_file_size*/
        ctx2[14];
      if (dirty[0] & /*app*/
      1024)
        mountcomponents_changes.client = /*app*/
        ctx2[10];
      mountcomponents.$set(mountcomponents_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(mountcomponents.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(mountcomponents.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(mountcomponents, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let footer;
  let t0;
  let a;
  let t1_value = (
    /*$_*/
    ctx[21]("common.built_with_gradio") + ""
  );
  let t1;
  let t2;
  let img;
  let img_src_value;
  let img_alt_value;
  let if_block = (
    /*show_api*/
    ctx[5] && create_if_block_4$1(ctx)
  );
  return {
    c() {
      footer = element("footer");
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      t1 = text$3(t1_value);
      t2 = space();
      img = element("img");
      this.h();
    },
    l(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block)
        if_block.l(footer_nodes);
      t0 = claim_space(footer_nodes);
      a = claim_element(footer_nodes, "A", {
        href: true,
        class: true,
        target: true,
        rel: true
      });
      var a_nodes = children(a);
      t1 = claim_text(a_nodes, t1_value);
      t2 = claim_space(a_nodes);
      img = claim_element(a_nodes, "IMG", { src: true, alt: true, class: true });
      a_nodes.forEach(detach);
      footer_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = logo))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$_*/
      ctx[21]("common.logo"));
      attr(img, "class", "svelte-1rjryqp");
      attr(a, "href", "https://gradio.app");
      attr(a, "class", "built-with svelte-1rjryqp");
      attr(a, "target", "_blank");
      attr(a, "rel", "noreferrer");
      attr(footer, "class", "svelte-1rjryqp");
    },
    m(target, anchor) {
      insert_hydration(target, footer, anchor);
      if (if_block)
        if_block.m(footer, null);
      append_hydration(footer, t0);
      append_hydration(footer, a);
      append_hydration(a, t1);
      append_hydration(a, t2);
      append_hydration(a, img);
    },
    p(ctx2, dirty) {
      if (
        /*show_api*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1(ctx2);
          if_block.c();
          if_block.m(footer, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*$_*/
      2097152 && t1_value !== (t1_value = /*$_*/
      ctx2[21]("common.built_with_gradio") + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*$_*/
      2097152 && img_alt_value !== (img_alt_value = /*$_*/
      ctx2[21]("common.logo"))) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(footer);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_4$1(ctx) {
  let button;
  let t0_value = (
    /*$_*/
    ctx[21]("errors.use_via_api") + ""
  );
  let t0;
  let t1;
  let img;
  let img_src_value;
  let img_alt_value;
  let t2;
  let div;
  let textContent = "";
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text$3(t0_value);
      t1 = space();
      img = element("img");
      t2 = space();
      div = element("div");
      div.textContent = textContent;
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div) !== "svelte-i2zgvn")
        div.textContent = textContent;
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = api_logo))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$_*/
      ctx[21]("common.logo"));
      attr(img, "class", "svelte-1rjryqp");
      attr(button, "class", "show-api svelte-1rjryqp");
      attr(div, "class", "svelte-1rjryqp");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, t0);
      append_hydration(button, t1);
      append_hydration(button, img);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[40]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_*/
      2097152 && t0_value !== (t0_value = /*$_*/
      ctx2[21]("errors.use_via_api") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$_*/
      2097152 && img_alt_value !== (img_alt_value = /*$_*/
      ctx2[21]("common.logo"))) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t2);
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let apirecorder;
  let current2;
  let mounted;
  let dispose;
  apirecorder = new ApiRecorder({
    props: {
      api_calls: (
        /*api_calls*/
        ctx[19]
      ),
      dependencies: (
        /*dependencies*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(apirecorder.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      claim_component(apirecorder.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "id", "api-recorder-container");
      attr(div, "class", "svelte-1rjryqp");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(apirecorder, div, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler_1*/
          ctx[41]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const apirecorder_changes = {};
      if (dirty[0] & /*api_calls*/
      524288)
        apirecorder_changes.api_calls = /*api_calls*/
        ctx2[19];
      if (dirty[0] & /*dependencies*/
      2)
        apirecorder_changes.dependencies = /*dependencies*/
        ctx2[1];
      apirecorder.$set(apirecorder_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(apirecorder.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(apirecorder.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(apirecorder);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$3(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let apidocs;
  let current2;
  let mounted;
  let dispose;
  apidocs = new ApiDocs({
    props: {
      root_node: (
        /*$_layout*/
        ctx[16]
      ),
      dependencies: (
        /*dependencies*/
        ctx[1]
      ),
      root: (
        /*root*/
        ctx[0]
      ),
      app: (
        /*app*/
        ctx[10]
      ),
      space_id: (
        /*space_id*/
        ctx[11]
      ),
      api_calls: (
        /*api_calls*/
        ctx[19]
      ),
      username: (
        /*username*/
        ctx[13]
      )
    }
  });
  apidocs.$on(
    "close",
    /*close_handler*/
    ctx[43]
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      create_component(apidocs.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(apidocs.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "backdrop svelte-1rjryqp");
      attr(div1, "class", "api-docs-wrap svelte-1rjryqp");
      attr(div2, "class", "api-docs svelte-1rjryqp");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div2, t);
      append_hydration(div2, div1);
      mount_component(apidocs, div1, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*click_handler_2*/
          ctx[42]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const apidocs_changes = {};
      if (dirty[0] & /*$_layout*/
      65536)
        apidocs_changes.root_node = /*$_layout*/
        ctx2[16];
      if (dirty[0] & /*dependencies*/
      2)
        apidocs_changes.dependencies = /*dependencies*/
        ctx2[1];
      if (dirty[0] & /*root*/
      1)
        apidocs_changes.root = /*root*/
        ctx2[0];
      if (dirty[0] & /*app*/
      1024)
        apidocs_changes.app = /*app*/
        ctx2[10];
      if (dirty[0] & /*space_id*/
      2048)
        apidocs_changes.space_id = /*space_id*/
        ctx2[11];
      if (dirty[0] & /*api_calls*/
      524288)
        apidocs_changes.api_calls = /*api_calls*/
        ctx2[19];
      if (dirty[0] & /*username*/
      8192)
        apidocs_changes.username = /*username*/
        ctx2[13];
      apidocs.$set(apidocs_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(apidocs.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(apidocs.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(apidocs);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$4(ctx) {
  let toast;
  let current2;
  toast = new Toast({
    props: { messages: (
      /*messages*/
      ctx[20]
    ) }
  });
  toast.$on(
    "close",
    /*handle_error_close*/
    ctx[27]
  );
  return {
    c() {
      create_component(toast.$$.fragment);
    },
    l(nodes) {
      claim_component(toast.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toast, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const toast_changes = {};
      if (dirty[0] & /*messages*/
      1048576)
        toast_changes.messages = /*messages*/
        ctx2[20];
      toast.$set(toast_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(toast.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(toast.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(toast, detaching);
    }
  };
}
function create_fragment$5(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let t0;
  let div1;
  let div0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block6_anchor;
  let current2;
  let if_block0 = (
    /*control_page_title*/
    ctx[7] && create_if_block_7$1(ctx)
  );
  let if_block1 = (
    /*css*/
    ctx[15] && create_if_block_6$1(ctx)
  );
  let if_block2 = (
    /*$_layout*/
    ctx[16] && /*app*/
    ctx[10].config && create_if_block_5$1(ctx)
  );
  let if_block3 = (
    /*show_footer*/
    ctx[6] && create_if_block_3$1(ctx)
  );
  let if_block4 = (
    /*api_recorder_visible*/
    ctx[18] && create_if_block_2$3(ctx)
  );
  let if_block5 = (
    /*api_docs_visible*/
    ctx[17] && /*$_layout*/
    ctx[16] && create_if_block_1$3(ctx)
  );
  let if_block6 = (
    /*messages*/
    ctx[20] && create_if_block$4(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t1 = space();
      if (if_block3)
        if_block3.c();
      t2 = space();
      if (if_block4)
        if_block4.c();
      t3 = space();
      if (if_block5)
        if_block5.c();
      t4 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      this.h();
    },
    l(nodes) {
      const head_nodes = head_selector("svelte-eiigye", document_1$1.head);
      if (if_block0)
        if_block0.l(head_nodes);
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.l(head_nodes);
      if_block1_anchor = empty();
      head_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      t1 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t3 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      t4 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      if_block6_anchor = empty();
      this.h();
    },
    h() {
      attr(div0, "class", "contain svelte-1rjryqp");
      set_style(
        div0,
        "flex-grow",
        /*app_mode*/
        ctx[8] ? "1" : "auto"
      );
      attr(div1, "class", "wrap svelte-1rjryqp");
      set_style(
        div1,
        "min-height",
        /*app_mode*/
        ctx[8] ? "100%" : "auto"
      );
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(document_1$1.head, null);
      append_hydration(document_1$1.head, if_block0_anchor);
      if (if_block1)
        if_block1.m(document_1$1.head, null);
      append_hydration(document_1$1.head, if_block1_anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration(div1, t1);
      if (if_block3)
        if_block3.m(div1, null);
      insert_hydration(target, t2, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration(target, t3, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration(target, t4, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration(target, if_block6_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*control_page_title*/
        ctx2[7]
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_7$1(ctx2);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*css*/
        ctx2[15]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6$1(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$_layout*/
        ctx2[16] && /*app*/
        ctx2[10].config
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$_layout, app*/
          66560) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_5$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*app_mode*/
      256) {
        set_style(
          div0,
          "flex-grow",
          /*app_mode*/
          ctx2[8] ? "1" : "auto"
        );
      }
      if (
        /*show_footer*/
        ctx2[6]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_3$1(ctx2);
          if_block3.c();
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty[0] & /*app_mode*/
      256) {
        set_style(
          div1,
          "min-height",
          /*app_mode*/
          ctx2[8] ? "100%" : "auto"
        );
      }
      if (
        /*api_recorder_visible*/
        ctx2[18]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*api_recorder_visible*/
          262144) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$3(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t3.parentNode, t3);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*api_docs_visible*/
        ctx2[17] && /*$_layout*/
        ctx2[16]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*api_docs_visible, $_layout*/
          196608) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1$3(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t4.parentNode, t4);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*messages*/
        ctx2[20]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*messages*/
          1048576) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block$4(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block2);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      current2 = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block6_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      detach(if_block0_anchor);
      if (if_block1)
        if_block1.d(detaching);
      detach(if_block1_anchor);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
    }
  };
}
const MESSAGE_QUOTE_RE = /^'([^]+)'$/;
const SHOW_DUPLICATE_MESSAGE_ON_ETA = 15;
const SHOW_MOBILE_QUEUE_WARNING_ON_ETA = 10;
function isCustomEvent(event) {
  return "detail" in event;
}
function instance$5($$self, $$props, $$invalidate) {
  let $loading_status;
  let $targets;
  let $scheduled_updates;
  let $_;
  let $_layout;
  component_subscribe($$self, $format, ($$value) => $$invalidate(21, $_ = $$value));
  setupi18n();
  let { root } = $$props;
  let { components } = $$props;
  let { layout } = $$props;
  let { dependencies } = $$props;
  let { title = "Gradio" } = $$props;
  let { target } = $$props;
  let { autoscroll } = $$props;
  let { show_api = true } = $$props;
  let { show_footer = true } = $$props;
  let { control_page_title = false } = $$props;
  let { app_mode } = $$props;
  let { theme_mode } = $$props;
  let { app } = $$props;
  let { space_id } = $$props;
  let { version } = $$props;
  let { js } = $$props;
  let { fill_height = false } = $$props;
  let { ready } = $$props;
  let { username } = $$props;
  let { api_prefix = "" } = $$props;
  let { max_file_size = void 0 } = $$props;
  let { initial_layout = void 0 } = $$props;
  let { css = null } = $$props;
  let { layout: _layout, targets, update_value, get_data, modify_stream, get_stream_state, set_time_limit, loading_status, scheduled_updates, create_layout, rerender_layout } = create_components(initial_layout);
  component_subscribe($$self, _layout, (value) => $$invalidate(16, $_layout = value));
  component_subscribe($$self, targets, (value) => $$invalidate(50, $targets = value));
  component_subscribe($$self, loading_status, (value) => $$invalidate(39, $loading_status = value));
  component_subscribe($$self, scheduled_updates, (value) => $$invalidate(51, $scheduled_updates = value));
  async function run() {
    await create_layout({
      components,
      layout,
      dependencies,
      root: root + api_prefix,
      app,
      options: { fill_height }
    });
  }
  let { search_params } = $$props;
  let api_docs_visible = search_params.get("view") === "api" && show_api;
  let api_recorder_visible = search_params.get("view") === "api-recorder" && show_api;
  function set_api_docs_visible(visible) {
    $$invalidate(18, api_recorder_visible = false);
    $$invalidate(17, api_docs_visible = visible);
    let params = new URLSearchParams(window.location.search);
    if (visible) {
      params.set("view", "api");
    } else {
      params.delete("view");
    }
    history.replaceState(null, "", "?" + params.toString());
  }
  let api_calls = [];
  let { render_complete = false } = $$props;
  async function handle_update(data, fn_index) {
    const outputs = dependencies.find((dep) => dep.id == fn_index).outputs;
    const meta_updates = data == null ? void 0 : data.map((value, i) => {
      return {
        id: outputs[i],
        prop: "value_is_output",
        value: true
      };
    });
    update_value(meta_updates);
    await tick();
    const updates = [];
    data == null ? void 0 : data.forEach((value, i) => {
      if (typeof value === "object" && value !== null && value.__type__ === "update") {
        for (const [update_key, update_value2] of Object.entries(value)) {
          if (update_key === "__type__") {
            continue;
          } else {
            updates.push({
              id: outputs[i],
              prop: update_key,
              value: update_value2
            });
          }
        }
      } else {
        updates.push({ id: outputs[i], prop: "value", value });
      }
    });
    update_value(updates);
    await tick();
  }
  let submit_map = /* @__PURE__ */ new Map();
  let messages = [];
  function new_message(title2, message, fn_index, type, duration = 10, visible = true) {
    return {
      title: title2,
      message,
      fn_index,
      type,
      id: ++_error_id,
      duration,
      visible
    };
  }
  function add_new_message(title2, message, type) {
    $$invalidate(20, messages = [new_message(title2, message, -1, type), ...messages]);
  }
  let _error_id = -1;
  let user_left_page = false;
  const DUPLICATE_MESSAGE = $_("blocks.long_requests_queue");
  const MOBILE_QUEUE_WARNING = $_("blocks.connection_can_break");
  const MOBILE_RECONNECT_MESSAGE = $_("blocks.lost_connection");
  const WAITING_FOR_INPUTS_MESSAGE = $_("blocks.waiting_for_inputs");
  let is_mobile_device = false;
  let showed_duplicate_message = false;
  let showed_mobile_warning = false;
  let inputs_waiting = [];
  function wait_then_trigger_api_call(dep_index, trigger_id = null, event_data = null) {
    let _unsub = () => {
    };
    function unsub() {
      _unsub();
    }
    if ($scheduled_updates) {
      _unsub = scheduled_updates.subscribe((updating) => {
        if (!updating) {
          tick().then(() => {
            trigger_api_call(dep_index, trigger_id, event_data);
            unsub();
          });
        }
      });
    } else {
      trigger_api_call(dep_index, trigger_id, event_data);
    }
  }
  async function get_component_value_or_event_data(component_id, trigger_id, event_data) {
    if (component_id === trigger_id && event_data && event_data.is_value_data === true) {
      return event_data.value;
    }
    return get_data(component_id);
  }
  async function trigger_api_call(dep_index, trigger_id = null, event_data = null) {
    let dep = dependencies.find((dep2) => dep2.id === dep_index);
    if (inputs_waiting.length > 0) {
      for (const input of inputs_waiting) {
        if (dep.inputs.includes(input)) {
          add_new_message("Warning", WAITING_FOR_INPUTS_MESSAGE, "warning");
          return;
        }
      }
    }
    const current_status = loading_status.get_status_for_fn(dep_index);
    $$invalidate(20, messages = messages.filter(({ fn_index }) => fn_index !== dep_index));
    if (current_status === "pending" || current_status === "generating") {
      dep.pending_request = true;
    }
    let payload = {
      fn_index: dep_index,
      data: await Promise.all(dep.inputs.map((id2) => get_component_value_or_event_data(id2, trigger_id, event_data))),
      event_data: dep.collects_event_data ? event_data : null,
      trigger_id
    };
    if (dep.frontend_fn) {
      dep.frontend_fn(payload.data.concat(await Promise.all(dep.outputs.map((id2) => get_data(id2))))).then((v) => {
        if (dep.backend_fn) {
          payload.data = v;
          trigger_prediction(dep, payload);
        } else {
          handle_update(v, dep_index);
        }
      });
    } else if (dep.types.cancel && dep.cancels) {
      await Promise.all(dep.cancels.map(async (fn_index) => {
        const submission = submit_map.get(fn_index);
        submission == null ? void 0 : submission.cancel();
        return submission;
      }));
    } else {
      if (dep.backend_fn) {
        trigger_prediction(dep, payload);
      }
    }
    function trigger_prediction(dep2, payload2) {
      if (dep2.trigger_mode === "once") {
        if (!dep2.pending_request)
          make_prediction(payload2, dep2.connection == "stream");
      } else if (dep2.trigger_mode === "multiple") {
        make_prediction(payload2, dep2.connection == "stream");
      } else if (dep2.trigger_mode === "always_last") {
        if (!dep2.pending_request) {
          make_prediction(payload2, dep2.connection == "stream");
        } else {
          dep2.final_event = payload2;
        }
      }
    }
    async function make_prediction(payload2, streaming = false) {
      if (api_recorder_visible) {
        $$invalidate(19, api_calls = [...api_calls, JSON.parse(JSON.stringify(payload2))]);
      }
      let submission;
      app.set_current_payload(payload2);
      if (streaming) {
        if (!submit_map.has(dep_index)) {
          dep.inputs.forEach((id2) => modify_stream(id2, "waiting"));
        } else if (submit_map.has(dep_index) && dep.inputs.some((id2) => get_stream_state(id2) === "waiting")) {
          return;
        } else if (submit_map.has(dep_index) && dep.inputs.some((id2) => get_stream_state(id2) === "open")) {
          await app.send_ws_message(
            // @ts-ignore
            `${app.config.root + app.config.api_prefix}/stream/${submit_map.get(dep_index).event_id()}`,
            {
              ...payload2,
              session_hash: app.session_hash
            }
          );
          return;
        }
      }
      try {
        submission = app.submit(payload2.fn_index, payload2.data, payload2.event_data, payload2.trigger_id);
      } catch (e) {
        const fn_index = 0;
        $$invalidate(20, messages = [new_message("Error", String(e), fn_index, "error"), ...messages]);
        loading_status.update({
          status: "error",
          fn_index,
          eta: 0,
          queue: false,
          queue_position: null
        });
        set_status($loading_status);
        return;
      }
      submit_map.set(dep_index, submission);
      for await (const message of submission) {
        if (message.type === "data") {
          handle_data(message);
        } else if (message.type === "render") {
          handle_render(message);
        } else if (message.type === "status") {
          handle_status_update(message);
        } else if (message.type === "log") {
          handle_log(message);
        }
      }
      function handle_data(message) {
        const { data, fn_index } = message;
        if (dep.pending_request && dep.final_event) {
          dep.pending_request = false;
          make_prediction(dep.final_event, dep.connection == "stream");
        }
        dep.pending_request = false;
        handle_update(data, fn_index);
        set_status($loading_status);
      }
      function handle_render(message) {
        const { data } = message;
        let _components = data.components;
        let render_layout = data.layout;
        let _dependencies = data.dependencies;
        let render_id = data.render_id;
        let deps_to_remove = [];
        dependencies.forEach((dep2, i) => {
          if (dep2.rendered_in === render_id) {
            deps_to_remove.push(i);
          }
        });
        deps_to_remove.reverse().forEach((i) => {
          dependencies.splice(i, 1);
        });
        _dependencies.forEach((dep2) => {
          dependencies.push(dep2);
        });
        rerender_layout({
          components: _components,
          layout: render_layout,
          root,
          dependencies,
          render_id
        });
      }
      function handle_log(msg) {
        const { title: title2, log, fn_index, level, duration, visible } = msg;
        $$invalidate(20, messages = [
          new_message(title2, log, fn_index, level, duration, visible),
          ...messages
        ]);
      }
      function open_stream_events(status, id2, dep2) {
        if (status.original_msg === "process_starts" && dep2.connection === "stream") {
          modify_stream(id2, "open");
        }
      }
      function handle_status_update(message) {
        var _a2;
        const { fn_index, ...status } = message;
        if (status.stage === "streaming" && status.time_limit) {
          dep.inputs.forEach((id2) => {
            set_time_limit(id2, status.time_limit);
          });
        }
        dep.inputs.forEach((id2) => {
          open_stream_events(message, id2, dep);
        });
        loading_status.update({
          ...status,
          time_limit: status.time_limit,
          status: status.stage,
          progress: status.progress_data,
          fn_index
        });
        set_status($loading_status);
        if (!showed_duplicate_message && space_id !== null && status.position !== void 0 && status.position >= 2 && status.eta !== void 0 && status.eta > SHOW_DUPLICATE_MESSAGE_ON_ETA) {
          showed_duplicate_message = true;
          $$invalidate(20, messages = [
            new_message("Warning", DUPLICATE_MESSAGE, fn_index, "warning"),
            ...messages
          ]);
        }
        if (!showed_mobile_warning && is_mobile_device && status.eta !== void 0 && status.eta > SHOW_MOBILE_QUEUE_WARNING_ON_ETA) {
          showed_mobile_warning = true;
          $$invalidate(20, messages = [
            new_message("Warning", MOBILE_QUEUE_WARNING, fn_index, "warning"),
            ...messages
          ]);
        }
        if (status.stage === "complete" || status.stage === "generating") {
          (_a2 = status.changed_state_ids) == null ? void 0 : _a2.forEach((id2) => {
            dependencies.filter((dep2) => dep2.targets.some(([_id2, _2]) => _id2 === id2)).forEach((dep2) => {
              wait_then_trigger_api_call(dep2.id, payload2.trigger_id);
            });
          });
        }
        if (status.stage === "complete") {
          dependencies.forEach(async (dep2) => {
            if (dep2.trigger_after === fn_index) {
              wait_then_trigger_api_call(dep2.id, payload2.trigger_id);
            }
          });
          dep.inputs.forEach((id2) => {
            modify_stream(id2, "closed");
          });
          submit_map.delete(dep_index);
        }
        if (status.broken && is_mobile_device && user_left_page) {
          window.setTimeout(
            () => {
              $$invalidate(20, messages = [
                new_message("Error", MOBILE_RECONNECT_MESSAGE, fn_index, "error"),
                ...messages
              ]);
            },
            0
          );
          wait_then_trigger_api_call(dep.id, payload2.trigger_id, event_data);
          user_left_page = false;
        } else if (status.stage === "error") {
          if (status.message) {
            const _message = status.message.replace(MESSAGE_QUOTE_RE, (_2, b) => b);
            const _title = status.title ?? "Error";
            $$invalidate(20, messages = [
              new_message(_title, _message, fn_index, "error", status.duration, status.visible),
              ...messages
            ]);
          }
          dependencies.map(async (dep2) => {
            if (dep2.trigger_after === fn_index && !dep2.trigger_only_on_success) {
              wait_then_trigger_api_call(dep2.id, payload2.trigger_id);
            }
          });
        }
      }
    }
  }
  function trigger_share(title2, description) {
    if (space_id === null) {
      return;
    }
    const discussion_url = new URL(`https://huggingface.co/spaces/${space_id}/discussions/new`);
    if (title2 !== void 0 && title2.length > 0) {
      discussion_url.searchParams.set("title", title2);
    }
    discussion_url.searchParams.set("description", description);
    window.open(discussion_url.toString(), "_blank");
  }
  function handle_error_close(e) {
    const _id2 = e.detail;
    $$invalidate(20, messages = messages.filter((m) => m.id !== _id2));
  }
  const is_external_url2 = (link2) => !!(link2 && new URL(link2, location.href).origin !== location.origin);
  async function handle_mount() {
    if (js) {
      let blocks_frontend_fn = new AsyncFunction(`let result = await (${js})();
					return (!Array.isArray(result)) ? [result] : result;`);
      await blocks_frontend_fn();
    }
    await tick();
    var a = target.getElementsByTagName("a");
    for (var i = 0; i < a.length; i++) {
      const _target = a[i].getAttribute("target");
      const _link = a[i].getAttribute("href");
      if (is_external_url2(_link) && _target !== "_blank")
        a[i].setAttribute("target", "_blank");
    }
    dependencies.forEach((dep) => {
      if (dep.targets.some((dep2) => dep2[1] === "load")) {
        wait_then_trigger_api_call(dep.id);
      }
    });
    if (!target || render_complete)
      return;
    target.addEventListener("prop_change", (e) => {
      if (!isCustomEvent(e))
        throw new Error("not a custom event");
      const { id: id2, prop, value } = e.detail;
      update_value([{ id: id2, prop, value }]);
      if (prop === "input_ready" && value === false) {
        inputs_waiting.push(id2);
      }
      if (prop === "input_ready" && value === true) {
        inputs_waiting = inputs_waiting.filter((item) => item !== id2);
      }
    });
    target.addEventListener("gradio", (e) => {
      var _a2, _b;
      if (!isCustomEvent(e))
        throw new Error("not a custom event");
      const { id: id2, event, data } = e.detail;
      if (event === "share") {
        const { title: title2, description } = data;
        trigger_share(title2, description);
      } else if (event === "error") {
        $$invalidate(20, messages = [new_message("Error", data, -1, event), ...messages]);
      } else if (event === "warning") {
        $$invalidate(20, messages = [new_message("Warning", data, -1, event), ...messages]);
      } else if (event == "clear_status") {
        update_status(id2, "complete", data);
      } else if (event == "close_stream") {
        const deps = (_a2 = $targets[id2]) == null ? void 0 : _a2[data];
        deps == null ? void 0 : deps.forEach((dep_id) => {
          if (submit_map.has(dep_id)) {
            const url = `${app.config.root + app.config.api_prefix}/stream/${submit_map.get(dep_id).event_id()}`;
            app.post_data(`${url}/close`, {});
            app.close_ws(url);
          }
        });
      } else {
        const deps = (_b = $targets[id2]) == null ? void 0 : _b[event];
        deps == null ? void 0 : deps.forEach((dep_id) => {
          requestAnimationFrame(() => {
            wait_then_trigger_api_call(dep_id, id2, data);
          });
        });
      }
    });
    $$invalidate(30, render_complete = true);
  }
  function update_status(id2, status, data) {
    data.status = status;
    update_value([{ id: id2, prop: "loading_status", value: data }]);
  }
  function set_status(statuses) {
    let updates = [];
    Object.entries(statuses).forEach(([id2, loading_status2]) => {
      let dependency = dependencies.find((dep) => dep.id == loading_status2.fn_index);
      if (dependency === void 0) {
        return;
      }
      loading_status2.scroll_to_output = dependency.scroll_to_output;
      loading_status2.show_progress = dependency.show_progress;
      updates.push({
        id: parseInt(id2),
        prop: "loading_status",
        value: loading_status2
      });
    });
    const inputs_to_update = loading_status.get_inputs_to_update();
    const additional_updates = Array.from(inputs_to_update).map(([id2, pending_status]) => {
      return {
        id: id2,
        prop: "pending",
        value: pending_status === "pending"
      };
    });
    update_value([...updates, ...additional_updates]);
  }
  onMount(() => {
    document.addEventListener("visibilitychange", function() {
      if (document.visibilityState === "hidden") {
        user_left_page = true;
      }
    });
    is_mobile_device = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  });
  const click_handler = () => {
    set_api_docs_visible(!api_docs_visible);
  };
  const click_handler_1 = () => {
    set_api_docs_visible(true);
    $$invalidate(18, api_recorder_visible = false);
  };
  const click_handler_2 = () => {
    set_api_docs_visible(false);
  };
  const close_handler = (event) => {
    var _a2;
    set_api_docs_visible(false);
    $$invalidate(19, api_calls = []);
    $$invalidate(18, api_recorder_visible = (_a2 = event.detail) == null ? void 0 : _a2.api_recorder_visible);
  };
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("components" in $$props2)
      $$invalidate(31, components = $$props2.components);
    if ("layout" in $$props2)
      $$invalidate(32, layout = $$props2.layout);
    if ("dependencies" in $$props2)
      $$invalidate(1, dependencies = $$props2.dependencies);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("target" in $$props2)
      $$invalidate(3, target = $$props2.target);
    if ("autoscroll" in $$props2)
      $$invalidate(4, autoscroll = $$props2.autoscroll);
    if ("show_api" in $$props2)
      $$invalidate(5, show_api = $$props2.show_api);
    if ("show_footer" in $$props2)
      $$invalidate(6, show_footer = $$props2.show_footer);
    if ("control_page_title" in $$props2)
      $$invalidate(7, control_page_title = $$props2.control_page_title);
    if ("app_mode" in $$props2)
      $$invalidate(8, app_mode = $$props2.app_mode);
    if ("theme_mode" in $$props2)
      $$invalidate(9, theme_mode = $$props2.theme_mode);
    if ("app" in $$props2)
      $$invalidate(10, app = $$props2.app);
    if ("space_id" in $$props2)
      $$invalidate(11, space_id = $$props2.space_id);
    if ("version" in $$props2)
      $$invalidate(12, version = $$props2.version);
    if ("js" in $$props2)
      $$invalidate(33, js = $$props2.js);
    if ("fill_height" in $$props2)
      $$invalidate(34, fill_height = $$props2.fill_height);
    if ("ready" in $$props2)
      $$invalidate(29, ready = $$props2.ready);
    if ("username" in $$props2)
      $$invalidate(13, username = $$props2.username);
    if ("api_prefix" in $$props2)
      $$invalidate(35, api_prefix = $$props2.api_prefix);
    if ("max_file_size" in $$props2)
      $$invalidate(14, max_file_size = $$props2.max_file_size);
    if ("initial_layout" in $$props2)
      $$invalidate(36, initial_layout = $$props2.initial_layout);
    if ("css" in $$props2)
      $$invalidate(15, css = $$props2.css);
    if ("search_params" in $$props2)
      $$invalidate(37, search_params = $$props2.search_params);
    if ("render_complete" in $$props2)
      $$invalidate(30, render_complete = $$props2.render_complete);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*dependencies, root, app, target*/
    1035 | $$self.$$.dirty[1] & /*components, layout, fill_height*/
    11) {
      run();
    }
    if ($$self.$$.dirty[0] & /*$_layout*/
    65536) {
      {
        $$invalidate(29, ready = !!$_layout);
      }
    }
    if ($$self.$$.dirty[1] & /*$loading_status*/
    256) {
      set_status($loading_status);
    }
  };
  return [
    root,
    dependencies,
    title,
    target,
    autoscroll,
    show_api,
    show_footer,
    control_page_title,
    app_mode,
    theme_mode,
    app,
    space_id,
    version,
    username,
    max_file_size,
    css,
    $_layout,
    api_docs_visible,
    api_recorder_visible,
    api_calls,
    messages,
    $_,
    _layout,
    targets,
    loading_status,
    scheduled_updates,
    set_api_docs_visible,
    handle_error_close,
    handle_mount,
    ready,
    render_complete,
    components,
    layout,
    js,
    fill_height,
    api_prefix,
    initial_layout,
    search_params,
    add_new_message,
    $loading_status,
    click_handler,
    click_handler_1,
    click_handler_2,
    close_handler
  ];
}
class Blocks extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(
      this,
      options2,
      instance$5,
      create_fragment$5,
      safe_not_equal,
      {
        root: 0,
        components: 31,
        layout: 32,
        dependencies: 1,
        title: 2,
        target: 3,
        autoscroll: 4,
        show_api: 5,
        show_footer: 6,
        control_page_title: 7,
        app_mode: 8,
        theme_mode: 9,
        app: 10,
        space_id: 11,
        version: 12,
        js: 33,
        fill_height: 34,
        ready: 29,
        username: 13,
        api_prefix: 35,
        max_file_size: 14,
        initial_layout: 36,
        css: 15,
        search_params: 37,
        render_complete: 30,
        add_new_message: 38
      },
      null,
      [-1, -1, -1]
    );
  }
  get add_new_message() {
    return this.$$.ctx[38];
  }
}
function create_fragment$4(ctx) {
  let div;
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "form svelte-633qhp");
      toggle_class(div, "hidden", !/*visible*/
      ctx[0]);
      set_style(
        div,
        "flex-grow",
        /*scale*/
        ctx[1]
      );
      set_style(div, "min-width", `calc(min(${/*min_width*/
      ctx[2]}px, 100%))`);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*visible*/
      1) {
        toggle_class(div, "hidden", !/*visible*/
        ctx2[0]);
      }
      if (dirty & /*scale*/
      2) {
        set_style(
          div,
          "flex-grow",
          /*scale*/
          ctx2[1]
        );
      }
      if (dirty & /*min_width*/
      4) {
        set_style(div, "min-width", `calc(min(${/*min_width*/
        ctx2[2]}px, 100%))`);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { visible = true } = $$props;
  let { scale = null } = $$props;
  let { min_width = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(0, visible = $$props2.visible);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
    if ("min_width" in $$props2)
      $$invalidate(2, min_width = $$props2.min_width);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [visible, scale, min_width, $$scope, slots];
}
let Index$2 = class Index extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$4, create_fragment$4, safe_not_equal, { visible: 0, scale: 1, min_width: 2 });
  }
};
const Index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Index$2
}, Symbol.toStringTag, { value: "Module" }));
function create_if_block_8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block_9, create_else_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[19]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_3(ctx) {
  let button;
  let copy2;
  let current2;
  let mounted;
  let dispose;
  copy2 = new Copy({});
  return {
    c() {
      button = element("button");
      create_component(copy2.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        "aria-roledescription": true
      });
      var button_nodes = children(button);
      claim_component(copy2.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "copy-button svelte-173056l");
      attr(button, "aria-label", "Copy");
      attr(button, "aria-roledescription", "Copy text");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      mount_component(copy2, button, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handle_copy*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(copy2.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(copy2.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(copy2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9(ctx) {
  let button;
  let check;
  let button_intro;
  let current2;
  check = new Check({});
  return {
    c() {
      button = element("button");
      create_component(check.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        "aria-roledescription": true
      });
      var button_nodes = children(button);
      claim_component(check.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "copy-button svelte-173056l");
      attr(button, "aria-label", "Copied");
      attr(button, "aria-roledescription", "Text copied");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      mount_component(check, button, null);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(check.$$.fragment, local);
      if (local) {
        if (!button_intro) {
          add_render_callback(() => {
            button_intro = create_in_transition(button, fade, { duration: 300 });
            button_intro.start();
          });
        }
      }
      current2 = true;
    },
    o(local) {
      transition_out(check.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(check);
    }
  };
}
function create_default_slot$2(ctx) {
  let t;
  return {
    c() {
      t = text$3(
        /*label*/
        ctx[3]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      8)
        set_data(
          t,
          /*label*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_else_block_2(ctx) {
  let textarea;
  let textarea_dir_value;
  let textarea_style_value;
  let text_area_resize_action;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      this.h();
    },
    l(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", {
        "data-testid": true,
        class: true,
        dir: true,
        placeholder: true,
        rows: true,
        maxlength: true,
        style: true
      });
      children(textarea).forEach(detach);
      this.h();
    },
    h() {
      attr(textarea, "data-testid", "textbox");
      attr(textarea, "class", "scroll-hide svelte-173056l");
      attr(textarea, "dir", textarea_dir_value = /*rtl*/
      ctx[13] ? "rtl" : "ltr");
      attr(
        textarea,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      attr(
        textarea,
        "rows",
        /*lines*/
        ctx[1]
      );
      textarea.disabled = /*disabled*/
      ctx[5];
      textarea.autofocus = /*autofocus*/
      ctx[14];
      attr(
        textarea,
        "maxlength",
        /*max_length*/
        ctx[16]
      );
      attr(textarea, "style", textarea_style_value = /*text_align*/
      ctx[15] ? "text-align: " + /*text_align*/
      ctx[15] : "");
      toggle_class(textarea, "no-label", !/*show_label*/
      ctx[6] && /*submit_btn*/
      (ctx[11] || /*stop_btn*/
      ctx[12]));
    },
    m(target, anchor) {
      insert_hydration(target, textarea, anchor);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      ctx[45](textarea);
      if (
        /*autofocus*/
        ctx[14]
      )
        textarea.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(text_area_resize_action = /*text_area_resize*/
          ctx[27].call(
            null,
            textarea,
            /*value*/
            ctx[0]
          )),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[44]
          ),
          listen(
            textarea,
            "keypress",
            /*handle_keypress*/
            ctx[23]
          ),
          listen(
            textarea,
            "blur",
            /*blur_handler_3*/
            ctx[36]
          ),
          listen(
            textarea,
            "select",
            /*handle_select*/
            ctx[22]
          ),
          listen(
            textarea,
            "focus",
            /*focus_handler_3*/
            ctx[37]
          ),
          listen(
            textarea,
            "scroll",
            /*handle_scroll*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*rtl*/
      8192 && textarea_dir_value !== (textarea_dir_value = /*rtl*/
      ctx2[13] ? "rtl" : "ltr")) {
        attr(textarea, "dir", textarea_dir_value);
      }
      if (dirty[0] & /*placeholder*/
      4) {
        attr(
          textarea,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*lines*/
      2) {
        attr(
          textarea,
          "rows",
          /*lines*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        textarea.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*autofocus*/
      16384) {
        textarea.autofocus = /*autofocus*/
        ctx2[14];
      }
      if (dirty[0] & /*max_length*/
      65536) {
        attr(
          textarea,
          "maxlength",
          /*max_length*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*text_align*/
      32768 && textarea_style_value !== (textarea_style_value = /*text_align*/
      ctx2[15] ? "text-align: " + /*text_align*/
      ctx2[15] : "")) {
        attr(textarea, "style", textarea_style_value);
      }
      if (text_area_resize_action && is_function(text_area_resize_action.update) && dirty[0] & /*value*/
      1)
        text_area_resize_action.update.call(
          null,
          /*value*/
          ctx2[0]
        );
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty[0] & /*show_label, submit_btn, stop_btn*/
      6208) {
        toggle_class(textarea, "no-label", !/*show_label*/
        ctx2[6] && /*submit_btn*/
        (ctx2[11] || /*stop_btn*/
        ctx2[12]));
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      ctx[45](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*type*/
      ctx2[9] === "text"
    )
      return create_if_block_5;
    if (
      /*type*/
      ctx2[9] === "password"
    )
      return create_if_block_6;
    if (
      /*type*/
      ctx2[9] === "email"
    )
      return create_if_block_7;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      this.h();
    },
    l(nodes) {
      input = claim_element(nodes, "INPUT", {
        "data-testid": true,
        type: true,
        class: true,
        placeholder: true,
        maxlength: true,
        autocomplete: true
      });
      this.h();
    },
    h() {
      attr(input, "data-testid", "textbox");
      attr(input, "type", "email");
      attr(input, "class", "scroll-hide svelte-173056l");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      input.disabled = /*disabled*/
      ctx[5];
      input.autofocus = /*autofocus*/
      ctx[14];
      attr(
        input,
        "maxlength",
        /*max_length*/
        ctx[16]
      );
      attr(input, "autocomplete", "email");
    },
    m(target, anchor) {
      insert_hydration(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[43](input);
      if (
        /*autofocus*/
        ctx[14]
      )
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler_2*/
            ctx[42]
          ),
          listen(
            input,
            "keypress",
            /*handle_keypress*/
            ctx[23]
          ),
          listen(
            input,
            "blur",
            /*blur_handler_2*/
            ctx[34]
          ),
          listen(
            input,
            "select",
            /*handle_select*/
            ctx[22]
          ),
          listen(
            input,
            "focus",
            /*focus_handler_2*/
            ctx[35]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*placeholder*/
      4) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        input.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*autofocus*/
      16384) {
        input.autofocus = /*autofocus*/
        ctx2[14];
      }
      if (dirty[0] & /*max_length*/
      65536) {
        attr(
          input,
          "maxlength",
          /*max_length*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[43](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_6(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      this.h();
    },
    l(nodes) {
      input = claim_element(nodes, "INPUT", {
        "data-testid": true,
        type: true,
        class: true,
        placeholder: true,
        maxlength: true,
        autocomplete: true
      });
      this.h();
    },
    h() {
      attr(input, "data-testid", "password");
      attr(input, "type", "password");
      attr(input, "class", "scroll-hide svelte-173056l");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      input.disabled = /*disabled*/
      ctx[5];
      input.autofocus = /*autofocus*/
      ctx[14];
      attr(
        input,
        "maxlength",
        /*max_length*/
        ctx[16]
      );
      attr(input, "autocomplete", "");
    },
    m(target, anchor) {
      insert_hydration(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[41](input);
      if (
        /*autofocus*/
        ctx[14]
      )
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[40]
          ),
          listen(
            input,
            "keypress",
            /*handle_keypress*/
            ctx[23]
          ),
          listen(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[32]
          ),
          listen(
            input,
            "select",
            /*handle_select*/
            ctx[22]
          ),
          listen(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*placeholder*/
      4) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        input.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*autofocus*/
      16384) {
        input.autofocus = /*autofocus*/
        ctx2[14];
      }
      if (dirty[0] & /*max_length*/
      65536) {
        attr(
          input,
          "maxlength",
          /*max_length*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[41](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5(ctx) {
  let input;
  let input_dir_value;
  let input_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      this.h();
    },
    l(nodes) {
      input = claim_element(nodes, "INPUT", {
        "data-testid": true,
        type: true,
        class: true,
        dir: true,
        placeholder: true,
        maxlength: true,
        style: true
      });
      this.h();
    },
    h() {
      attr(input, "data-testid", "textbox");
      attr(input, "type", "text");
      attr(input, "class", "scroll-hide svelte-173056l");
      attr(input, "dir", input_dir_value = /*rtl*/
      ctx[13] ? "rtl" : "ltr");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[2]
      );
      input.disabled = /*disabled*/
      ctx[5];
      input.autofocus = /*autofocus*/
      ctx[14];
      attr(
        input,
        "maxlength",
        /*max_length*/
        ctx[16]
      );
      attr(input, "style", input_style_value = /*text_align*/
      ctx[15] ? "text-align: " + /*text_align*/
      ctx[15] : "");
    },
    m(target, anchor) {
      insert_hydration(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      ctx[39](input);
      if (
        /*autofocus*/
        ctx[14]
      )
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[38]
          ),
          listen(
            input,
            "keypress",
            /*handle_keypress*/
            ctx[23]
          ),
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[30]
          ),
          listen(
            input,
            "select",
            /*handle_select*/
            ctx[22]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[31]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*rtl*/
      8192 && input_dir_value !== (input_dir_value = /*rtl*/
      ctx2[13] ? "rtl" : "ltr")) {
        attr(input, "dir", input_dir_value);
      }
      if (dirty[0] & /*placeholder*/
      4) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*disabled*/
      32) {
        input.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*autofocus*/
      16384) {
        input.autofocus = /*autofocus*/
        ctx2[14];
      }
      if (dirty[0] & /*max_length*/
      65536) {
        attr(
          input,
          "maxlength",
          /*max_length*/
          ctx2[16]
        );
      }
      if (dirty[0] & /*text_align*/
      32768 && input_style_value !== (input_style_value = /*text_align*/
      ctx2[15] ? "text-align: " + /*text_align*/
      ctx2[15] : "")) {
        attr(input, "style", input_style_value);
      }
      if (dirty[0] & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$2(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current2;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_3, create_else_block_1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*submit_btn*/
      ctx2[11] === true
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "submit-button svelte-173056l");
      toggle_class(
        button,
        "padded-button",
        /*submit_btn*/
        ctx[11] !== true
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handle_submit*/
          ctx[26]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current2 || dirty[0] & /*submit_btn*/
      2048) {
        toggle_class(
          button,
          "padded-button",
          /*submit_btn*/
          ctx2[11] !== true
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text$3(
        /*submit_btn*/
        ctx[11]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*submit_btn*/
        ctx[11]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*submit_btn*/
      2048)
        set_data(
          t,
          /*submit_btn*/
          ctx2[11]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let send;
  let current2;
  send = new Send({});
  return {
    c() {
      create_component(send.$$.fragment);
    },
    l(nodes) {
      claim_component(send.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(send, target, anchor);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(send.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(send.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(send, detaching);
    }
  };
}
function create_if_block$3(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current2;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$2, create_else_block];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*stop_btn*/
      ctx2[12] === true
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "stop-button svelte-173056l");
      toggle_class(
        button,
        "padded-button",
        /*stop_btn*/
        ctx[12] !== true
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handle_stop*/
          ctx[25]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current2 || dirty[0] & /*stop_btn*/
      4096) {
        toggle_class(
          button,
          "padded-button",
          /*stop_btn*/
          ctx2[12] !== true
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text$3(
        /*stop_btn*/
        ctx[12]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*stop_btn*/
        ctx[12]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*stop_btn*/
      4096)
        set_data(
          t,
          /*stop_btn*/
          ctx2[12]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1$2(ctx) {
  let square;
  let current2;
  square = new Square({
    props: { fill: "none", stroke_width: 2.5 }
  });
  return {
    c() {
      create_component(square.$$.fragment);
    },
    l(nodes) {
      claim_component(square.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(square, target, anchor);
      current2 = true;
    },
    p: noop,
    i(local) {
      if (current2)
        return;
      transition_in(square.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(square.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(square, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let label_1;
  let t0;
  let blocktitle;
  let t1;
  let div;
  let t2;
  let t3;
  let current2;
  let if_block0 = (
    /*show_label*/
    ctx[6] && /*show_copy_button*/
    ctx[10] && create_if_block_8(ctx)
  );
  blocktitle = new BlockTitle({
    props: {
      root: (
        /*root*/
        ctx[17]
      ),
      show_label: (
        /*show_label*/
        ctx[6]
      ),
      info: (
        /*info*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  function select_block_type_1(ctx2, dirty) {
    if (
      /*lines*/
      ctx2[1] === 1 && /*max_lines*/
      ctx2[8] === 1
    )
      return create_if_block_4;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  let if_block2 = (
    /*submit_btn*/
    ctx[11] && create_if_block_2$2(ctx)
  );
  let if_block3 = (
    /*stop_btn*/
    ctx[12] && create_if_block$3(ctx)
  );
  return {
    c() {
      label_1 = element("label");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(blocktitle.$$.fragment);
      t1 = space();
      div = element("div");
      if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      if (if_block0)
        if_block0.l(label_1_nodes);
      t0 = claim_space(label_1_nodes);
      claim_component(blocktitle.$$.fragment, label_1_nodes);
      t1 = claim_space(label_1_nodes);
      div = claim_element(label_1_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block1.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      div_nodes.forEach(detach);
      label_1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "input-container svelte-173056l");
      attr(label_1, "class", "svelte-173056l");
      toggle_class(
        label_1,
        "container",
        /*container*/
        ctx[7]
      );
      toggle_class(
        label_1,
        "show_textbox_border",
        /*show_textbox_border*/
        ctx[20]
      );
    },
    m(target, anchor) {
      insert_hydration(target, label_1, anchor);
      if (if_block0)
        if_block0.m(label_1, null);
      append_hydration(label_1, t0);
      mount_component(blocktitle, label_1, null);
      append_hydration(label_1, t1);
      append_hydration(label_1, div);
      if_block1.m(div, null);
      append_hydration(div, t2);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration(div, t3);
      if (if_block3)
        if_block3.m(div, null);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*show_label*/
        ctx2[6] && /*show_copy_button*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*show_label, show_copy_button*/
          1088) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label_1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const blocktitle_changes = {};
      if (dirty[0] & /*root*/
      131072)
        blocktitle_changes.root = /*root*/
        ctx2[17];
      if (dirty[0] & /*show_label*/
      64)
        blocktitle_changes.show_label = /*show_label*/
        ctx2[6];
      if (dirty[0] & /*info*/
      16)
        blocktitle_changes.info = /*info*/
        ctx2[4];
      if (dirty[0] & /*label*/
      8 | dirty[1] & /*$$scope*/
      16777216) {
        blocktitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blocktitle.$set(blocktitle_changes);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, t2);
        }
      }
      if (
        /*submit_btn*/
        ctx2[11]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*submit_btn*/
          2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*stop_btn*/
        ctx2[12]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*stop_btn*/
          4096) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current2 || dirty[0] & /*container*/
      128) {
        toggle_class(
          label_1,
          "container",
          /*container*/
          ctx2[7]
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block0);
      transition_in(blocktitle.$$.fragment, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current2 = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(blocktitle.$$.fragment, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label_1);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(blocktitle);
      if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { value = "" } = $$props;
  let { value_is_output = false } = $$props;
  let { lines = 1 } = $$props;
  let { placeholder = "Type here..." } = $$props;
  let { label: label2 } = $$props;
  let { info = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { show_label = true } = $$props;
  let { container = true } = $$props;
  let { max_lines } = $$props;
  let { type = "text" } = $$props;
  let { show_copy_button = false } = $$props;
  let { submit_btn = null } = $$props;
  let { stop_btn = null } = $$props;
  let { rtl = false } = $$props;
  let { autofocus = false } = $$props;
  let { text_align = void 0 } = $$props;
  let { autoscroll = true } = $$props;
  let { max_length = void 0 } = $$props;
  let { root } = $$props;
  let el;
  let copied = false;
  let timer;
  let can_scroll;
  let previous_scroll_top = 0;
  let user_has_scrolled_up = false;
  const show_textbox_border = !submit_btn;
  const dispatch = createEventDispatcher();
  beforeUpdate(() => {
    can_scroll = el && el.offsetHeight + el.scrollTop > el.scrollHeight - 100;
  });
  const scroll = () => {
    if (can_scroll && autoscroll && !user_has_scrolled_up) {
      el.scrollTo(0, el.scrollHeight);
    }
  };
  function handle_change() {
    dispatch("change", value);
    if (!value_is_output) {
      dispatch("input");
    }
  }
  afterUpdate(() => {
    if (autofocus) {
      el.focus();
    }
    if (can_scroll && autoscroll) {
      scroll();
    }
    $$invalidate(28, value_is_output = false);
  });
  async function handle_copy() {
    if ("clipboard" in navigator) {
      await navigator.clipboard.writeText(value);
      copy_feedback();
    }
  }
  function copy_feedback() {
    $$invalidate(19, copied = true);
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(
      () => {
        $$invalidate(19, copied = false);
      },
      1e3
    );
  }
  function handle_select(event) {
    const target = event.target;
    const text2 = target.value;
    const index = [target.selectionStart, target.selectionEnd];
    dispatch("select", { value: text2.substring(...index), index });
  }
  async function handle_keypress(e) {
    await tick();
    if (e.key === "Enter" && e.shiftKey && lines > 1) {
      e.preventDefault();
      dispatch("submit");
    } else if (e.key === "Enter" && !e.shiftKey && lines === 1 && max_lines >= 1) {
      e.preventDefault();
      dispatch("submit");
    }
  }
  function handle_scroll(event) {
    const target = event.target;
    const current_scroll_top = target.scrollTop;
    if (current_scroll_top < previous_scroll_top) {
      user_has_scrolled_up = true;
    }
    previous_scroll_top = current_scroll_top;
    const max_scroll_top = target.scrollHeight - target.clientHeight;
    const user_has_scrolled_to_bottom = current_scroll_top >= max_scroll_top;
    if (user_has_scrolled_to_bottom) {
      user_has_scrolled_up = false;
    }
  }
  function handle_stop() {
    dispatch("stop");
  }
  function handle_submit() {
    dispatch("submit");
  }
  async function resize(event) {
    await tick();
    if (lines === max_lines)
      return;
    const target = event.target;
    const computed_styles = window.getComputedStyle(target);
    const padding_top = parseFloat(computed_styles.paddingTop);
    const padding_bottom = parseFloat(computed_styles.paddingBottom);
    const line_height = parseFloat(computed_styles.lineHeight);
    let max = max_lines === void 0 ? false : padding_top + padding_bottom + line_height * max_lines;
    let min = padding_top + padding_bottom + lines * line_height;
    target.style.height = "1px";
    let scroll_height;
    if (max && target.scrollHeight > max) {
      scroll_height = max;
    } else if (target.scrollHeight < min) {
      scroll_height = min;
    } else {
      scroll_height = target.scrollHeight;
    }
    target.style.height = `${scroll_height}px`;
  }
  function text_area_resize(_el2, _value) {
    if (lines === max_lines)
      return;
    _el2.style.overflowY = "scroll";
    _el2.addEventListener("input", resize);
    if (!_value.trim())
      return;
    resize({ target: _el2 });
    return {
      destroy: () => _el2.removeEventListener("input", resize)
    };
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(18, el);
    });
  }
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(18, el);
    });
  }
  function input_input_handler_2() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(18, el);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(18, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("value_is_output" in $$props2)
      $$invalidate(28, value_is_output = $$props2.value_is_output);
    if ("lines" in $$props2)
      $$invalidate(1, lines = $$props2.lines);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("label" in $$props2)
      $$invalidate(3, label2 = $$props2.label);
    if ("info" in $$props2)
      $$invalidate(4, info = $$props2.info);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("show_label" in $$props2)
      $$invalidate(6, show_label = $$props2.show_label);
    if ("container" in $$props2)
      $$invalidate(7, container = $$props2.container);
    if ("max_lines" in $$props2)
      $$invalidate(8, max_lines = $$props2.max_lines);
    if ("type" in $$props2)
      $$invalidate(9, type = $$props2.type);
    if ("show_copy_button" in $$props2)
      $$invalidate(10, show_copy_button = $$props2.show_copy_button);
    if ("submit_btn" in $$props2)
      $$invalidate(11, submit_btn = $$props2.submit_btn);
    if ("stop_btn" in $$props2)
      $$invalidate(12, stop_btn = $$props2.stop_btn);
    if ("rtl" in $$props2)
      $$invalidate(13, rtl = $$props2.rtl);
    if ("autofocus" in $$props2)
      $$invalidate(14, autofocus = $$props2.autofocus);
    if ("text_align" in $$props2)
      $$invalidate(15, text_align = $$props2.text_align);
    if ("autoscroll" in $$props2)
      $$invalidate(29, autoscroll = $$props2.autoscroll);
    if ("max_length" in $$props2)
      $$invalidate(16, max_length = $$props2.max_length);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      if (value === null)
        $$invalidate(0, value = "");
    }
    if ($$self.$$.dirty[0] & /*value, el, lines, max_lines*/
    262403) {
      el && lines !== max_lines && resize({ target: el });
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      handle_change();
    }
  };
  return [
    value,
    lines,
    placeholder,
    label2,
    info,
    disabled,
    show_label,
    container,
    max_lines,
    type,
    show_copy_button,
    submit_btn,
    stop_btn,
    rtl,
    autofocus,
    text_align,
    max_length,
    root,
    el,
    copied,
    show_textbox_border,
    handle_copy,
    handle_select,
    handle_keypress,
    handle_scroll,
    handle_stop,
    handle_submit,
    text_area_resize,
    value_is_output,
    autoscroll,
    blur_handler,
    focus_handler,
    blur_handler_1,
    focus_handler_1,
    blur_handler_2,
    focus_handler_2,
    blur_handler_3,
    focus_handler_3,
    input_input_handler,
    input_binding,
    input_input_handler_1,
    input_binding_1,
    input_input_handler_2,
    input_binding_2,
    textarea_input_handler,
    textarea_binding
  ];
}
class Textbox extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(
      this,
      options2,
      instance$3,
      create_fragment$3,
      safe_not_equal,
      {
        value: 0,
        value_is_output: 28,
        lines: 1,
        placeholder: 2,
        label: 3,
        info: 4,
        disabled: 5,
        show_label: 6,
        container: 7,
        max_lines: 8,
        type: 9,
        show_copy_button: 10,
        submit_btn: 11,
        stop_btn: 12,
        rtl: 13,
        autofocus: 14,
        text_align: 15,
        autoscroll: 29,
        max_length: 16,
        root: 17
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block$2(ctx) {
  let statustracker;
  let current2;
  const statustracker_spread_levels = [
    { autoscroll: (
      /*gradio*/
      ctx[8].autoscroll
    ) },
    { i18n: (
      /*gradio*/
      ctx[8].i18n
    ) },
    /*loading_status*/
    ctx[7],
    {
      status: (
        /*loading_status*/
        ctx[7] ? (
          /*loading_status*/
          ctx[7].status == "pending" ? "generating" : (
            /*loading_status*/
            ctx[7].status
          )
        ) : null
      )
    }
  ];
  let statustracker_props = {};
  for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
    statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
  }
  statustracker = new Static({ props: statustracker_props });
  return {
    c() {
      create_component(statustracker.$$.fragment);
    },
    l(nodes) {
      claim_component(statustracker.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(statustracker, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const statustracker_changes = dirty & /*gradio, loading_status*/
      384 ? get_spread_update(statustracker_spread_levels, [
        dirty & /*gradio*/
        256 && { autoscroll: (
          /*gradio*/
          ctx2[8].autoscroll
        ) },
        dirty & /*gradio*/
        256 && { i18n: (
          /*gradio*/
          ctx2[8].i18n
        ) },
        dirty & /*loading_status*/
        128 && get_spread_object(
          /*loading_status*/
          ctx2[7]
        ),
        dirty & /*loading_status*/
        128 && {
          status: (
            /*loading_status*/
            ctx2[7] ? (
              /*loading_status*/
              ctx2[7].status == "pending" ? "generating" : (
                /*loading_status*/
                ctx2[7].status
              )
            ) : null
          )
        }
      ]) : {};
      statustracker.$set(statustracker_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(statustracker.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(statustracker.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(statustracker, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let div;
  let t;
  let div_class_value;
  let style_min_width = `calc(min(${/*min_width*/
  ctx[2]}px, 100%))`;
  let current2;
  let if_block = (
    /*loading_status*/
    ctx[7] && /*show_progress*/
    ctx[9] && /*gradio*/
    ctx[8] && create_if_block$2(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        div,
        "id",
        /*elem_id*/
        ctx[3]
      );
      attr(div, "class", div_class_value = "column " + /*elem_classes*/
      ctx[4].join(" ") + " svelte-vt1mxs");
      toggle_class(
        div,
        "gap",
        /*gap*/
        ctx[1]
      );
      toggle_class(
        div,
        "compact",
        /*variant*/
        ctx[6] === "compact"
      );
      toggle_class(
        div,
        "panel",
        /*variant*/
        ctx[6] === "panel"
      );
      toggle_class(div, "hide", !/*visible*/
      ctx[5]);
      set_style(
        div,
        "flex-grow",
        /*scale*/
        ctx[0]
      );
      set_style(div, "min-width", style_min_width);
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*loading_status*/
        ctx2[7] && /*show_progress*/
        ctx2[9] && /*gradio*/
        ctx2[8]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*loading_status, show_progress, gradio*/
          896) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current2 || dirty & /*elem_id*/
      8) {
        attr(
          div,
          "id",
          /*elem_id*/
          ctx2[3]
        );
      }
      if (!current2 || dirty & /*elem_classes*/
      16 && div_class_value !== (div_class_value = "column " + /*elem_classes*/
      ctx2[4].join(" ") + " svelte-vt1mxs")) {
        attr(div, "class", div_class_value);
      }
      if (!current2 || dirty & /*elem_classes, gap*/
      18) {
        toggle_class(
          div,
          "gap",
          /*gap*/
          ctx2[1]
        );
      }
      if (!current2 || dirty & /*elem_classes, variant*/
      80) {
        toggle_class(
          div,
          "compact",
          /*variant*/
          ctx2[6] === "compact"
        );
      }
      if (!current2 || dirty & /*elem_classes, variant*/
      80) {
        toggle_class(
          div,
          "panel",
          /*variant*/
          ctx2[6] === "panel"
        );
      }
      if (!current2 || dirty & /*elem_classes, visible*/
      48) {
        toggle_class(div, "hide", !/*visible*/
        ctx2[5]);
      }
      if (dirty & /*scale*/
      1) {
        set_style(
          div,
          "flex-grow",
          /*scale*/
          ctx2[0]
        );
      }
      if (dirty & /*min_width*/
      4 && style_min_width !== (style_min_width = `calc(min(${/*min_width*/
      ctx2[2]}px, 100%))`)) {
        set_style(div, "min-width", style_min_width);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { scale = null } = $$props;
  let { gap = true } = $$props;
  let { min_width = 0 } = $$props;
  let { elem_id = "" } = $$props;
  let { elem_classes = [] } = $$props;
  let { visible = true } = $$props;
  let { variant = "default" } = $$props;
  let { loading_status = void 0 } = $$props;
  let { gradio = void 0 } = $$props;
  let { show_progress = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("scale" in $$props2)
      $$invalidate(0, scale = $$props2.scale);
    if ("gap" in $$props2)
      $$invalidate(1, gap = $$props2.gap);
    if ("min_width" in $$props2)
      $$invalidate(2, min_width = $$props2.min_width);
    if ("elem_id" in $$props2)
      $$invalidate(3, elem_id = $$props2.elem_id);
    if ("elem_classes" in $$props2)
      $$invalidate(4, elem_classes = $$props2.elem_classes);
    if ("visible" in $$props2)
      $$invalidate(5, visible = $$props2.visible);
    if ("variant" in $$props2)
      $$invalidate(6, variant = $$props2.variant);
    if ("loading_status" in $$props2)
      $$invalidate(7, loading_status = $$props2.loading_status);
    if ("gradio" in $$props2)
      $$invalidate(8, gradio = $$props2.gradio);
    if ("show_progress" in $$props2)
      $$invalidate(9, show_progress = $$props2.show_progress);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    scale,
    gap,
    min_width,
    elem_id,
    elem_classes,
    visible,
    variant,
    loading_status,
    gradio,
    show_progress,
    $$scope,
    slots
  ];
}
class Index2 extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$2, create_fragment$2, safe_not_equal, {
      scale: 0,
      gap: 1,
      min_width: 2,
      elem_id: 3,
      elem_classes: 4,
      visible: 5,
      variant: 6,
      loading_status: 7,
      gradio: 8,
      show_progress: 9
    });
  }
}
const Index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Index2
}, Symbol.toStringTag, { value: "Module" }));
function create_if_block_2$1(ctx) {
  let p;
  let html_tag;
  return {
    c() {
      p = element("p");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      html_tag = claim_html_tag(p_nodes, false);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = null;
      attr(p, "class", "auth svelte-1ogxbi0");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      html_tag.m(
        /*auth_message*/
        ctx[1],
        p
      );
    },
    p(ctx2, dirty) {
      if (dirty & /*auth_message*/
      2)
        html_tag.p(
          /*auth_message*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$1(ctx) {
  let p;
  let t_value = (
    /*$_*/
    ctx[7]("login.enable_cookies") + ""
  );
  let t;
  return {
    c() {
      p = element("p");
      t = text$3(t_value);
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(p_nodes, t_value);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "auth svelte-1ogxbi0");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$_*/
      128 && t_value !== (t_value = /*$_*/
      ctx2[7]("login.enable_cookies") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$1(ctx) {
  let p;
  let t_value = (
    /*$_*/
    ctx[7]("login.incorrect_credentials") + ""
  );
  let t;
  return {
    c() {
      p = element("p");
      t = text$3(t_value);
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(p_nodes, t_value);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "creds svelte-1ogxbi0");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$_*/
      128 && t_value !== (t_value = /*$_*/
      ctx2[7]("login.incorrect_credentials") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_default_slot_4(ctx) {
  let textbox;
  let updating_value;
  let current2;
  function textbox_value_binding(value) {
    ctx[9](value);
  }
  let textbox_props = {
    root: (
      /*root*/
      ctx[0]
    ),
    label: "username",
    lines: 1,
    show_label: true,
    max_lines: 1
  };
  if (
    /*username*/
    ctx[4] !== void 0
  ) {
    textbox_props.value = /*username*/
    ctx[4];
  }
  textbox = new Textbox({ props: textbox_props });
  binding_callbacks.push(() => bind(textbox, "value", textbox_value_binding));
  textbox.$on(
    "submit",
    /*submit*/
    ctx[8]
  );
  return {
    c() {
      create_component(textbox.$$.fragment);
    },
    l(nodes) {
      claim_component(textbox.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(textbox, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const textbox_changes = {};
      if (dirty & /*root*/
      1)
        textbox_changes.root = /*root*/
        ctx2[0];
      if (!updating_value && dirty & /*username*/
      16) {
        updating_value = true;
        textbox_changes.value = /*username*/
        ctx2[4];
        add_flush_callback(() => updating_value = false);
      }
      textbox.$set(textbox_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(textbox.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(textbox.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(textbox, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let textbox;
  let updating_value;
  let current2;
  function textbox_value_binding_1(value) {
    ctx[10](value);
  }
  let textbox_props = {
    root: (
      /*root*/
      ctx[0]
    ),
    label: "password",
    lines: 1,
    show_label: true,
    max_lines: 1,
    type: "password"
  };
  if (
    /*password*/
    ctx[5] !== void 0
  ) {
    textbox_props.value = /*password*/
    ctx[5];
  }
  textbox = new Textbox({ props: textbox_props });
  binding_callbacks.push(() => bind(textbox, "value", textbox_value_binding_1));
  textbox.$on(
    "submit",
    /*submit*/
    ctx[8]
  );
  return {
    c() {
      create_component(textbox.$$.fragment);
    },
    l(nodes) {
      claim_component(textbox.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(textbox, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const textbox_changes = {};
      if (dirty & /*root*/
      1)
        textbox_changes.root = /*root*/
        ctx2[0];
      if (!updating_value && dirty & /*password*/
      32) {
        updating_value = true;
        textbox_changes.value = /*password*/
        ctx2[5];
        add_flush_callback(() => updating_value = false);
      }
      textbox.$set(textbox_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(textbox.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(textbox.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(textbox, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let block0;
  let t;
  let block1;
  let current2;
  block0 = new Block({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  block1 = new Block({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block0.$$.fragment);
      t = space();
      create_component(block1.$$.fragment);
    },
    l(nodes) {
      claim_component(block0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(block1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block0, target, anchor);
      insert_hydration(target, t, anchor);
      mount_component(block1, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const block0_changes = {};
      if (dirty & /*$$scope, root, username*/
      2065) {
        block0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block0.$set(block0_changes);
      const block1_changes = {};
      if (dirty & /*$$scope, root, password*/
      2081) {
        block1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block1.$set(block1_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(block0.$$.fragment, local);
      transition_in(block1.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(block0.$$.fragment, local);
      transition_out(block1.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(block0, detaching);
      destroy_component(block1, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let t_value = (
    /*$_*/
    ctx[7]("login.login") + ""
  );
  let t;
  return {
    c() {
      t = text$3(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$_*/
      128 && t_value !== (t_value = /*$_*/
      ctx2[7]("login.login") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_default_slot$1(ctx) {
  let h2;
  let t0_value = (
    /*$_*/
    ctx[7]("login.login") + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let form;
  let t5;
  let basebutton;
  let current2;
  let if_block0 = (
    /*auth_message*/
    ctx[1] && create_if_block_2$1(ctx)
  );
  let if_block1 = (
    /*space_id*/
    ctx[3] && create_if_block_1$1(ctx)
  );
  let if_block2 = (
    /*incorrect_credentials*/
    ctx[6] && create_if_block$1(ctx)
  );
  form = new Index$2({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  basebutton = new Button({
    props: {
      size: "lg",
      variant: "primary",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  basebutton.$on(
    "click",
    /*submit*/
    ctx[8]
  );
  return {
    c() {
      h2 = element("h2");
      t0 = text$3(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      create_component(form.$$.fragment);
      t5 = space();
      create_component(basebutton.$$.fragment);
      this.h();
    },
    l(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, t0_value);
      h2_nodes.forEach(detach);
      t1 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t2 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t4 = claim_space(nodes);
      claim_component(form.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(basebutton.$$.fragment, nodes);
      this.h();
    },
    h() {
      attr(h2, "class", "svelte-1ogxbi0");
    },
    m(target, anchor) {
      insert_hydration(target, h2, anchor);
      append_hydration(h2, t0);
      insert_hydration(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration(target, t4, anchor);
      mount_component(form, target, anchor);
      insert_hydration(target, t5, anchor);
      mount_component(basebutton, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if ((!current2 || dirty & /*$_*/
      128) && t0_value !== (t0_value = /*$_*/
      ctx2[7]("login.login") + ""))
        set_data(t0, t0_value);
      if (
        /*auth_message*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$1(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*space_id*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1(ctx2);
          if_block1.c();
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*incorrect_credentials*/
        ctx2[6]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$1(ctx2);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      const form_changes = {};
      if (dirty & /*$$scope, root, password, username*/
      2097) {
        form_changes.$$scope = { dirty, ctx: ctx2 };
      }
      form.$set(form_changes);
      const basebutton_changes = {};
      if (dirty & /*$$scope, $_*/
      2176) {
        basebutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      basebutton.$set(basebutton_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(form.$$.fragment, local);
      transition_in(basebutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(form.$$.fragment, local);
      transition_out(basebutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      destroy_component(form, detaching);
      destroy_component(basebutton, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let div;
  let column;
  let current2;
  column = new Index2({
    props: {
      variant: "panel",
      min_width: 480,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(column.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(column.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "wrap svelte-1ogxbi0");
      toggle_class(
        div,
        "min-h-screen",
        /*app_mode*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      mount_component(column, div, null);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const column_changes = {};
      if (dirty & /*$$scope, $_, root, password, username, incorrect_credentials, space_id, auth_message*/
      2299) {
        column_changes.$$scope = { dirty, ctx: ctx2 };
      }
      column.$set(column_changes);
      if (!current2 || dirty & /*app_mode*/
      4) {
        toggle_class(
          div,
          "min-h-screen",
          /*app_mode*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(column.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(column.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(column);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, $format, ($$value) => $$invalidate(7, $_ = $$value));
  let { root } = $$props;
  let { auth_message } = $$props;
  let { app_mode } = $$props;
  let { space_id } = $$props;
  let username = "";
  let password = "";
  let incorrect_credentials = false;
  const submit2 = async () => {
    const formData = new FormData();
    formData.append("username", username);
    formData.append("password", password);
    let response = await fetch(root + "/login", { method: "POST", body: formData });
    if (response.status === 400) {
      $$invalidate(6, incorrect_credentials = true);
      $$invalidate(4, username = "");
      $$invalidate(5, password = "");
    } else if (response.status == 200) {
      location.reload();
    }
  };
  function textbox_value_binding(value) {
    username = value;
    $$invalidate(4, username);
  }
  function textbox_value_binding_1(value) {
    password = value;
    $$invalidate(5, password);
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root = $$props2.root);
    if ("auth_message" in $$props2)
      $$invalidate(1, auth_message = $$props2.auth_message);
    if ("app_mode" in $$props2)
      $$invalidate(2, app_mode = $$props2.app_mode);
    if ("space_id" in $$props2)
      $$invalidate(3, space_id = $$props2.space_id);
  };
  return [
    root,
    auth_message,
    app_mode,
    space_id,
    username,
    password,
    incorrect_credentials,
    $_,
    submit2,
    textbox_value_binding,
    textbox_value_binding_1
  ];
}
class Login extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(this, options2, instance$1, create_fragment$1, safe_not_equal, {
      root: 0,
      auth_message: 1,
      app_mode: 2,
      space_id: 3
    });
  }
}
async function load({
  url,
  data: { server, port, local_dev_mode, custom_path }
}) {
  var _a2;
  const api_url = !local_dev_mode ? new URL(".", location.href).href : server;
  const app = await Client.connect(api_url, {
    with_null_state: true,
    events: ["data", "log", "status", "render"]
  });
  if (!app.config) {
    throw new Error("No config found");
  }
  const { create_layout, layout } = create_components(void 0);
  await create_layout({
    app,
    components: app.config.components,
    dependencies: app.config.dependencies,
    layout: app.config.layout,
    root: app.config.root + app.config.api_prefix,
    options: {
      fill_height: app.config.fill_height
    }
  });
  const layouts = get(layout);
  return {
    Render: ((_a2 = app.config) == null ? void 0 : _a2.auth_required) ? Login : Blocks,
    config: app.config,
    api_url,
    layout: layouts,
    app
  };
}
const _page = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  load
}, Symbol.toStringTag, { value: "Module" }));
var inject_fonts = () => {
  const source_sans_pro = document.createElement("link");
  source_sans_pro.href = "https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap";
  source_sans_pro.rel = "stylesheet";
  const ibm_mono = document.createElement("link");
  ibm_mono.href = "https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&display=swap";
  ibm_mono.rel = "stylesheet";
  document.head.appendChild(source_sans_pro);
  document.head.appendChild(ibm_mono);
};
var Box = () => {
  const box = document.createElement("div");
  box.style.backgroundImage = "linear-gradient(to top, #f9fafb, white)";
  box.style.border = "1px solid #e5e7eb";
  box.style.borderRadius = "0.75rem";
  box.style.boxShadow = "0 0 10px rgba(0, 0, 0, 0.1)";
  box.style.color = "#374151";
  box.style.display = "flex";
  box.style.flexDirection = "row";
  box.style.alignItems = "center";
  box.style.height = "40px";
  box.style.justifyContent = "space-between";
  box.style.overflow = "hidden";
  box.style.position = "fixed";
  box.style.right = ".75rem";
  box.style.top = ".75rem";
  box.style.width = "auto";
  box.style.zIndex = "20";
  box.style.paddingLeft = "1rem";
  box.setAttribute("id", "huggingface-space-header");
  window.matchMedia("(max-width: 768px)").addEventListener("change", (e) => {
    if (e.matches) {
      box.style.display = "none";
    } else {
      box.style.display = "flex";
    }
  });
  return box;
};
var ArrowCollapse = () => {
  const arrow = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  arrow.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  arrow.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink");
  arrow.setAttribute("aria-hidden", "true");
  arrow.setAttribute("focusable", "false");
  arrow.setAttribute("role", "img");
  arrow.setAttribute("width", "1em");
  arrow.setAttribute("height", "1em");
  arrow.setAttribute("preserveAspectRatio", "xMidYMid meet");
  arrow.setAttribute("viewBox", "0 0 12 12");
  arrow.setAttribute("fill", "currentColor");
  const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path2.setAttribute(
    "d",
    "M0.375001 10.3828L0.375 1.61719C0.375 1.104 0.816001 0.687501 1.35938 0.687501L10.6406 0.6875C10.9017 0.6875 11.1521 0.785449 11.3367 0.959797C11.5213 1.13415 11.625 1.37062 11.625 1.61719V10.3828C11.625 10.6294 11.5213 10.8659 11.3367 11.0402C11.1521 11.2145 10.9017 11.3125 10.6406 11.3125H1.35938C0.816001 11.3125 0.375001 10.896 0.375001 10.3828ZM1.35938 10.5156H10.6406C10.7183 10.5156 10.7813 10.4561 10.7813 10.3828V4.40625H1.21875V10.3828C1.21875 10.418 1.23356 10.4518 1.25994 10.4767C1.28631 10.5017 1.32208 10.5156 1.35938 10.5156ZM4.61052 6.38251L5.9999 7.69472L7.38927 6.38251C7.44083 6.33007 7.50645 6.29173 7.57913 6.27153C7.6518 6.25134 7.72898 6.25003 7.8024 6.26776C7.87583 6.28549 7.9428 6.3216 7.99628 6.37227C8.04983 6.42295 8.08785 6.48631 8.10645 6.5557C8.12528 6.62497 8.12393 6.69773 8.10263 6.76635C8.0814 6.83497 8.0409 6.8969 7.98555 6.94564L6.29802 8.53936C6.21892 8.61399 6.11169 8.65592 5.9999 8.65592C5.8881 8.65592 5.78087 8.61399 5.70177 8.53936L4.01427 6.94564C3.95874 6.89694 3.91814 6.835 3.89676 6.76633C3.87538 6.69766 3.874 6.62483 3.89277 6.55549C3.91154 6.48615 3.94977 6.42287 4.00343 6.37233C4.05708 6.32179 4.12418 6.28585 4.19765 6.2683C4.27098 6.25054 4.34803 6.25178 4.42068 6.27188C4.49334 6.29198 4.55891 6.3302 4.61052 6.38251Z"
  );
  arrow.appendChild(path2);
  return arrow;
};
var Collapse = (space2, callback) => {
  const box = document.createElement("div");
  box.setAttribute("id", "space-header__collapse");
  box.style.display = "flex";
  box.style.flexDirection = "row";
  box.style.alignItems = "center";
  box.style.justifyContent = "center";
  box.style.fontSize = "16px";
  box.style.paddingLeft = "10px";
  box.style.paddingRight = "10px";
  box.style.height = "40px";
  box.style.cursor = "pointer";
  box.style.color = "#40546e";
  box.style.transitionDuration = "0.1s";
  box.style.transitionProperty = "all";
  box.style.transitionTimingFunction = "ease-in-out";
  box.appendChild(ArrowCollapse());
  box.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    callback();
  });
  box.addEventListener("mouseenter", () => {
    box.style.color = "#213551";
  });
  box.addEventListener("mouseleave", () => {
    box.style.color = "#40546e";
  });
  return box;
};
var Count = (count) => {
  const text2 = document.createElement("p");
  text2.style.margin = "0";
  text2.style.padding = "0";
  text2.style.color = "#9ca3af";
  text2.style.fontSize = "14px";
  text2.style.fontFamily = "Source Sans Pro, sans-serif";
  text2.style.padding = "0px 6px";
  text2.style.borderLeft = "1px solid #e5e7eb";
  text2.style.marginLeft = "4px";
  text2.textContent = (count != null ? count : 0).toString();
  return text2;
};
var Heart = () => {
  const heart = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  heart.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  heart.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink");
  heart.setAttribute("aria-hidden", "true");
  heart.setAttribute("focusable", "false");
  heart.setAttribute("role", "img");
  heart.setAttribute("width", "1em");
  heart.setAttribute("height", "1em");
  heart.setAttribute("preserveAspectRatio", "xMidYMid meet");
  heart.setAttribute("viewBox", "0 0 32 32");
  heart.setAttribute("fill", "#6b7280");
  const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path2.setAttribute(
    "d",
    "M22.45,6a5.47,5.47,0,0,1,3.91,1.64,5.7,5.7,0,0,1,0,8L16,26.13,5.64,15.64a5.7,5.7,0,0,1,0-8,5.48,5.48,0,0,1,7.82,0L16,10.24l2.53-2.58A5.44,5.44,0,0,1,22.45,6m0-2a7.47,7.47,0,0,0-5.34,2.24L16,7.36,14.89,6.24a7.49,7.49,0,0,0-10.68,0,7.72,7.72,0,0,0,0,10.82L16,29,27.79,17.06a7.72,7.72,0,0,0,0-10.82A7.49,7.49,0,0,0,22.45,4Z"
  );
  heart.appendChild(path2);
  return heart;
};
var Like = (space2) => {
  const box = document.createElement("a");
  box.setAttribute("href", `https://huggingface.co/spaces/${space2.id}`);
  box.setAttribute("rel", "noopener noreferrer");
  box.setAttribute("target", "_blank");
  box.style.border = "1px solid #e5e7eb";
  box.style.borderRadius = "6px";
  box.style.display = "flex";
  box.style.flexDirection = "row";
  box.style.alignItems = "center";
  box.style.margin = "0 0 0 12px";
  box.style.fontSize = "14px";
  box.style.paddingLeft = "4px";
  box.style.textDecoration = "none";
  box.appendChild(Heart());
  box.appendChild(Count(space2.likes));
  return box;
};
var Avatar = (username) => {
  const element2 = document.createElement("img");
  element2.src = `https://huggingface.co/api/users/${username}/avatar`;
  element2.style.width = "0.875rem";
  element2.style.height = "0.875rem";
  element2.style.borderRadius = "50%";
  element2.style.flex = "none";
  element2.style.marginRight = "0.375rem";
  return element2;
};
var Namespace2 = (id2) => {
  const [_, spaceName] = id2.split("/");
  const element2 = document.createElement("a");
  element2.setAttribute("href", `https://huggingface.co/spaces/${id2}`);
  element2.setAttribute("rel", "noopener noreferrer");
  element2.setAttribute("target", "_blank");
  element2.style.color = "#1f2937";
  element2.style.textDecoration = "none";
  element2.style.fontWeight = "600";
  element2.style.fontSize = "15px";
  element2.style.lineHeight = "24px";
  element2.style.flex = "none";
  element2.style.fontFamily = "IBM Plex Mono, sans-serif";
  element2.addEventListener("mouseover", () => {
    element2.style.color = "#2563eb";
  });
  element2.addEventListener("mouseout", () => {
    element2.style.color = "#1f2937";
  });
  element2.textContent = spaceName;
  return element2;
};
var Separation = () => {
  const separation = document.createElement("div");
  separation.style.marginLeft = ".125rem";
  separation.style.marginRight = ".125rem";
  separation.style.color = "#d1d5db";
  separation.textContent = "/";
  return separation;
};
var Username = (username) => {
  const element2 = document.createElement("a");
  element2.setAttribute("href", `https://huggingface.co/${username}`);
  element2.setAttribute("rel", "noopener noreferrer");
  element2.setAttribute("target", "_blank");
  element2.style.color = "rgb(107, 114, 128)";
  element2.style.textDecoration = "none";
  element2.style.fontWeight = "400";
  element2.style.fontSize = "16px";
  element2.style.lineHeight = "24px";
  element2.style.flex = "none";
  element2.style.fontFamily = "Source Sans Pro, sans-serif";
  element2.addEventListener("mouseover", () => {
    element2.style.color = "#2563eb";
  });
  element2.addEventListener("mouseout", () => {
    element2.style.color = "rgb(107, 114, 128)";
  });
  element2.textContent = username;
  return element2;
};
var Content = (space2) => {
  const content = document.createElement("div");
  content.style.display = "flex";
  content.style.flexDirection = "row";
  content.style.alignItems = "center";
  content.style.justifyContent = "center";
  content.style.borderRight = "1px solid #e5e7eb";
  content.style.paddingRight = "12px";
  content.style.height = "40px";
  content.appendChild(Avatar(space2.author));
  content.appendChild(Username(space2.author));
  content.appendChild(Separation());
  content.appendChild(Namespace2(space2.id));
  content.appendChild(Like(space2));
  return content;
};
var create2 = (space2) => {
  const box = Box();
  const handleCollapse = () => box.style.display = "none";
  box.appendChild(Content(space2));
  box.appendChild(Collapse(space2, handleCollapse));
  return box;
};
var get_space = async (space_id) => {
  try {
    const response = await fetch(`https://huggingface.co/api/spaces/${space_id}`);
    const data = await response.json();
    return data;
  } catch (error) {
    return null;
  }
};
var inject = (element2, options2) => {
  if (document.body === null) {
    return console.error("document.body is null");
  }
  document.body.appendChild(element2);
};
async function main(initialSpace, options2) {
  var _a2, _b;
  if (window === void 0)
    return console.error("Please run this script in a browser environment");
  const has_huggingface_ancestor = Object.values(
    (_b = (_a2 = window.location) == null ? void 0 : _a2.ancestorOrigins) != null ? _b : {
      0: window.document.referrer
    }
  ).some((origin) => {
    var _a22;
    return ((_a22 = new URL(origin)) == null ? void 0 : _a22.origin) === "https://huggingface.co";
  });
  if (has_huggingface_ancestor)
    return;
  inject_fonts();
  let space2;
  if (typeof initialSpace === "string") {
    space2 = await get_space(initialSpace);
    if (space2 === null)
      return console.error("Space not found");
  } else {
    space2 = initialSpace;
  }
  const mini_header_element = create2(space2);
  inject(mini_header_element);
  return {
    element: mini_header_element
  };
}
var init = (space2, options2) => main(space2);
const { document: document_1 } = globals;
function create_if_block_2(ctx) {
  let html_tag;
  let raw_value = (
    /*config*/
    ctx[12].head + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*config*/
      4096 && raw_value !== (raw_value = /*config*/
      ctx2[12].head + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_1(ctx) {
  let switch_instance;
  let updating_ready;
  let updating_render_complete;
  let updating_add_new_message;
  let switch_instance_anchor;
  let current2;
  const switch_instance_spread_levels = [
    { app: (
      /*app*/
      ctx[11]
    ) },
    /*config*/
    ctx[12],
    {
      fill_height: !/*is_embed*/
      ctx[5] && /*config*/
      ctx[12].fill_height
    },
    {
      theme_mode: (
        /*active_theme_mode*/
        ctx[13]
      )
    },
    {
      control_page_title: (
        /*control_page_title*/
        ctx[6]
      )
    },
    { target: (
      /*wrapper*/
      ctx[9]
    ) },
    { autoscroll: (
      /*autoscroll*/
      ctx[1]
    ) },
    { show_footer: !/*is_embed*/
    ctx[5] },
    { app_mode: (
      /*app_mode*/
      ctx[4]
    ) },
    { version: (
      /*version*/
      ctx[2]
    ) },
    {
      search_params: (
        /*$page*/
        ctx[16].url.searchParams
      )
    },
    { initial_layout: (
      /*data*/
      ctx[0].layout
    ) }
  ];
  function switch_instance_ready_binding(value) {
    ctx[18](value);
  }
  function switch_instance_render_complete_binding(value) {
    ctx[19](value);
  }
  function switch_instance_add_new_message_binding(value) {
    ctx[20](value);
  }
  var switch_value = (
    /*data*/
    ctx[0].Render
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*app, config, is_embed, active_theme_mode, control_page_title, wrapper, autoscroll, app_mode, version, $page, data*/
    80503) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*app*/
        2048 && { app: (
          /*app*/
          ctx2[11]
        ) },
        dirty[0] & /*config*/
        4096 && get_spread_object(
          /*config*/
          ctx2[12]
        ),
        dirty[0] & /*is_embed, config*/
        4128 && {
          fill_height: !/*is_embed*/
          ctx2[5] && /*config*/
          ctx2[12].fill_height
        },
        dirty[0] & /*active_theme_mode*/
        8192 && {
          theme_mode: (
            /*active_theme_mode*/
            ctx2[13]
          )
        },
        dirty[0] & /*control_page_title*/
        64 && {
          control_page_title: (
            /*control_page_title*/
            ctx2[6]
          )
        },
        dirty[0] & /*wrapper*/
        512 && { target: (
          /*wrapper*/
          ctx2[9]
        ) },
        dirty[0] & /*autoscroll*/
        2 && { autoscroll: (
          /*autoscroll*/
          ctx2[1]
        ) },
        dirty[0] & /*is_embed*/
        32 && { show_footer: !/*is_embed*/
        ctx2[5] },
        dirty[0] & /*app_mode*/
        16 && { app_mode: (
          /*app_mode*/
          ctx2[4]
        ) },
        dirty[0] & /*version*/
        4 && { version: (
          /*version*/
          ctx2[2]
        ) },
        dirty[0] & /*$page*/
        65536 && {
          search_params: (
            /*$page*/
            ctx2[16].url.searchParams
          )
        },
        dirty[0] & /*data*/
        1 && { initial_layout: (
          /*data*/
          ctx2[0].layout
        ) }
      ]));
    }
    if (
      /*ready*/
      ctx2[14] !== void 0
    ) {
      switch_instance_props.ready = /*ready*/
      ctx2[14];
    }
    if (
      /*render_complete*/
      ctx2[10] !== void 0
    ) {
      switch_instance_props.render_complete = /*render_complete*/
      ctx2[10];
    }
    if (
      /*new_message_fn*/
      ctx2[15] !== void 0
    ) {
      switch_instance_props.add_new_message = /*new_message_fn*/
      ctx2[15];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "ready", switch_instance_ready_binding));
    binding_callbacks.push(() => bind(switch_instance, "render_complete", switch_instance_render_complete_binding));
    binding_callbacks.push(() => bind(switch_instance, "add_new_message", switch_instance_add_new_message_binding));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*data*/
      1 && switch_value !== (switch_value = /*data*/
      ctx2[0].Render)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          binding_callbacks.push(() => bind(switch_instance, "ready", switch_instance_ready_binding));
          binding_callbacks.push(() => bind(switch_instance, "render_complete", switch_instance_render_complete_binding));
          binding_callbacks.push(() => bind(switch_instance, "add_new_message", switch_instance_add_new_message_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*app, config, is_embed, active_theme_mode, control_page_title, wrapper, autoscroll, app_mode, version, $page, data*/
        80503 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*app*/
          2048 && { app: (
            /*app*/
            ctx2[11]
          ) },
          dirty[0] & /*config*/
          4096 && get_spread_object(
            /*config*/
            ctx2[12]
          ),
          dirty[0] & /*is_embed, config*/
          4128 && {
            fill_height: !/*is_embed*/
            ctx2[5] && /*config*/
            ctx2[12].fill_height
          },
          dirty[0] & /*active_theme_mode*/
          8192 && {
            theme_mode: (
              /*active_theme_mode*/
              ctx2[13]
            )
          },
          dirty[0] & /*control_page_title*/
          64 && {
            control_page_title: (
              /*control_page_title*/
              ctx2[6]
            )
          },
          dirty[0] & /*wrapper*/
          512 && { target: (
            /*wrapper*/
            ctx2[9]
          ) },
          dirty[0] & /*autoscroll*/
          2 && { autoscroll: (
            /*autoscroll*/
            ctx2[1]
          ) },
          dirty[0] & /*is_embed*/
          32 && { show_footer: !/*is_embed*/
          ctx2[5] },
          dirty[0] & /*app_mode*/
          16 && { app_mode: (
            /*app_mode*/
            ctx2[4]
          ) },
          dirty[0] & /*version*/
          4 && { version: (
            /*version*/
            ctx2[2]
          ) },
          dirty[0] & /*$page*/
          65536 && {
            search_params: (
              /*$page*/
              ctx2[16].url.searchParams
            )
          },
          dirty[0] & /*data*/
          1 && { initial_layout: (
            /*data*/
            ctx2[0].layout
          ) }
        ]) : {};
        if (!updating_ready && dirty[0] & /*ready*/
        16384) {
          updating_ready = true;
          switch_instance_changes.ready = /*ready*/
          ctx2[14];
          add_flush_callback(() => updating_ready = false);
        }
        if (!updating_render_complete && dirty[0] & /*render_complete*/
        1024) {
          updating_render_complete = true;
          switch_instance_changes.render_complete = /*render_complete*/
          ctx2[10];
          add_flush_callback(() => updating_render_complete = false);
        }
        if (!updating_add_new_message && dirty[0] & /*new_message_fn*/
        32768) {
          updating_add_new_message = true;
          switch_instance_changes.add_new_message = /*new_message_fn*/
          ctx2[15];
          add_flush_callback(() => updating_add_new_message = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current2)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current2;
  var switch_value = (
    /*data*/
    ctx[0].Render
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        auth_message: (
          /*config*/
          ctx2[12].auth_message
        ),
        root: (
          /*config*/
          ctx2[12].root
        ),
        space_id: (
          /*space*/
          ctx2[8]
        ),
        app_mode: (
          /*app_mode*/
          ctx2[4]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*data*/
      1 && switch_value !== (switch_value = /*data*/
      ctx2[0].Render)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*config*/
        4096)
          switch_instance_changes.auth_message = /*config*/
          ctx2[12].auth_message;
        if (dirty[0] & /*config*/
        4096)
          switch_instance_changes.root = /*config*/
          ctx2[12].root;
        if (dirty[0] & /*space*/
        256)
          switch_instance_changes.space_id = /*space*/
          ctx2[8];
        if (dirty[0] & /*app_mode*/
        16)
          switch_instance_changes.app_mode = /*app_mode*/
          ctx2[4];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current2)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a2;
    if (
      /*config*/
      (_a2 = ctx2[12]) == null ? void 0 : _a2.auth_required
    )
      return 0;
    if (
      /*config*/
      ctx2[12] && /*app*/
      ctx2[11]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment(ctx) {
  var _a2;
  let link2;
  let link_href_value;
  let if_block_anchor;
  let t;
  let embed;
  let updating_wrapper;
  let current2;
  let if_block = (
    /*config*/
    ctx[12].head && create_if_block_2(ctx)
  );
  function embed_wrapper_binding(value) {
    ctx[21](value);
  }
  let embed_props = {
    display: (
      /*container*/
      ctx[7] && /*is_embed*/
      ctx[5]
    ),
    is_embed: (
      /*is_embed*/
      ctx[5]
    ),
    info: false,
    version: (
      /*version*/
      ctx[2]
    ),
    initial_height: (
      /*initial_height*/
      ctx[3]
    ),
    space: (
      /*space*/
      ctx[8]
    ),
    loaded: loader_status === "complete",
    fill_width: (
      /*config*/
      ((_a2 = ctx[12]) == null ? void 0 : _a2.fill_width) || false
    ),
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*wrapper*/
    ctx[9] !== void 0
  ) {
    embed_props.wrapper = /*wrapper*/
    ctx[9];
  }
  embed = new Embed({ props: embed_props });
  binding_callbacks.push(() => bind(embed, "wrapper", embed_wrapper_binding));
  return {
    c() {
      link2 = element("link");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      t = space();
      create_component(embed.$$.fragment);
      this.h();
    },
    l(nodes) {
      const head_nodes = head_selector("svelte-1fnmhmq", document_1.head);
      link2 = claim_element(head_nodes, "LINK", { rel: true, href: true });
      if (if_block)
        if_block.l(head_nodes);
      if_block_anchor = empty();
      head_nodes.forEach(detach);
      t = claim_space(nodes);
      claim_component(embed.$$.fragment, nodes);
      this.h();
    },
    h() {
      var _a3;
      attr(link2, "rel", "stylesheet");
      attr(link2, "href", link_href_value = "./theme.css?v=" + /*config*/
      ((_a3 = ctx[12]) == null ? void 0 : _a3.theme_hash));
    },
    m(target, anchor) {
      append_hydration(document_1.head, link2);
      if (if_block)
        if_block.m(document_1.head, null);
      append_hydration(document_1.head, if_block_anchor);
      insert_hydration(target, t, anchor);
      mount_component(embed, target, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      var _a3, _b;
      if (!current2 || dirty[0] & /*config*/
      4096 && link_href_value !== (link_href_value = "./theme.css?v=" + /*config*/
      ((_a3 = ctx2[12]) == null ? void 0 : _a3.theme_hash))) {
        attr(link2, "href", link_href_value);
      }
      if (
        /*config*/
        ctx2[12].head
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const embed_changes = {};
      if (dirty[0] & /*container, is_embed*/
      160)
        embed_changes.display = /*container*/
        ctx2[7] && /*is_embed*/
        ctx2[5];
      if (dirty[0] & /*is_embed*/
      32)
        embed_changes.is_embed = /*is_embed*/
        ctx2[5];
      if (dirty[0] & /*version*/
      4)
        embed_changes.version = /*version*/
        ctx2[2];
      if (dirty[0] & /*initial_height*/
      8)
        embed_changes.initial_height = /*initial_height*/
        ctx2[3];
      if (dirty[0] & /*space*/
      256)
        embed_changes.space = /*space*/
        ctx2[8];
      if (dirty[0] & /*config*/
      4096)
        embed_changes.fill_width = /*config*/
        ((_b = ctx2[12]) == null ? void 0 : _b.fill_width) || false;
      if (dirty[0] & /*data, config, space, app_mode, app, is_embed, active_theme_mode, control_page_title, wrapper, autoscroll, version, $page, ready, render_complete, new_message_fn*/
      130935 | dirty[1] & /*$$scope*/
      128) {
        embed_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_wrapper && dirty[0] & /*wrapper*/
      512) {
        updating_wrapper = true;
        embed_changes.wrapper = /*wrapper*/
        ctx2[9];
        add_flush_callback(() => updating_wrapper = false);
      }
      embed.$set(embed_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(embed.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(embed.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      detach(link2);
      if (if_block)
        if_block.d(detaching);
      detach(if_block_anchor);
      destroy_component(embed, detaching);
    }
  };
}
let id = -1;
function create_intersection_store() {
  const intersecting = writable({});
  const els = /* @__PURE__ */ new Map();
  const observer = new IntersectionObserver((entries2) => {
    entries2.forEach((entry) => {
      if (entry.isIntersecting) {
        let _el2 = els.get(entry.target);
        if (_el2 !== void 0)
          intersecting.update((s) => ({ ...s, [_el2]: true }));
      }
    });
  });
  function register(_id2, el) {
    els.set(el, _id2);
    observer.observe(el);
  }
  return {
    register,
    subscribe: intersecting.subscribe
  };
}
let loader_status = "complete";
function instance($$self, $$props, $$invalidate) {
  let config;
  let $_;
  let $page;
  component_subscribe($$self, $format, ($$value) => $$invalidate(29, $_ = $$value));
  component_subscribe($$self, page, ($$value) => $$invalidate(16, $page = $$value));
  setupi18n();
  const dispatch = createEventDispatcher();
  let { data } = $$props;
  let { autoscroll = false } = $$props;
  let { version = "5-5-0" } = $$props;
  let { initial_height } = $$props;
  let { app_mode = true } = $$props;
  let { is_embed = false } = $$props;
  let { theme_mode = "system" } = $$props;
  let { control_page_title = true } = $$props;
  let { container } = $$props;
  let stream2;
  function handle_theme_mode(target) {
    let new_theme_mode;
    const url = new URL(window.location.toString());
    const url_color_mode = url.searchParams.get("__theme");
    new_theme_mode = theme_mode || url_color_mode || "system";
    if (new_theme_mode === "dark" || new_theme_mode === "light") {
      apply_theme(target, new_theme_mode);
    } else {
      new_theme_mode = sync_system_theme(target);
    }
    return new_theme_mode;
  }
  function sync_system_theme(target) {
    var _a2;
    const theme = update_scheme();
    (_a2 = window == null ? void 0 : window.matchMedia("(prefers-color-scheme: dark)")) == null ? void 0 : _a2.addEventListener("change", update_scheme);
    function update_scheme() {
      var _a3;
      let _theme = ((_a3 = window == null ? void 0 : window.matchMedia) == null ? void 0 : _a3.call(window, "(prefers-color-scheme: dark)").matches) ? "dark" : "light";
      apply_theme(target, _theme);
      return _theme;
    }
    return theme;
  }
  function apply_theme(target, theme) {
    const dark_class_element = is_embed ? target.parentElement : document.body;
    const bg_element = is_embed ? target : target.parentElement;
    bg_element.style.background = "var(--body-background-fill)";
    if (theme === "dark") {
      dark_class_element.classList.add("dark");
    } else {
      dark_class_element.classList.remove("dark");
    }
  }
  let active_theme_mode;
  {
    active_theme_mode = handle_theme_mode(document.body);
  }
  let { space: space2 } = $$props;
  let _id2 = id++;
  let wrapper;
  let ready = false;
  let render_complete = false;
  $_("common.loading") + "...";
  let intersecting = {
    register: () => {
    },
    subscribe: writable({}).subscribe
  };
  let app = data.app;
  function handle_status(_status) {
  }
  onMount(async () => {
    $$invalidate(12, config = data.config);
    window.gradio_config = config;
    window.gradio_config = data.config;
    $$invalidate(12, config = data.config);
    if (!app.config) {
      throw new Error("Could not resolve app config");
    }
    window.__gradio_space__ = config.space_id;
    window.__is_colab__ = config.is_colab;
    dispatch("loaded");
    if (config.dev_mode) {
      setTimeout(
        () => {
          const { host } = new URL(data.api_url);
          let url = new URL(`http://${host}${app.api_prefix}/dev/reload`);
          stream2 = new EventSource(url);
          stream2.addEventListener("error", async (e) => {
            new_message_fn("Error", "Error reloading app", "error");
            console.error(JSON.parse(e.data));
          });
          stream2.addEventListener("reload", async (event) => {
            app.close();
            $$invalidate(11, app = await Client.connect(data.api_url, {
              status_callback: handle_status,
              with_null_state: true,
              events: ["data", "log", "status", "render"]
            }));
            if (!app.config) {
              throw new Error("Could not resolve app config");
            }
            $$invalidate(12, config = app.config);
            window.__gradio_space__ = config.space_id;
          });
        },
        200
      );
    }
  });
  let new_message_fn;
  onMount(async () => {
    intersecting = create_intersection_store();
    intersecting.register(_id2, wrapper);
  });
  let spaceheader;
  async function mount_space_header(space_id, is_embed2) {
    if (space_id && !is_embed2 && window.self === window.top) {
      if (spaceheader) {
        spaceheader.remove();
        spaceheader = void 0;
      }
      const header = await init(space_id);
      if (header)
        spaceheader = header.element;
    }
  }
  onDestroy(() => {
    spaceheader == null ? void 0 : spaceheader.remove();
  });
  function switch_instance_ready_binding(value) {
    ready = value;
    $$invalidate(14, ready);
  }
  function switch_instance_render_complete_binding(value) {
    render_complete = value;
    $$invalidate(10, render_complete);
  }
  function switch_instance_add_new_message_binding(value) {
    new_message_fn = value;
    $$invalidate(15, new_message_fn);
  }
  function embed_wrapper_binding(value) {
    wrapper = value;
    $$invalidate(9, wrapper);
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("autoscroll" in $$props2)
      $$invalidate(1, autoscroll = $$props2.autoscroll);
    if ("version" in $$props2)
      $$invalidate(2, version = $$props2.version);
    if ("initial_height" in $$props2)
      $$invalidate(3, initial_height = $$props2.initial_height);
    if ("app_mode" in $$props2)
      $$invalidate(4, app_mode = $$props2.app_mode);
    if ("is_embed" in $$props2)
      $$invalidate(5, is_embed = $$props2.is_embed);
    if ("theme_mode" in $$props2)
      $$invalidate(17, theme_mode = $$props2.theme_mode);
    if ("control_page_title" in $$props2)
      $$invalidate(6, control_page_title = $$props2.control_page_title);
    if ("container" in $$props2)
      $$invalidate(7, container = $$props2.container);
    if ("space" in $$props2)
      $$invalidate(8, space2 = $$props2.space);
  };
  $$self.$$.update = () => {
    var _a2;
    if ($$self.$$.dirty[0] & /*data*/
    1) {
      $$invalidate(12, config = data.config);
    }
    if ($$self.$$.dirty[0] & /*config*/
    4096) {
      if (config == null ? void 0 : config.app_id) {
        config.app_id;
      }
    }
    if ($$self.$$.dirty[0] & /*render_complete, wrapper*/
    1536) {
      if (render_complete) {
        wrapper.dispatchEvent(new CustomEvent(
          "render",
          {
            bubbles: true,
            cancelable: false,
            composed: true
          }
        ));
      }
    }
    if ($$self.$$.dirty[0] & /*app, is_embed*/
    2080) {
      (app == null ? void 0 : app.config) && browser && mount_space_header((_a2 = app == null ? void 0 : app.config) == null ? void 0 : _a2.space_id, is_embed);
    }
  };
  return [
    data,
    autoscroll,
    version,
    initial_height,
    app_mode,
    is_embed,
    control_page_title,
    container,
    space2,
    wrapper,
    render_complete,
    app,
    config,
    active_theme_mode,
    ready,
    new_message_fn,
    $page,
    theme_mode,
    switch_instance_ready_binding,
    switch_instance_render_complete_binding,
    switch_instance_add_new_message_binding,
    embed_wrapper_binding
  ];
}
class Page extends SvelteComponent {
  constructor(options2) {
    super();
    init$2(
      this,
      options2,
      instance,
      create_fragment,
      safe_not_equal,
      {
        data: 0,
        autoscroll: 1,
        version: 2,
        initial_height: 3,
        app_mode: 4,
        is_embed: 5,
        theme_mode: 17,
        control_page_title: 6,
        container: 7,
        space: 8
      },
      null,
      [-1, -1]
    );
  }
}
export {
  Block as B,
  Clear2 as C,
  Embed as E,
  IconButton as I,
  Loader as L,
  MarkdownCode as M,
  Prism$1 as P,
  Static as S,
  Toast as T,
  _page as _,
  process_langs as a,
  Button as b,
  create_components as c,
  ShareError as d,
  Textbox as e,
  BlockTitle as f,
  getDefaultExportFromCjs as g,
  prepare_files as h,
  Index2 as i,
  Info$1 as j,
  colors as k,
  css_units as l,
  mount_css as m,
  copy as n,
  ordered_colors as o,
  prefix_css as p,
  Check as q,
  Copy as r,
  setupi18n as s,
  commonjsGlobal as t,
  uploadToHuggingFace as u,
  Send as v,
  Square as w,
  format_time as x,
  getAugmentedNamespace as y,
  Page as z
};
